<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20210713140915.1"><vh>@settings</vh>
<v t="leo.20210713140915.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20210713140915.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20210713140756.1"><vh>recursive importer</vh></v>
<v t="leo.20210713140751.2"><vh>About vrep_env</vh></v>
<v t="leo.20210713140956.1"><vh>imported files</vh>
<v t="leo.20210713140956.2"><vh>@path ./../</vh>
<v t="leo.20210713140956.3"><vh>@clean setup.py</vh>
<v t="leo.20210713140956.4"><vh>Declarations</vh></v>
</v>
<v t="leo.20210713140956.6"><vh>@path examples</vh>
<v t="leo.20210713140956.7"><vh>@path envs</vh>
<v t="leo.20210713140956.8"><vh>@clean cartpole_continuous_vrep_env.py</vh>
<v t="leo.20210713140956.9"><vh>Declarations</vh></v>
<v t="leo.20210713140956.10"><vh>class CartPoleContinuousVrepEnv(vrep_env.VrepEnv)</vh>
<v t="leo.20210713140956.11"><vh>CartPoleContinuousVrepEnv.__init__</vh></v>
<v t="leo.20210713140956.12"><vh>CartPoleContinuousVrepEnv.seed</vh></v>
<v t="leo.20210713140956.13"><vh>CartPoleContinuousVrepEnv._make_observation</vh></v>
<v t="leo.20210713140956.14"><vh>CartPoleContinuousVrepEnv._make_action</vh></v>
<v t="leo.20210713140956.15"><vh>CartPoleContinuousVrepEnv.step</vh></v>
<v t="leo.20210713140956.16"><vh>CartPoleContinuousVrepEnv.reset</vh></v>
<v t="leo.20210713140956.17"><vh>CartPoleContinuousVrepEnv.render</vh></v>
<v t="leo.20210713140956.18"><vh>CartPoleContinuousVrepEnv.close</vh></v>
</v>
<v t="leo.20210713140956.19"><vh>main</vh></v>
</v>
<v t="leo.20210713140956.20"><vh>@clean cartpole_vrep_env.py</vh>
<v t="leo.20210713140956.21"><vh>Declarations</vh></v>
<v t="leo.20210713140956.22"><vh>class CartPoleVrepEnv(vrep_env.VrepEnv)</vh>
<v t="leo.20210713140956.23"><vh>CartPoleVrepEnv.__init__</vh></v>
<v t="leo.20210713140956.24"><vh>CartPoleVrepEnv.seed</vh></v>
<v t="leo.20210713140956.25"><vh>CartPoleVrepEnv._make_observation</vh></v>
<v t="leo.20210713140956.26"><vh>CartPoleVrepEnv._make_action</vh></v>
<v t="leo.20210713140956.27"><vh>CartPoleVrepEnv.step</vh></v>
<v t="leo.20210713140956.28"><vh>CartPoleVrepEnv.reset</vh></v>
<v t="leo.20210713140956.29"><vh>CartPoleVrepEnv.render</vh></v>
<v t="leo.20210713140956.30"><vh>CartPoleVrepEnv.close</vh></v>
</v>
<v t="leo.20210713140956.31"><vh>main</vh></v>
</v>
<v t="leo.20210713140956.32"><vh>@clean example_vrep_env.py</vh>
<v t="leo.20210713140956.33"><vh>Declarations</vh></v>
<v t="leo.20210713140956.34"><vh>class ExampleVrepEnv(vrep_env.VrepEnv)</vh>
<v t="leo.20210713140956.35"><vh>ExampleVrepEnv.__init__</vh></v>
<v t="leo.20210713140956.36"><vh>ExampleVrepEnv._make_observation</vh></v>
<v t="leo.20210713140956.37"><vh>ExampleVrepEnv._make_action</vh></v>
<v t="leo.20210713140956.38"><vh>ExampleVrepEnv.step</vh></v>
<v t="leo.20210713140956.39"><vh>ExampleVrepEnv.reset</vh></v>
<v t="leo.20210713140956.40"><vh>ExampleVrepEnv.render</vh></v>
<v t="leo.20210713140956.41"><vh>ExampleVrepEnv.seed</vh></v>
</v>
<v t="leo.20210713140956.42"><vh>main</vh></v>
</v>
<v t="leo.20210713140956.43"><vh>@clean hopper_vrep_env.py</vh>
<v t="leo.20210713140956.44"><vh>Declarations</vh></v>
<v t="leo.20210713140956.45"><vh>class HopperVrepEnv(vrep_env.VrepEnv)</vh>
<v t="leo.20210713140956.46"><vh>HopperVrepEnv.__init__</vh></v>
<v t="leo.20210713140956.47"><vh>HopperVrepEnv._make_observation</vh></v>
<v t="leo.20210713140956.48"><vh>HopperVrepEnv._make_action</vh></v>
<v t="leo.20210713140956.49"><vh>HopperVrepEnv.step</vh></v>
<v t="leo.20210713140956.50"><vh>HopperVrepEnv.reset</vh></v>
<v t="leo.20210713140956.51"><vh>HopperVrepEnv.render</vh></v>
<v t="leo.20210713140956.52"><vh>HopperVrepEnv.seed</vh></v>
</v>
<v t="leo.20210713140956.53"><vh>main</vh></v>
</v>
<v t="leo.20210713140956.54"><vh>@path vrep_env</vh>
<v t="leo.20210713140956.55"><vh>@clean sim.py</vh>
<v t="leo.20210713140956.56"><vh>Declarations</vh></v>
<v t="leo.20210713140956.57"><vh>simxGetJointPosition</vh></v>
<v t="leo.20210713140956.58"><vh>simxSetJointPosition</vh></v>
<v t="leo.20210713140956.59"><vh>simxGetJointMatrix</vh></v>
<v t="leo.20210713140956.60"><vh>simxSetSphericalJointMatrix</vh></v>
<v t="leo.20210713140956.61"><vh>simxSetJointTargetVelocity</vh></v>
<v t="leo.20210713140956.62"><vh>simxSetJointTargetPosition</vh></v>
<v t="leo.20210713140956.63"><vh>simxJointGetForce</vh></v>
<v t="leo.20210713140956.64"><vh>simxGetJointForce</vh></v>
<v t="leo.20210713140956.65"><vh>simxGetJointMaxForce</vh></v>
<v t="leo.20210713140956.66"><vh>simxSetJointForce</vh></v>
<v t="leo.20210713140956.67"><vh>simxSetJointMaxForce</vh></v>
<v t="leo.20210713140956.68"><vh>simxReadForceSensor</vh></v>
<v t="leo.20210713140956.69"><vh>simxBreakForceSensor</vh></v>
<v t="leo.20210713140956.70"><vh>simxReadVisionSensor</vh></v>
<v t="leo.20210713140956.71"><vh>simxGetObjectHandle</vh></v>
<v t="leo.20210713140956.72"><vh>simxGetVisionSensorImage</vh></v>
<v t="leo.20210713140956.73"><vh>simxSetVisionSensorImage</vh></v>
<v t="leo.20210713140956.74"><vh>simxGetVisionSensorDepthBuffer</vh></v>
<v t="leo.20210713140956.75"><vh>simxGetObjectChild</vh></v>
<v t="leo.20210713140956.76"><vh>simxGetObjectParent</vh></v>
<v t="leo.20210713140956.77"><vh>simxReadProximitySensor</vh></v>
<v t="leo.20210713140956.78"><vh>simxLoadModel</vh></v>
<v t="leo.20210713140956.79"><vh>simxLoadUI</vh></v>
<v t="leo.20210713140956.80"><vh>simxLoadScene</vh></v>
<v t="leo.20210713140956.81"><vh>simxStartSimulation</vh></v>
<v t="leo.20210713140956.82"><vh>simxPauseSimulation</vh></v>
<v t="leo.20210713140956.83"><vh>simxStopSimulation</vh></v>
<v t="leo.20210713140956.84"><vh>simxGetUIHandle</vh></v>
<v t="leo.20210713140956.85"><vh>simxGetUISlider</vh></v>
<v t="leo.20210713140956.86"><vh>simxSetUISlider</vh></v>
<v t="leo.20210713140956.87"><vh>simxGetUIEventButton</vh></v>
<v t="leo.20210713140956.88"><vh>simxGetUIButtonProperty</vh></v>
<v t="leo.20210713140956.89"><vh>simxSetUIButtonProperty</vh></v>
<v t="leo.20210713140956.90"><vh>simxAddStatusbarMessage</vh></v>
<v t="leo.20210713140956.91"><vh>simxAuxiliaryConsoleOpen</vh></v>
<v t="leo.20210713140956.92"><vh>simxAuxiliaryConsoleClose</vh></v>
<v t="leo.20210713140956.93"><vh>simxAuxiliaryConsolePrint</vh></v>
<v t="leo.20210713140956.94"><vh>simxAuxiliaryConsoleShow</vh></v>
<v t="leo.20210713140956.95"><vh>simxGetObjectOrientation</vh></v>
<v t="leo.20210713140956.96"><vh>simxGetObjectQuaternion</vh></v>
<v t="leo.20210713140956.97"><vh>simxGetObjectPosition</vh></v>
<v t="leo.20210713140956.98"><vh>simxSetObjectOrientation</vh></v>
<v t="leo.20210713140956.99"><vh>simxSetObjectQuaternion</vh></v>
<v t="leo.20210713140956.100"><vh>simxSetObjectPosition</vh></v>
<v t="leo.20210713140956.101"><vh>simxSetObjectParent</vh></v>
<v t="leo.20210713140956.102"><vh>simxSetUIButtonLabel</vh></v>
<v t="leo.20210713140956.103"><vh>simxGetLastErrors</vh></v>
<v t="leo.20210713140956.104"><vh>simxGetArrayParameter</vh></v>
<v t="leo.20210713140956.105"><vh>simxSetArrayParameter</vh></v>
<v t="leo.20210713140956.106"><vh>simxGetBooleanParameter</vh></v>
<v t="leo.20210713140956.107"><vh>simxSetBooleanParameter</vh></v>
<v t="leo.20210713140956.108"><vh>simxGetIntegerParameter</vh></v>
<v t="leo.20210713140956.109"><vh>simxSetIntegerParameter</vh></v>
<v t="leo.20210713140956.110"><vh>simxGetFloatingParameter</vh></v>
<v t="leo.20210713140956.111"><vh>simxSetFloatingParameter</vh></v>
<v t="leo.20210713140956.112"><vh>simxGetStringParameter</vh></v>
<v t="leo.20210713140956.113"><vh>simxGetCollisionHandle</vh></v>
<v t="leo.20210713140956.114"><vh>simxGetCollectionHandle</vh></v>
<v t="leo.20210713140956.115"><vh>simxGetDistanceHandle</vh></v>
<v t="leo.20210713140956.116"><vh>simxReadCollision</vh></v>
<v t="leo.20210713140956.117"><vh>simxReadDistance</vh></v>
<v t="leo.20210713140956.118"><vh>simxRemoveObject</vh></v>
<v t="leo.20210713140956.119"><vh>simxRemoveModel</vh></v>
<v t="leo.20210713140956.120"><vh>simxRemoveUI</vh></v>
<v t="leo.20210713140956.121"><vh>simxCloseScene</vh></v>
<v t="leo.20210713140956.122"><vh>simxGetObjects</vh></v>
<v t="leo.20210713140956.123"><vh>simxDisplayDialog</vh></v>
<v t="leo.20210713140956.124"><vh>simxEndDialog</vh></v>
<v t="leo.20210713140956.125"><vh>simxGetDialogInput</vh></v>
<v t="leo.20210713140956.126"><vh>simxGetDialogResult</vh></v>
<v t="leo.20210713140956.127"><vh>simxCopyPasteObjects</vh></v>
<v t="leo.20210713140956.128"><vh>simxGetObjectSelection</vh></v>
<v t="leo.20210713140956.129"><vh>simxSetObjectSelection</vh></v>
<v t="leo.20210713140956.130"><vh>simxClearFloatSignal</vh></v>
<v t="leo.20210713140956.131"><vh>simxClearIntegerSignal</vh></v>
<v t="leo.20210713140956.132"><vh>simxClearStringSignal</vh></v>
<v t="leo.20210713140956.133"><vh>simxGetFloatSignal</vh></v>
<v t="leo.20210713140956.134"><vh>simxGetIntegerSignal</vh></v>
<v t="leo.20210713140956.135"><vh>simxGetStringSignal</vh></v>
<v t="leo.20210713140956.136"><vh>simxGetAndClearStringSignal</vh></v>
<v t="leo.20210713140956.137"><vh>simxReadStringStream</vh></v>
<v t="leo.20210713140956.138"><vh>simxSetFloatSignal</vh></v>
<v t="leo.20210713140956.139"><vh>simxSetIntegerSignal</vh></v>
<v t="leo.20210713140956.140"><vh>simxSetStringSignal</vh></v>
<v t="leo.20210713140956.141"><vh>simxAppendStringSignal</vh></v>
<v t="leo.20210713140956.142"><vh>simxWriteStringStream</vh></v>
<v t="leo.20210713140956.143"><vh>simxGetObjectFloatParameter</vh></v>
<v t="leo.20210713140956.144"><vh>simxSetObjectFloatParameter</vh></v>
<v t="leo.20210713140956.145"><vh>simxGetObjectIntParameter</vh></v>
<v t="leo.20210713140956.146"><vh>simxSetObjectIntParameter</vh></v>
<v t="leo.20210713140956.147"><vh>simxGetModelProperty</vh></v>
<v t="leo.20210713140956.148"><vh>simxSetModelProperty</vh></v>
<v t="leo.20210713140956.149"><vh>simxStart</vh></v>
<v t="leo.20210713140956.150"><vh>simxFinish</vh></v>
<v t="leo.20210713140956.151"><vh>simxGetPingTime</vh></v>
<v t="leo.20210713140956.152"><vh>simxGetLastCmdTime</vh></v>
<v t="leo.20210713140956.153"><vh>simxSynchronousTrigger</vh></v>
<v t="leo.20210713140956.154"><vh>simxSynchronous</vh></v>
<v t="leo.20210713140956.155"><vh>simxPauseCommunication</vh></v>
<v t="leo.20210713140956.156"><vh>simxGetInMessageInfo</vh></v>
<v t="leo.20210713140956.157"><vh>simxGetOutMessageInfo</vh></v>
<v t="leo.20210713140956.158"><vh>simxGetConnectionId</vh></v>
<v t="leo.20210713140956.159"><vh>simxCreateBuffer</vh></v>
<v t="leo.20210713140956.160"><vh>simxReleaseBuffer</vh></v>
<v t="leo.20210713140956.161"><vh>simxTransferFile</vh></v>
<v t="leo.20210713140956.162"><vh>simxEraseFile</vh></v>
<v t="leo.20210713140956.163"><vh>simxCreateDummy</vh></v>
<v t="leo.20210713140956.164"><vh>simxQuery</vh></v>
<v t="leo.20210713140956.165"><vh>simxGetObjectGroupData</vh></v>
<v t="leo.20210713140956.166"><vh>simxCallScriptFunction</vh></v>
<v t="leo.20210713140956.167"><vh>simxGetObjectVelocity</vh></v>
<v t="leo.20210713140956.168"><vh>simxPackInts</vh></v>
<v t="leo.20210713140956.169"><vh>simxUnpackInts</vh></v>
<v t="leo.20210713140956.170"><vh>simxPackFloats</vh></v>
<v t="leo.20210713140956.171"><vh>simxUnpackFloats</vh></v>
</v>
<v t="leo.20210713140956.172"><vh>@clean simConst.py</vh>
<v t="leo.20210713140956.173"><vh>Declarations</vh></v>
</v>
<v t="leo.20210713140956.174"><vh>@clean vrep.py</vh>
<v t="leo.20210713140956.175"><vh>Declarations</vh></v>
<v t="leo.20210713140956.176"><vh>simxGetJointPosition</vh></v>
<v t="leo.20210713140956.177"><vh>simxSetJointPosition</vh></v>
<v t="leo.20210713140956.178"><vh>simxGetJointMatrix</vh></v>
<v t="leo.20210713140956.179"><vh>simxSetSphericalJointMatrix</vh></v>
<v t="leo.20210713140956.180"><vh>simxSetJointTargetVelocity</vh></v>
<v t="leo.20210713140956.181"><vh>simxSetJointTargetPosition</vh></v>
<v t="leo.20210713140956.182"><vh>simxJointGetForce</vh></v>
<v t="leo.20210713140956.183"><vh>simxGetJointForce</vh></v>
<v t="leo.20210713140956.184"><vh>simxGetJointMaxForce</vh></v>
<v t="leo.20210713140956.185"><vh>simxSetJointForce</vh></v>
<v t="leo.20210713140956.186"><vh>simxSetJointMaxForce</vh></v>
<v t="leo.20210713140956.187"><vh>simxReadForceSensor</vh></v>
<v t="leo.20210713140956.188"><vh>simxBreakForceSensor</vh></v>
<v t="leo.20210713140956.189"><vh>simxReadVisionSensor</vh></v>
<v t="leo.20210713140956.190"><vh>simxGetObjectHandle</vh></v>
<v t="leo.20210713140956.191"><vh>simxGetVisionSensorImage</vh></v>
<v t="leo.20210713140956.192"><vh>simxSetVisionSensorImage</vh></v>
<v t="leo.20210713140956.193"><vh>simxGetVisionSensorDepthBuffer</vh></v>
<v t="leo.20210713140956.194"><vh>simxGetObjectChild</vh></v>
<v t="leo.20210713140956.195"><vh>simxGetObjectParent</vh></v>
<v t="leo.20210713140956.196"><vh>simxReadProximitySensor</vh></v>
<v t="leo.20210713140956.197"><vh>simxLoadModel</vh></v>
<v t="leo.20210713140956.198"><vh>simxLoadUI</vh></v>
<v t="leo.20210713140956.199"><vh>simxLoadScene</vh></v>
<v t="leo.20210713140956.200"><vh>simxStartSimulation</vh></v>
<v t="leo.20210713140956.201"><vh>simxPauseSimulation</vh></v>
<v t="leo.20210713140956.202"><vh>simxStopSimulation</vh></v>
<v t="leo.20210713140956.203"><vh>simxGetUIHandle</vh></v>
<v t="leo.20210713140956.204"><vh>simxGetUISlider</vh></v>
<v t="leo.20210713140956.205"><vh>simxSetUISlider</vh></v>
<v t="leo.20210713140956.206"><vh>simxGetUIEventButton</vh></v>
<v t="leo.20210713140956.207"><vh>simxGetUIButtonProperty</vh></v>
<v t="leo.20210713140956.208"><vh>simxSetUIButtonProperty</vh></v>
<v t="leo.20210713140956.209"><vh>simxAddStatusbarMessage</vh></v>
<v t="leo.20210713140956.210"><vh>simxAuxiliaryConsoleOpen</vh></v>
<v t="leo.20210713140956.211"><vh>simxAuxiliaryConsoleClose</vh></v>
<v t="leo.20210713140956.212"><vh>simxAuxiliaryConsolePrint</vh></v>
<v t="leo.20210713140956.213"><vh>simxAuxiliaryConsoleShow</vh></v>
<v t="leo.20210713140956.214"><vh>simxGetObjectOrientation</vh></v>
<v t="leo.20210713140956.215"><vh>simxGetObjectQuaternion</vh></v>
<v t="leo.20210713140956.216"><vh>simxGetObjectPosition</vh></v>
<v t="leo.20210713140956.217"><vh>simxSetObjectOrientation</vh></v>
<v t="leo.20210713140956.218"><vh>simxSetObjectQuaternion</vh></v>
<v t="leo.20210713140956.219"><vh>simxSetObjectPosition</vh></v>
<v t="leo.20210713140956.220"><vh>simxSetObjectParent</vh></v>
<v t="leo.20210713140956.221"><vh>simxSetUIButtonLabel</vh></v>
<v t="leo.20210713140956.222"><vh>simxGetLastErrors</vh></v>
<v t="leo.20210713140956.223"><vh>simxGetArrayParameter</vh></v>
<v t="leo.20210713140956.224"><vh>simxSetArrayParameter</vh></v>
<v t="leo.20210713140956.225"><vh>simxGetBooleanParameter</vh></v>
<v t="leo.20210713140956.226"><vh>simxSetBooleanParameter</vh></v>
<v t="leo.20210713140956.227"><vh>simxGetIntegerParameter</vh></v>
<v t="leo.20210713140956.228"><vh>simxSetIntegerParameter</vh></v>
<v t="leo.20210713140956.229"><vh>simxGetFloatingParameter</vh></v>
<v t="leo.20210713140956.230"><vh>simxSetFloatingParameter</vh></v>
<v t="leo.20210713140956.231"><vh>simxGetStringParameter</vh></v>
<v t="leo.20210713140956.232"><vh>simxGetCollisionHandle</vh></v>
<v t="leo.20210713140956.233"><vh>simxGetCollectionHandle</vh></v>
<v t="leo.20210713140956.234"><vh>simxGetDistanceHandle</vh></v>
<v t="leo.20210713140956.235"><vh>simxReadCollision</vh></v>
<v t="leo.20210713140956.236"><vh>simxReadDistance</vh></v>
<v t="leo.20210713140956.237"><vh>simxRemoveObject</vh></v>
<v t="leo.20210713140956.238"><vh>simxRemoveModel</vh></v>
<v t="leo.20210713140956.239"><vh>simxRemoveUI</vh></v>
<v t="leo.20210713140956.240"><vh>simxCloseScene</vh></v>
<v t="leo.20210713140956.241"><vh>simxGetObjects</vh></v>
<v t="leo.20210713140956.242"><vh>simxDisplayDialog</vh></v>
<v t="leo.20210713140956.243"><vh>simxEndDialog</vh></v>
<v t="leo.20210713140956.244"><vh>simxGetDialogInput</vh></v>
<v t="leo.20210713140956.245"><vh>simxGetDialogResult</vh></v>
<v t="leo.20210713140956.246"><vh>simxCopyPasteObjects</vh></v>
<v t="leo.20210713140956.247"><vh>simxGetObjectSelection</vh></v>
<v t="leo.20210713140956.248"><vh>simxSetObjectSelection</vh></v>
<v t="leo.20210713140956.249"><vh>simxClearFloatSignal</vh></v>
<v t="leo.20210713140956.250"><vh>simxClearIntegerSignal</vh></v>
<v t="leo.20210713140956.251"><vh>simxClearStringSignal</vh></v>
<v t="leo.20210713140956.252"><vh>simxGetFloatSignal</vh></v>
<v t="leo.20210713140956.253"><vh>simxGetIntegerSignal</vh></v>
<v t="leo.20210713140956.254"><vh>simxGetStringSignal</vh></v>
<v t="leo.20210713140956.255"><vh>simxGetAndClearStringSignal</vh></v>
<v t="leo.20210713140956.256"><vh>simxReadStringStream</vh></v>
<v t="leo.20210713140956.257"><vh>simxSetFloatSignal</vh></v>
<v t="leo.20210713140956.258"><vh>simxSetIntegerSignal</vh></v>
<v t="leo.20210713140956.259"><vh>simxSetStringSignal</vh></v>
<v t="leo.20210713140956.260"><vh>simxAppendStringSignal</vh></v>
<v t="leo.20210713140956.261"><vh>simxWriteStringStream</vh></v>
<v t="leo.20210713140956.262"><vh>simxGetObjectFloatParameter</vh></v>
<v t="leo.20210713140956.263"><vh>simxSetObjectFloatParameter</vh></v>
<v t="leo.20210713140956.264"><vh>simxGetObjectIntParameter</vh></v>
<v t="leo.20210713140956.265"><vh>simxSetObjectIntParameter</vh></v>
<v t="leo.20210713140956.266"><vh>simxGetModelProperty</vh></v>
<v t="leo.20210713140956.267"><vh>simxSetModelProperty</vh></v>
<v t="leo.20210713140956.268"><vh>simxStart</vh></v>
<v t="leo.20210713140956.269"><vh>simxFinish</vh></v>
<v t="leo.20210713140956.270"><vh>simxGetPingTime</vh></v>
<v t="leo.20210713140956.271"><vh>simxGetLastCmdTime</vh></v>
<v t="leo.20210713140956.272"><vh>simxSynchronousTrigger</vh></v>
<v t="leo.20210713140956.273"><vh>simxSynchronous</vh></v>
<v t="leo.20210713140956.274"><vh>simxPauseCommunication</vh></v>
<v t="leo.20210713140956.275"><vh>simxGetInMessageInfo</vh></v>
<v t="leo.20210713140956.276"><vh>simxGetOutMessageInfo</vh></v>
<v t="leo.20210713140956.277"><vh>simxGetConnectionId</vh></v>
<v t="leo.20210713140956.278"><vh>simxCreateBuffer</vh></v>
<v t="leo.20210713140956.279"><vh>simxReleaseBuffer</vh></v>
<v t="leo.20210713140956.280"><vh>simxTransferFile</vh></v>
<v t="leo.20210713140956.281"><vh>simxEraseFile</vh></v>
<v t="leo.20210713140956.282"><vh>simxCreateDummy</vh></v>
<v t="leo.20210713140956.283"><vh>simxQuery</vh></v>
<v t="leo.20210713140956.284"><vh>simxGetObjectGroupData</vh></v>
<v t="leo.20210713140956.285"><vh>simxCallScriptFunction</vh></v>
<v t="leo.20210713140956.286"><vh>simxGetObjectVelocity</vh></v>
<v t="leo.20210713140956.287"><vh>simxPackInts</vh></v>
<v t="leo.20210713140956.288"><vh>simxUnpackInts</vh></v>
<v t="leo.20210713140956.289"><vh>simxPackFloats</vh></v>
<v t="leo.20210713140956.290"><vh>simxUnpackFloats</vh></v>
</v>
<v t="leo.20210713140956.291"><vh>@clean vrep_env.py</vh>
<v t="leo.20210713140956.292"><vh>Declarations</vh></v>
<v t="leo.20210713140956.293"><vh>class VrepEnv(gym.Env)</vh>
<v t="leo.20210713140956.294"><vh>VrepEnv.__init__</vh></v>
<v t="leo.20210713140956.295"><vh>VrepEnv.RAPI_rc</vh></v>
<v t="leo.20210713140956.296"><vh>VrepEnv.connect</vh></v>
<v t="leo.20210713140956.297"><vh>VrepEnv.disconnect</vh></v>
<v t="leo.20210713140956.298"><vh>VrepEnv.load_scene</vh></v>
<v t="leo.20210713140956.299"><vh>VrepEnv.close_scene</vh></v>
<v t="leo.20210713140956.300"><vh>VrepEnv.start_simulation</vh></v>
<v t="leo.20210713140956.301"><vh>VrepEnv.stop_simulation</vh></v>
<v t="leo.20210713140956.302"><vh>VrepEnv.step_simulation</vh></v>
<v t="leo.20210713140956.303"><vh>VrepEnv.add_statusbar_message</vh></v>
<v t="leo.20210713140956.304"><vh>VrepEnv.get_object_handle</vh></v>
<v t="leo.20210713140956.305"><vh>VrepEnv.obj_get_position</vh></v>
<v t="leo.20210713140956.306"><vh>VrepEnv.obj_get_orientation</vh></v>
<v t="leo.20210713140956.307"><vh>VrepEnv.obj_get_orientation_continuous</vh></v>
<v t="leo.20210713140956.308"><vh>VrepEnv.obj_get_velocity</vh></v>
<v t="leo.20210713140956.309"><vh>VrepEnv.obj_get_joint_angle</vh></v>
<v t="leo.20210713140956.310"><vh>VrepEnv.obj_get_joint_angle_continuous</vh></v>
<v t="leo.20210713140956.311"><vh>VrepEnv.obj_get_joint_force</vh></v>
<v t="leo.20210713140956.312"><vh>VrepEnv.obj_read_force_sensor</vh></v>
<v t="leo.20210713140956.313"><vh>VrepEnv.obj_get_vision_image</vh></v>
<v t="leo.20210713140956.314"><vh>VrepEnv.obj_set_position_target</vh></v>
<v t="leo.20210713140956.315"><vh>VrepEnv.obj_set_velocity</vh></v>
<v t="leo.20210713140956.316"><vh>VrepEnv.obj_set_force</vh></v>
<v t="leo.20210713140956.317"><vh>VrepEnv.obj_set_position</vh></v>
<v t="leo.20210713140956.318"><vh>VrepEnv.obj_set_orientation</vh></v>
<v t="leo.20210713140956.319"><vh>VrepEnv.get_collision_handle</vh></v>
<v t="leo.20210713140956.320"><vh>VrepEnv.read_collision</vh></v>
<v t="leo.20210713140956.321"><vh>VrepEnv.set_integer_signal</vh></v>
<v t="leo.20210713140956.322"><vh>VrepEnv.set_float_signal</vh></v>
<v t="leo.20210713140956.323"><vh>VrepEnv.set_string_signal</vh></v>
<v t="leo.20210713140956.324"><vh>VrepEnv.get_integer_signal</vh></v>
<v t="leo.20210713140956.325"><vh>VrepEnv.get_float_signal</vh></v>
<v t="leo.20210713140956.326"><vh>VrepEnv.get_string_signal</vh></v>
<v t="leo.20210713140956.327"><vh>VrepEnv.set_boolean_parameter</vh></v>
<v t="leo.20210713140956.328"><vh>VrepEnv.set_integer_parameter</vh></v>
<v t="leo.20210713140956.329"><vh>VrepEnv.set_float_parameter</vh></v>
<v t="leo.20210713140956.330"><vh>VrepEnv.set_array_parameter</vh></v>
<v t="leo.20210713140956.331"><vh>VrepEnv.get_boolean_parameter</vh></v>
<v t="leo.20210713140956.332"><vh>VrepEnv.get_integer_parameter</vh></v>
<v t="leo.20210713140956.333"><vh>VrepEnv.get_float_parameter</vh></v>
<v t="leo.20210713140956.334"><vh>VrepEnv.get_array_parameter</vh></v>
<v t="leo.20210713140956.335"><vh>VrepEnv.call_childscript_function</vh></v>
<v t="leo.20210713140956.336"><vh>VrepEnv.close</vh></v>
</v>
</v>
<v t="leo.20210713140956.337"><vh>@clean __init__.py</vh></v>
</v>
</v>
</v>
<v t="leo.20210713140956.340"><vh>@path vrep_env</vh>
<v t="leo.20210713140956.341"><vh>@clean sim.py</vh>
<v t="leo.20210713140956.342"><vh>Declarations</vh></v>
<v t="leo.20210713140956.343"><vh>simxGetJointPosition</vh></v>
<v t="leo.20210713140956.344"><vh>simxSetJointPosition</vh></v>
<v t="leo.20210713140956.345"><vh>simxGetJointMatrix</vh></v>
<v t="leo.20210713140956.346"><vh>simxSetSphericalJointMatrix</vh></v>
<v t="leo.20210713140956.347"><vh>simxSetJointTargetVelocity</vh></v>
<v t="leo.20210713140956.348"><vh>simxSetJointTargetPosition</vh></v>
<v t="leo.20210713140956.349"><vh>simxJointGetForce</vh></v>
<v t="leo.20210713140956.350"><vh>simxGetJointForce</vh></v>
<v t="leo.20210713140956.351"><vh>simxGetJointMaxForce</vh></v>
<v t="leo.20210713140956.352"><vh>simxSetJointForce</vh></v>
<v t="leo.20210713140956.353"><vh>simxSetJointMaxForce</vh></v>
<v t="leo.20210713140956.354"><vh>simxReadForceSensor</vh></v>
<v t="leo.20210713140956.355"><vh>simxBreakForceSensor</vh></v>
<v t="leo.20210713140956.356"><vh>simxReadVisionSensor</vh></v>
<v t="leo.20210713140956.357"><vh>simxGetObjectHandle</vh></v>
<v t="leo.20210713140956.358"><vh>simxGetVisionSensorImage</vh></v>
<v t="leo.20210713140956.359"><vh>simxSetVisionSensorImage</vh></v>
<v t="leo.20210713140956.360"><vh>simxGetVisionSensorDepthBuffer</vh></v>
<v t="leo.20210713140956.361"><vh>simxGetObjectChild</vh></v>
<v t="leo.20210713140956.362"><vh>simxGetObjectParent</vh></v>
<v t="leo.20210713140956.363"><vh>simxReadProximitySensor</vh></v>
<v t="leo.20210713140956.364"><vh>simxLoadModel</vh></v>
<v t="leo.20210713140956.365"><vh>simxLoadUI</vh></v>
<v t="leo.20210713140956.366"><vh>simxLoadScene</vh></v>
<v t="leo.20210713140956.367"><vh>simxStartSimulation</vh></v>
<v t="leo.20210713140956.368"><vh>simxPauseSimulation</vh></v>
<v t="leo.20210713140956.369"><vh>simxStopSimulation</vh></v>
<v t="leo.20210713140956.370"><vh>simxGetUIHandle</vh></v>
<v t="leo.20210713140956.371"><vh>simxGetUISlider</vh></v>
<v t="leo.20210713140956.372"><vh>simxSetUISlider</vh></v>
<v t="leo.20210713140956.373"><vh>simxGetUIEventButton</vh></v>
<v t="leo.20210713140956.374"><vh>simxGetUIButtonProperty</vh></v>
<v t="leo.20210713140956.375"><vh>simxSetUIButtonProperty</vh></v>
<v t="leo.20210713140956.376"><vh>simxAddStatusbarMessage</vh></v>
<v t="leo.20210713140956.377"><vh>simxAuxiliaryConsoleOpen</vh></v>
<v t="leo.20210713140956.378"><vh>simxAuxiliaryConsoleClose</vh></v>
<v t="leo.20210713140956.379"><vh>simxAuxiliaryConsolePrint</vh></v>
<v t="leo.20210713140956.380"><vh>simxAuxiliaryConsoleShow</vh></v>
<v t="leo.20210713140956.381"><vh>simxGetObjectOrientation</vh></v>
<v t="leo.20210713140956.382"><vh>simxGetObjectQuaternion</vh></v>
<v t="leo.20210713140956.383"><vh>simxGetObjectPosition</vh></v>
<v t="leo.20210713140956.384"><vh>simxSetObjectOrientation</vh></v>
<v t="leo.20210713140956.385"><vh>simxSetObjectQuaternion</vh></v>
<v t="leo.20210713140956.386"><vh>simxSetObjectPosition</vh></v>
<v t="leo.20210713140956.387"><vh>simxSetObjectParent</vh></v>
<v t="leo.20210713140956.388"><vh>simxSetUIButtonLabel</vh></v>
<v t="leo.20210713140956.389"><vh>simxGetLastErrors</vh></v>
<v t="leo.20210713140956.390"><vh>simxGetArrayParameter</vh></v>
<v t="leo.20210713140956.391"><vh>simxSetArrayParameter</vh></v>
<v t="leo.20210713140956.392"><vh>simxGetBooleanParameter</vh></v>
<v t="leo.20210713140956.393"><vh>simxSetBooleanParameter</vh></v>
<v t="leo.20210713140956.394"><vh>simxGetIntegerParameter</vh></v>
<v t="leo.20210713140956.395"><vh>simxSetIntegerParameter</vh></v>
<v t="leo.20210713140956.396"><vh>simxGetFloatingParameter</vh></v>
<v t="leo.20210713140956.397"><vh>simxSetFloatingParameter</vh></v>
<v t="leo.20210713140956.398"><vh>simxGetStringParameter</vh></v>
<v t="leo.20210713140956.399"><vh>simxGetCollisionHandle</vh></v>
<v t="leo.20210713140956.400"><vh>simxGetCollectionHandle</vh></v>
<v t="leo.20210713140956.401"><vh>simxGetDistanceHandle</vh></v>
<v t="leo.20210713140956.402"><vh>simxReadCollision</vh></v>
<v t="leo.20210713140956.403"><vh>simxReadDistance</vh></v>
<v t="leo.20210713140956.404"><vh>simxRemoveObject</vh></v>
<v t="leo.20210713140956.405"><vh>simxRemoveModel</vh></v>
<v t="leo.20210713140956.406"><vh>simxRemoveUI</vh></v>
<v t="leo.20210713140956.407"><vh>simxCloseScene</vh></v>
<v t="leo.20210713140956.408"><vh>simxGetObjects</vh></v>
<v t="leo.20210713140956.409"><vh>simxDisplayDialog</vh></v>
<v t="leo.20210713140956.410"><vh>simxEndDialog</vh></v>
<v t="leo.20210713140956.411"><vh>simxGetDialogInput</vh></v>
<v t="leo.20210713140956.412"><vh>simxGetDialogResult</vh></v>
<v t="leo.20210713140956.413"><vh>simxCopyPasteObjects</vh></v>
<v t="leo.20210713140956.414"><vh>simxGetObjectSelection</vh></v>
<v t="leo.20210713140956.415"><vh>simxSetObjectSelection</vh></v>
<v t="leo.20210713140956.416"><vh>simxClearFloatSignal</vh></v>
<v t="leo.20210713140956.417"><vh>simxClearIntegerSignal</vh></v>
<v t="leo.20210713140956.418"><vh>simxClearStringSignal</vh></v>
<v t="leo.20210713140956.419"><vh>simxGetFloatSignal</vh></v>
<v t="leo.20210713140956.420"><vh>simxGetIntegerSignal</vh></v>
<v t="leo.20210713140956.421"><vh>simxGetStringSignal</vh></v>
<v t="leo.20210713140956.422"><vh>simxGetAndClearStringSignal</vh></v>
<v t="leo.20210713140956.423"><vh>simxReadStringStream</vh></v>
<v t="leo.20210713140956.424"><vh>simxSetFloatSignal</vh></v>
<v t="leo.20210713140956.425"><vh>simxSetIntegerSignal</vh></v>
<v t="leo.20210713140956.426"><vh>simxSetStringSignal</vh></v>
<v t="leo.20210713140956.427"><vh>simxAppendStringSignal</vh></v>
<v t="leo.20210713140956.428"><vh>simxWriteStringStream</vh></v>
<v t="leo.20210713140956.429"><vh>simxGetObjectFloatParameter</vh></v>
<v t="leo.20210713140956.430"><vh>simxSetObjectFloatParameter</vh></v>
<v t="leo.20210713140956.431"><vh>simxGetObjectIntParameter</vh></v>
<v t="leo.20210713140956.432"><vh>simxSetObjectIntParameter</vh></v>
<v t="leo.20210713140956.433"><vh>simxGetModelProperty</vh></v>
<v t="leo.20210713140956.434"><vh>simxSetModelProperty</vh></v>
<v t="leo.20210713140956.435"><vh>simxStart</vh></v>
<v t="leo.20210713140956.436"><vh>simxFinish</vh></v>
<v t="leo.20210713140956.437"><vh>simxGetPingTime</vh></v>
<v t="leo.20210713140956.438"><vh>simxGetLastCmdTime</vh></v>
<v t="leo.20210713140956.439"><vh>simxSynchronousTrigger</vh></v>
<v t="leo.20210713140956.440"><vh>simxSynchronous</vh></v>
<v t="leo.20210713140956.441"><vh>simxPauseCommunication</vh></v>
<v t="leo.20210713140956.442"><vh>simxGetInMessageInfo</vh></v>
<v t="leo.20210713140956.443"><vh>simxGetOutMessageInfo</vh></v>
<v t="leo.20210713140956.444"><vh>simxGetConnectionId</vh></v>
<v t="leo.20210713140956.445"><vh>simxCreateBuffer</vh></v>
<v t="leo.20210713140956.446"><vh>simxReleaseBuffer</vh></v>
<v t="leo.20210713140956.447"><vh>simxTransferFile</vh></v>
<v t="leo.20210713140956.448"><vh>simxEraseFile</vh></v>
<v t="leo.20210713140956.449"><vh>simxCreateDummy</vh></v>
<v t="leo.20210713140956.450"><vh>simxQuery</vh></v>
<v t="leo.20210713140956.451"><vh>simxGetObjectGroupData</vh></v>
<v t="leo.20210713140956.452"><vh>simxCallScriptFunction</vh></v>
<v t="leo.20210713140956.453"><vh>simxGetObjectVelocity</vh></v>
<v t="leo.20210713140956.454"><vh>simxPackInts</vh></v>
<v t="leo.20210713140956.455"><vh>simxUnpackInts</vh></v>
<v t="leo.20210713140956.456"><vh>simxPackFloats</vh></v>
<v t="leo.20210713140956.457"><vh>simxUnpackFloats</vh></v>
</v>
<v t="leo.20210713140956.458"><vh>@clean simConst.py</vh>
<v t="leo.20210713140956.459"><vh>Declarations</vh></v>
</v>
<v t="leo.20210713140957.1"><vh>@clean vrep.py</vh>
<v t="leo.20210713140957.2"><vh>Declarations</vh></v>
<v t="leo.20210713140957.3"><vh>simxGetJointPosition</vh></v>
<v t="leo.20210713140957.4"><vh>simxSetJointPosition</vh></v>
<v t="leo.20210713140957.5"><vh>simxGetJointMatrix</vh></v>
<v t="leo.20210713140957.6"><vh>simxSetSphericalJointMatrix</vh></v>
<v t="leo.20210713140957.7"><vh>simxSetJointTargetVelocity</vh></v>
<v t="leo.20210713140957.8"><vh>simxSetJointTargetPosition</vh></v>
<v t="leo.20210713140957.9"><vh>simxJointGetForce</vh></v>
<v t="leo.20210713140957.10"><vh>simxGetJointForce</vh></v>
<v t="leo.20210713140957.11"><vh>simxGetJointMaxForce</vh></v>
<v t="leo.20210713140957.12"><vh>simxSetJointForce</vh></v>
<v t="leo.20210713140957.13"><vh>simxSetJointMaxForce</vh></v>
<v t="leo.20210713140957.14"><vh>simxReadForceSensor</vh></v>
<v t="leo.20210713140957.15"><vh>simxBreakForceSensor</vh></v>
<v t="leo.20210713140957.16"><vh>simxReadVisionSensor</vh></v>
<v t="leo.20210713140957.17"><vh>simxGetObjectHandle</vh></v>
<v t="leo.20210713140957.18"><vh>simxGetVisionSensorImage</vh></v>
<v t="leo.20210713140957.19"><vh>simxSetVisionSensorImage</vh></v>
<v t="leo.20210713140957.20"><vh>simxGetVisionSensorDepthBuffer</vh></v>
<v t="leo.20210713140957.21"><vh>simxGetObjectChild</vh></v>
<v t="leo.20210713140957.22"><vh>simxGetObjectParent</vh></v>
<v t="leo.20210713140957.23"><vh>simxReadProximitySensor</vh></v>
<v t="leo.20210713140957.24"><vh>simxLoadModel</vh></v>
<v t="leo.20210713140957.25"><vh>simxLoadUI</vh></v>
<v t="leo.20210713140957.26"><vh>simxLoadScene</vh></v>
<v t="leo.20210713140957.27"><vh>simxStartSimulation</vh></v>
<v t="leo.20210713140957.28"><vh>simxPauseSimulation</vh></v>
<v t="leo.20210713140957.29"><vh>simxStopSimulation</vh></v>
<v t="leo.20210713140957.30"><vh>simxGetUIHandle</vh></v>
<v t="leo.20210713140957.31"><vh>simxGetUISlider</vh></v>
<v t="leo.20210713140957.32"><vh>simxSetUISlider</vh></v>
<v t="leo.20210713140957.33"><vh>simxGetUIEventButton</vh></v>
<v t="leo.20210713140957.34"><vh>simxGetUIButtonProperty</vh></v>
<v t="leo.20210713140957.35"><vh>simxSetUIButtonProperty</vh></v>
<v t="leo.20210713140957.36"><vh>simxAddStatusbarMessage</vh></v>
<v t="leo.20210713140957.37"><vh>simxAuxiliaryConsoleOpen</vh></v>
<v t="leo.20210713140957.38"><vh>simxAuxiliaryConsoleClose</vh></v>
<v t="leo.20210713140957.39"><vh>simxAuxiliaryConsolePrint</vh></v>
<v t="leo.20210713140957.40"><vh>simxAuxiliaryConsoleShow</vh></v>
<v t="leo.20210713140957.41"><vh>simxGetObjectOrientation</vh></v>
<v t="leo.20210713140957.42"><vh>simxGetObjectQuaternion</vh></v>
<v t="leo.20210713140957.43"><vh>simxGetObjectPosition</vh></v>
<v t="leo.20210713140957.44"><vh>simxSetObjectOrientation</vh></v>
<v t="leo.20210713140957.45"><vh>simxSetObjectQuaternion</vh></v>
<v t="leo.20210713140957.46"><vh>simxSetObjectPosition</vh></v>
<v t="leo.20210713140957.47"><vh>simxSetObjectParent</vh></v>
<v t="leo.20210713140957.48"><vh>simxSetUIButtonLabel</vh></v>
<v t="leo.20210713140957.49"><vh>simxGetLastErrors</vh></v>
<v t="leo.20210713140957.50"><vh>simxGetArrayParameter</vh></v>
<v t="leo.20210713140957.51"><vh>simxSetArrayParameter</vh></v>
<v t="leo.20210713140957.52"><vh>simxGetBooleanParameter</vh></v>
<v t="leo.20210713140957.53"><vh>simxSetBooleanParameter</vh></v>
<v t="leo.20210713140957.54"><vh>simxGetIntegerParameter</vh></v>
<v t="leo.20210713140957.55"><vh>simxSetIntegerParameter</vh></v>
<v t="leo.20210713140957.56"><vh>simxGetFloatingParameter</vh></v>
<v t="leo.20210713140957.57"><vh>simxSetFloatingParameter</vh></v>
<v t="leo.20210713140957.58"><vh>simxGetStringParameter</vh></v>
<v t="leo.20210713140957.59"><vh>simxGetCollisionHandle</vh></v>
<v t="leo.20210713140957.60"><vh>simxGetCollectionHandle</vh></v>
<v t="leo.20210713140957.61"><vh>simxGetDistanceHandle</vh></v>
<v t="leo.20210713140957.62"><vh>simxReadCollision</vh></v>
<v t="leo.20210713140957.63"><vh>simxReadDistance</vh></v>
<v t="leo.20210713140957.64"><vh>simxRemoveObject</vh></v>
<v t="leo.20210713140957.65"><vh>simxRemoveModel</vh></v>
<v t="leo.20210713140957.66"><vh>simxRemoveUI</vh></v>
<v t="leo.20210713140957.67"><vh>simxCloseScene</vh></v>
<v t="leo.20210713140957.68"><vh>simxGetObjects</vh></v>
<v t="leo.20210713140957.69"><vh>simxDisplayDialog</vh></v>
<v t="leo.20210713140957.70"><vh>simxEndDialog</vh></v>
<v t="leo.20210713140957.71"><vh>simxGetDialogInput</vh></v>
<v t="leo.20210713140957.72"><vh>simxGetDialogResult</vh></v>
<v t="leo.20210713140957.73"><vh>simxCopyPasteObjects</vh></v>
<v t="leo.20210713140957.74"><vh>simxGetObjectSelection</vh></v>
<v t="leo.20210713140957.75"><vh>simxSetObjectSelection</vh></v>
<v t="leo.20210713140957.76"><vh>simxClearFloatSignal</vh></v>
<v t="leo.20210713140957.77"><vh>simxClearIntegerSignal</vh></v>
<v t="leo.20210713140957.78"><vh>simxClearStringSignal</vh></v>
<v t="leo.20210713140957.79"><vh>simxGetFloatSignal</vh></v>
<v t="leo.20210713140957.80"><vh>simxGetIntegerSignal</vh></v>
<v t="leo.20210713140957.81"><vh>simxGetStringSignal</vh></v>
<v t="leo.20210713140957.82"><vh>simxGetAndClearStringSignal</vh></v>
<v t="leo.20210713140957.83"><vh>simxReadStringStream</vh></v>
<v t="leo.20210713140957.84"><vh>simxSetFloatSignal</vh></v>
<v t="leo.20210713140957.85"><vh>simxSetIntegerSignal</vh></v>
<v t="leo.20210713140957.86"><vh>simxSetStringSignal</vh></v>
<v t="leo.20210713140957.87"><vh>simxAppendStringSignal</vh></v>
<v t="leo.20210713140957.88"><vh>simxWriteStringStream</vh></v>
<v t="leo.20210713140957.89"><vh>simxGetObjectFloatParameter</vh></v>
<v t="leo.20210713140957.90"><vh>simxSetObjectFloatParameter</vh></v>
<v t="leo.20210713140957.91"><vh>simxGetObjectIntParameter</vh></v>
<v t="leo.20210713140957.92"><vh>simxSetObjectIntParameter</vh></v>
<v t="leo.20210713140957.93"><vh>simxGetModelProperty</vh></v>
<v t="leo.20210713140957.94"><vh>simxSetModelProperty</vh></v>
<v t="leo.20210713140957.95"><vh>simxStart</vh></v>
<v t="leo.20210713140957.96"><vh>simxFinish</vh></v>
<v t="leo.20210713140957.97"><vh>simxGetPingTime</vh></v>
<v t="leo.20210713140957.98"><vh>simxGetLastCmdTime</vh></v>
<v t="leo.20210713140957.99"><vh>simxSynchronousTrigger</vh></v>
<v t="leo.20210713140957.100"><vh>simxSynchronous</vh></v>
<v t="leo.20210713140957.101"><vh>simxPauseCommunication</vh></v>
<v t="leo.20210713140957.102"><vh>simxGetInMessageInfo</vh></v>
<v t="leo.20210713140957.103"><vh>simxGetOutMessageInfo</vh></v>
<v t="leo.20210713140957.104"><vh>simxGetConnectionId</vh></v>
<v t="leo.20210713140957.105"><vh>simxCreateBuffer</vh></v>
<v t="leo.20210713140957.106"><vh>simxReleaseBuffer</vh></v>
<v t="leo.20210713140957.107"><vh>simxTransferFile</vh></v>
<v t="leo.20210713140957.108"><vh>simxEraseFile</vh></v>
<v t="leo.20210713140957.109"><vh>simxCreateDummy</vh></v>
<v t="leo.20210713140957.110"><vh>simxQuery</vh></v>
<v t="leo.20210713140957.111"><vh>simxGetObjectGroupData</vh></v>
<v t="leo.20210713140957.112"><vh>simxCallScriptFunction</vh></v>
<v t="leo.20210713140957.113"><vh>simxGetObjectVelocity</vh></v>
<v t="leo.20210713140957.114"><vh>simxPackInts</vh></v>
<v t="leo.20210713140957.115"><vh>simxUnpackInts</vh></v>
<v t="leo.20210713140957.116"><vh>simxPackFloats</vh></v>
<v t="leo.20210713140957.117"><vh>simxUnpackFloats</vh></v>
</v>
<v t="leo.20210713140957.118"><vh>@clean vrep_env.py</vh>
<v t="leo.20210713140957.119"><vh>Declarations</vh></v>
<v t="leo.20210713140957.120"><vh>class VrepEnv(gym.Env)</vh>
<v t="leo.20210713140957.121"><vh>VrepEnv.__init__</vh></v>
<v t="leo.20210713140957.122"><vh>VrepEnv.RAPI_rc</vh></v>
<v t="leo.20210713140957.123"><vh>VrepEnv.connect</vh></v>
<v t="leo.20210713140957.124"><vh>VrepEnv.disconnect</vh></v>
<v t="leo.20210713140957.125"><vh>VrepEnv.load_scene</vh></v>
<v t="leo.20210713140957.126"><vh>VrepEnv.close_scene</vh></v>
<v t="leo.20210713140957.127"><vh>VrepEnv.start_simulation</vh></v>
<v t="leo.20210713140957.128"><vh>VrepEnv.stop_simulation</vh></v>
<v t="leo.20210713140957.129"><vh>VrepEnv.step_simulation</vh></v>
<v t="leo.20210713140957.130"><vh>VrepEnv.add_statusbar_message</vh></v>
<v t="leo.20210713140957.131"><vh>VrepEnv.get_object_handle</vh></v>
<v t="leo.20210713140957.132"><vh>VrepEnv.obj_get_position</vh></v>
<v t="leo.20210713140957.133"><vh>VrepEnv.obj_get_orientation</vh></v>
<v t="leo.20210713140957.134"><vh>VrepEnv.obj_get_orientation_continuous</vh></v>
<v t="leo.20210713140957.135"><vh>VrepEnv.obj_get_velocity</vh></v>
<v t="leo.20210713140957.136"><vh>VrepEnv.obj_get_joint_angle</vh></v>
<v t="leo.20210713140957.137"><vh>VrepEnv.obj_get_joint_angle_continuous</vh></v>
<v t="leo.20210713140957.138"><vh>VrepEnv.obj_get_joint_force</vh></v>
<v t="leo.20210713140957.139"><vh>VrepEnv.obj_read_force_sensor</vh></v>
<v t="leo.20210713140957.140"><vh>VrepEnv.obj_get_vision_image</vh></v>
<v t="leo.20210713140957.141"><vh>VrepEnv.obj_set_position_target</vh></v>
<v t="leo.20210713140957.142"><vh>VrepEnv.obj_set_velocity</vh></v>
<v t="leo.20210713140957.143"><vh>VrepEnv.obj_set_force</vh></v>
<v t="leo.20210713140957.144"><vh>VrepEnv.obj_set_position</vh></v>
<v t="leo.20210713140957.145"><vh>VrepEnv.obj_set_orientation</vh></v>
<v t="leo.20210713140957.146"><vh>VrepEnv.get_collision_handle</vh></v>
<v t="leo.20210713140957.147"><vh>VrepEnv.read_collision</vh></v>
<v t="leo.20210713140957.148"><vh>VrepEnv.set_integer_signal</vh></v>
<v t="leo.20210713140957.149"><vh>VrepEnv.set_float_signal</vh></v>
<v t="leo.20210713140957.150"><vh>VrepEnv.set_string_signal</vh></v>
<v t="leo.20210713140957.151"><vh>VrepEnv.get_integer_signal</vh></v>
<v t="leo.20210713140957.152"><vh>VrepEnv.get_float_signal</vh></v>
<v t="leo.20210713140957.153"><vh>VrepEnv.get_string_signal</vh></v>
<v t="leo.20210713140957.154"><vh>VrepEnv.set_boolean_parameter</vh></v>
<v t="leo.20210713140957.155"><vh>VrepEnv.set_integer_parameter</vh></v>
<v t="leo.20210713140957.156"><vh>VrepEnv.set_float_parameter</vh></v>
<v t="leo.20210713140957.157"><vh>VrepEnv.set_array_parameter</vh></v>
<v t="leo.20210713140957.158"><vh>VrepEnv.get_boolean_parameter</vh></v>
<v t="leo.20210713140957.159"><vh>VrepEnv.get_integer_parameter</vh></v>
<v t="leo.20210713140957.160"><vh>VrepEnv.get_float_parameter</vh></v>
<v t="leo.20210713140957.161"><vh>VrepEnv.get_array_parameter</vh></v>
<v t="leo.20210713140957.162"><vh>VrepEnv.call_childscript_function</vh></v>
<v t="leo.20210713140957.163"><vh>VrepEnv.close</vh></v>
</v>
</v>
<v t="leo.20210713140957.164"><vh>@clean __init__.py</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20210713140751.2">倉儲位於 https://github.com/mdecourse/vrep-env

fork from https://github.com/ycps/vrep-env 然後進行修改

將原先 Linux 版本改為 Windows 10 版本

直接將 vrep_env 原始碼放在執行 examples 目錄中

已經修改 vrep-env 中的原始碼, 主要讓程式可以在 Windows 執行

執行之前必須檢查 

VREP_SCENES_PATH 與 VREP_PATH 設定

目前將 VREP_PATH 在 start_ipv6.bat 中設定如下:

REM for PyRep
set VREP_PATH=%Disk%:\CoppeliaSimEdu_4.1.0_rev1
</t>
<t tx="leo.20210713140756.1">'''Recursively import all python files in a directory and clean the result.'''
# ctrl + b to execute

c.recursiveImport(
    dir_ = r'./../',
    kind = '@clean', # The new best practice.
    safe_at_file = False,
    theTypes = ['.py'] 
)</t>
<t tx="leo.20210713140915.1"></t>
<t tx="leo.20210713140915.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 30px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 30px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 30px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 30px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 30px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 30px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20210713140915.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20210713140956.1"></t>
<t tx="leo.20210713140956.10">class CartPoleContinuousVrepEnv(vrep_env.VrepEnv):
    metadata = {
        'render.modes': ['human', 'rgb_array'],
        'video.frames_per_second' : 50
    }
    @others
</t>
<t tx="leo.20210713140956.100">def simxSetObjectPosition(clientID, objectHandle, relativeToObjectHandle, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_position = (ct.c_float*3)(*position)
    return c_SetObjectPosition(clientID, objectHandle, relativeToObjectHandle, c_position, operationMode)

</t>
<t tx="leo.20210713140956.101">def simxSetObjectParent(clientID, objectHandle, parentObject, keepInPlace, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectParent(clientID, objectHandle, parentObject, keepInPlace, operationMode)

</t>
<t tx="leo.20210713140956.102">def simxSetUIButtonLabel(clientID, uiHandle, uiButtonID, upStateLabel, downStateLabel, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        if type(upStateLabel) is str:
            upStateLabel=upStateLabel.encode('utf-8')
        if type(downStateLabel) is str:
            downStateLabel=downStateLabel.encode('utf-8')
    return c_SetUIButtonLabel(clientID, uiHandle, uiButtonID, upStateLabel, downStateLabel, operationMode)

</t>
<t tx="leo.20210713140956.103">def simxGetLastErrors(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    errors =[]
    errorCnt = ct.c_int()
    errorStrings = ct.POINTER(ct.c_char)()
    ret = c_GetLastErrors(clientID, ct.byref(errorCnt), ct.byref(errorStrings), operationMode)
    if ret == 0:
        s = 0
        for i in range(errorCnt.value):
            a = bytearray()
            while errorStrings[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(errorStrings[s],'big'))
                else:
                    a.append(errorStrings[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                errors.append(str(a,'utf-8'))
            else:
                errors.append(str(a))

    return ret, errors

</t>
<t tx="leo.20210713140956.104">def simxGetArrayParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    paramValues = (ct.c_float*3)()
    ret = c_GetArrayParameter(clientID, paramIdentifier, paramValues, operationMode)
    arr = []
    for i in range(3):
        arr.append(paramValues[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.105">def simxSetArrayParameter(clientID, paramIdentifier, paramValues, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_paramValues = (ct.c_float*3)(*paramValues)
    return c_SetArrayParameter(clientID, paramIdentifier, c_paramValues, operationMode)

</t>
<t tx="leo.20210713140956.106">def simxGetBooleanParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_ubyte()
    return c_GetBooleanParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), bool(paramValue.value!=0)

</t>
<t tx="leo.20210713140956.107">def simxSetBooleanParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetBooleanParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140956.108">def simxGetIntegerParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_int()
    return c_GetIntegerParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), paramValue.value

</t>
<t tx="leo.20210713140956.109">def simxSetIntegerParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetIntegerParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140956.11">def __init__(
    self,
    server_addr='127.0.0.1',
    server_port=19997,
    scene_path=vrep_scenes_path+'/gym_cartpole.ttt',
):
    vrep_env.VrepEnv.__init__(
        self,
        server_addr,
        server_port,
        scene_path,
    )
    
    # getting object handles
    self.action   = self.get_object_handle('action')
    self.cart     = self.get_object_handle('cart')
    self.pole     = self.get_object_handle('pole')
    self.viewer   = self.get_object_handle('viewer')
    
    # adjusting parameters
    self.tau = 0.02  # seconds between state updates
    self.gravity = 9.8
    #self.force_mag = 10.0
    self.force_mag = 100.0
    
    self.set_float_parameter(vrep.sim_floatparam_simulation_time_step, self.tau)
    self.set_array_parameter(vrep.sim_arrayparam_gravity,[0,0,-self.gravity])
    self.obj_set_force(self.action,self.force_mag)
    
    # Angle at which to fail the episode
    self.theta_threshold_radians = 12 * 2 * math.pi / 360
    self.x_threshold = 2.4
    # Angle limit set to 2 * theta_threshold_radians so failing observation is still within bounds
    high = np.array([
        self.x_threshold * 2,             np.finfo(np.float32).max,
        self.theta_threshold_radians * 2, np.finfo(np.float32).max])
    
    self.min_action = -1.0
    self.max_action =  1.0
    
    self.action_space = spaces.Box(low=self.min_action, high=self.max_action, shape=(1,))
    self.observation_space = spaces.Box(-high, high)
    
    self.seed()
    self.viewer = None
    self.state = None
    self.steps_beyond_done = None

</t>
<t tx="leo.20210713140956.110">def simxGetFloatingParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_float()
    return c_GetFloatingParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), paramValue.value

</t>
<t tx="leo.20210713140956.111">def simxSetFloatingParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetFloatingParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140956.112">def simxGetStringParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    paramValue = ct.POINTER(ct.c_char)()
    ret = c_GetStringParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode)

    a = bytearray()
    if ret == 0:
        i = 0
        while paramValue[i] != b'\0':
            if sys.version_info[0] == 3:
                a.append(int.from_bytes(paramValue[i],'big'))
            else:
                a.append(paramValue[i])
            i=i+1
    if sys.version_info[0] == 3:
        a=str(a,'utf-8')
    else:
        a=str(a)
    return ret, a

</t>
<t tx="leo.20210713140956.113">def simxGetCollisionHandle(clientID, collisionObjectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(collisionObjectName) is str):
        collisionObjectName=collisionObjectName.encode('utf-8')
    return c_GetCollisionHandle(clientID, collisionObjectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.114">def simxGetCollectionHandle(clientID, collectionName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(collectionName) is str):
        collectionName=collectionName.encode('utf-8')
    return c_GetCollectionHandle(clientID, collectionName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.115">def simxGetDistanceHandle(clientID, distanceObjectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(distanceObjectName) is str):
        distanceObjectName=distanceObjectName.encode('utf-8')
    return c_GetDistanceHandle(clientID, distanceObjectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.116">def simxReadCollision(clientID, collisionObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    collisionState = ct.c_ubyte()
    return c_ReadCollision(clientID, collisionObjectHandle, ct.byref(collisionState), operationMode), bool(collisionState.value!=0)

</t>
<t tx="leo.20210713140956.117">def simxReadDistance(clientID, distanceObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    minimumDistance = ct.c_float()
    return c_ReadDistance(clientID, distanceObjectHandle, ct.byref(minimumDistance), operationMode), minimumDistance.value

</t>
<t tx="leo.20210713140956.118">def simxRemoveObject(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveObject(clientID, objectHandle, operationMode)

</t>
<t tx="leo.20210713140956.119">def simxRemoveModel(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveModel(clientID, objectHandle, operationMode)

</t>
<t tx="leo.20210713140956.12">def seed(self, seed=None):
    self.np_random, seed = seeding.np_random(seed)
    return [seed]

</t>
<t tx="leo.20210713140956.120">def simxRemoveUI(clientID, uiHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveUI(clientID, uiHandle, operationMode)

</t>
<t tx="leo.20210713140956.121">def simxCloseScene(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_CloseScene(clientID, operationMode)

</t>
<t tx="leo.20210713140956.122">def simxGetObjects(clientID, objectType, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    objectCount = ct.c_int()
    objectHandles = ct.POINTER(ct.c_int)()

    ret = c_GetObjects(clientID, objectType, ct.byref(objectCount), ct.byref(objectHandles), operationMode)
    handles = []
    if ret == 0:
        for i in range(objectCount.value):
            handles.append(objectHandles[i])

    return ret, handles


</t>
<t tx="leo.20210713140956.123">def simxDisplayDialog(clientID, titleText, mainText, dialogType, initialText, titleColors, dialogColors, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    if titleColors != None:
        c_titleColors  = (ct.c_float*6)(*titleColors)
    else:
        c_titleColors  = None
    if dialogColors != None:
        c_dialogColors  = (ct.c_float*6)(*dialogColors)
    else:
        c_dialogColors  = None

    c_dialogHandle = ct.c_int()
    c_uiHandle = ct.c_int()
    if sys.version_info[0] == 3:
        if type(titleText) is str:
            titleText=titleText.encode('utf-8')
        if type(mainText) is str:
            mainText=mainText.encode('utf-8')
        if type(initialText) is str:
            initialText=initialText.encode('utf-8')
    return c_DisplayDialog(clientID, titleText, mainText, dialogType, initialText, c_titleColors, c_dialogColors, ct.byref(c_dialogHandle), ct.byref(c_uiHandle), operationMode), c_dialogHandle.value, c_uiHandle.value

</t>
<t tx="leo.20210713140956.124">def simxEndDialog(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_EndDialog(clientID, dialogHandle, operationMode)

</t>
<t tx="leo.20210713140956.125">def simxGetDialogInput(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    inputText = ct.POINTER(ct.c_char)()
    ret = c_GetDialogInput(clientID, dialogHandle, ct.byref(inputText), operationMode)

    a = bytearray()
    if ret == 0:
        i = 0
        while inputText[i] != b'\0':
            if sys.version_info[0] == 3:
                a.append(int.from_bytes(inputText[i],'big'))
            else:
                a.append(inputText[i])
            i = i+1

    if sys.version_info[0] == 3:
        a=str(a,'utf-8')
    else:
        a=str(a)
    return ret, a


</t>
<t tx="leo.20210713140956.126">def simxGetDialogResult(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    result = ct.c_int()
    return c_GetDialogResult(clientID, dialogHandle, ct.byref(result), operationMode), result.value

</t>
<t tx="leo.20210713140956.127">def simxCopyPasteObjects(clientID, objectHandles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    c_objectHandles  = (ct.c_int*len(objectHandles))(*objectHandles)
    c_objectHandles = ct.cast(c_objectHandles,ct.POINTER(ct.c_int)) # IronPython needs this
    newObjectCount   = ct.c_int()
    newObjectHandles = ct.POINTER(ct.c_int)()
    ret = c_CopyPasteObjects(clientID, c_objectHandles, len(objectHandles), ct.byref(newObjectHandles), ct.byref(newObjectCount), operationMode)

    newobj = []
    if ret == 0:
        for i in range(newObjectCount.value):
            newobj.append(newObjectHandles[i])

    return ret, newobj


</t>
<t tx="leo.20210713140956.128">def simxGetObjectSelection(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    objectCount   = ct.c_int()
    objectHandles = ct.POINTER(ct.c_int)()
    ret = c_GetObjectSelection(clientID, ct.byref(objectHandles), ct.byref(objectCount), operationMode)

    newobj = []
    if ret == 0:
        for i in range(objectCount.value):
            newobj.append(objectHandles[i])

    return ret, newobj



</t>
<t tx="leo.20210713140956.129">def simxSetObjectSelection(clientID, objectHandles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_objectHandles  = (ct.c_int*len(objectHandles))(*objectHandles)
    return c_SetObjectSelection(clientID, c_objectHandles, len(objectHandles), operationMode)

</t>
<t tx="leo.20210713140956.13">def _make_observation(self):
    # discard y and z values
    [  x   ,_,_ ]         = self.obj_get_position(self.cart)
    [x_dot ,_,_ ] , _     = self.obj_get_velocity(self.cart)
    
    [_, theta ,_]         = self.obj_get_orientation(self.pole)
    _ , [_, theta_dot ,_] = self.obj_get_velocity(self.pole)
    
    self.state = (x,x_dot,theta,theta_dot)

</t>
<t tx="leo.20210713140956.130">def simxClearFloatSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearFloatSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140956.131">def simxClearIntegerSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearIntegerSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140956.132">def simxClearStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearStringSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140956.133">def simxGetFloatSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalValue = ct.c_float()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_GetFloatSignal(clientID, signalName, ct.byref(signalValue), operationMode), signalValue.value

</t>
<t tx="leo.20210713140956.134">def simxGetIntegerSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalValue = ct.c_int()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_GetIntegerSignal(clientID, signalName, ct.byref(signalValue), operationMode), signalValue.value

</t>
<t tx="leo.20210713140956.135">def simxGetStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_GetStringSignal(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.136">def simxGetAndClearStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_GetAndClearStringSignal(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.137">def simxReadStringStream(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_ReadStringStream(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.138">def simxSetFloatSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_SetFloatSignal(clientID, signalName, signalValue, operationMode)

</t>
<t tx="leo.20210713140956.139">def simxSetIntegerSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_SetIntegerSignal(clientID, signalName, signalValue, operationMode)

</t>
<t tx="leo.20210713140956.14">def _make_action(self, a):
    self.obj_set_velocity(self.action,a*2.0)

</t>
<t tx="leo.20210713140956.140">def simxSetStringSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_SetStringSignal(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140956.141">def simxAppendStringSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_AppendStringSignal(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140956.142">def simxWriteStringStream(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_WriteStringStream(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140956.143">def simxGetObjectFloatParameter(clientID, objectHandle, parameterID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parameterValue = ct.c_float()
    return c_GetObjectFloatParameter(clientID, objectHandle, parameterID, ct.byref(parameterValue), operationMode), parameterValue.value

</t>
<t tx="leo.20210713140956.144">def simxSetObjectFloatParameter(clientID, objectHandle, parameterID, parameterValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectFloatParameter(clientID, objectHandle, parameterID, parameterValue, operationMode)

</t>
<t tx="leo.20210713140956.145">def simxGetObjectIntParameter(clientID, objectHandle, parameterID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parameterValue = ct.c_int()
    return c_GetObjectIntParameter(clientID, objectHandle, parameterID, ct.byref(parameterValue), operationMode), parameterValue.value

</t>
<t tx="leo.20210713140956.146">def simxSetObjectIntParameter(clientID, objectHandle, parameterID, parameterValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectIntParameter(clientID, objectHandle, parameterID, parameterValue, operationMode)

</t>
<t tx="leo.20210713140956.147">def simxGetModelProperty(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    prop = ct.c_int()
    return c_GetModelProperty(clientID, objectHandle, ct.byref(prop), operationMode), prop.value

</t>
<t tx="leo.20210713140956.148">def simxSetModelProperty(clientID, objectHandle, prop, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetModelProperty(clientID, objectHandle, prop, operationMode)

</t>
<t tx="leo.20210713140956.149">def simxStart(connectionAddress, connectionPort, waitUntilConnected, doNotReconnectOnceDisconnected, timeOutInMs, commThreadCycleInMs):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(connectionAddress) is str):
        connectionAddress=connectionAddress.encode('utf-8')
    return c_Start(connectionAddress, connectionPort, waitUntilConnected, doNotReconnectOnceDisconnected, timeOutInMs, commThreadCycleInMs)

</t>
<t tx="leo.20210713140956.15">def step(self, action):
    assert self.action_space.contains(action), "%r (%s) invalid"%(action, type(action))
    
    # Actuate
    self._make_action(action)
    # Step
    self.step_simulation()
    # Observe
    self._make_observation()
    
    (x,x_dot,theta,theta_dot) = self.state
    
    done = x &lt; -self.x_threshold or theta &lt; -self.theta_threshold_radians \
        or x &gt;  self.x_threshold or theta &gt;  self.theta_threshold_radians
    done = bool(done)
    
    if not done:
        reward = 1.0
    elif self.steps_beyond_done is None:
        self.steps_beyond_done = 0
        reward = 1.0
    else:
        if self.steps_beyond_done == 0:
            logger.warning("You are calling 'step()' even though this environment has already returned done = True. You should always call 'reset()' once you receive 'done = True' -- any further steps are undefined behavior.")
        self.steps_beyond_done += 1
        reward = 0.0
    
    return np.array(self.state), reward, done, {}

</t>
<t tx="leo.20210713140956.150">def simxFinish(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_Finish(clientID)

</t>
<t tx="leo.20210713140956.151">def simxGetPingTime(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    pingTime = ct.c_int()
    return c_GetPingTime(clientID, ct.byref(pingTime)), pingTime.value

</t>
<t tx="leo.20210713140956.152">def simxGetLastCmdTime(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_GetLastCmdTime(clientID)

</t>
<t tx="leo.20210713140956.153">def simxSynchronousTrigger(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SynchronousTrigger(clientID)

</t>
<t tx="leo.20210713140956.154">def simxSynchronous(clientID, enable):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_Synchronous(clientID, enable)

</t>
<t tx="leo.20210713140956.155">def simxPauseCommunication(clientID, enable):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_PauseCommunication(clientID, enable)

</t>
<t tx="leo.20210713140956.156">def simxGetInMessageInfo(clientID, infoType):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    info = ct.c_int()
    return c_GetInMessageInfo(clientID, infoType, ct.byref(info)), info.value

</t>
<t tx="leo.20210713140956.157">def simxGetOutMessageInfo(clientID, infoType):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    info = ct.c_int()
    return c_GetOutMessageInfo(clientID, infoType, ct.byref(info)), info.value

</t>
<t tx="leo.20210713140956.158">def simxGetConnectionId(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_GetConnectionId(clientID)

</t>
<t tx="leo.20210713140956.159">def simxCreateBuffer(bufferSize):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_CreateBuffer(bufferSize)

</t>
<t tx="leo.20210713140956.16">def reset(self):
    if self.sim_running:
        self.stop_simulation()
    self.start_simulation()
    self.steps_beyond_done = None
    
    v = self.np_random.uniform(low=-0.04, high=0.04, size=(1,))
    self.obj_set_velocity(self.action,v)
    self.step_simulation()
    
    self._make_observation()
    return np.array(self.state)

</t>
<t tx="leo.20210713140956.160">def simxReleaseBuffer(buffer):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_ReleaseBuffer(buffer)

</t>
<t tx="leo.20210713140956.161">def simxTransferFile(clientID, filePathAndName, fileName_serverSide, timeOut, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(filePathAndName) is str):
        filePathAndName=filePathAndName.encode('utf-8')
    return c_TransferFile(clientID, filePathAndName, fileName_serverSide, timeOut, operationMode)

</t>
<t tx="leo.20210713140956.162">def simxEraseFile(clientID, fileName_serverSide, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(fileName_serverSide) is str):
        fileName_serverSide=fileName_serverSide.encode('utf-8')
    return c_EraseFile(clientID, fileName_serverSide, operationMode)

</t>
<t tx="leo.20210713140956.163">def simxCreateDummy(clientID, size, color, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if color != None:
        c_color = (ct.c_ubyte*12)(*color)
    else:
        c_color = None
    return c_CreateDummy(clientID, size, c_color, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.164">def simxQuery(clientID, signalName, signalValue, retSignalName, timeOutInMs):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    retSignalLength = ct.c_int();
    retSignalValue = ct.POINTER(ct.c_ubyte)()

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(retSignalName) is str:
            retSignalName=retSignalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this

    ret = c_Query(clientID, signalName, sigV, len(signalValue), retSignalName, ct.byref(retSignalValue), ct.byref(retSignalLength), timeOutInMs)

    a = bytearray()
    if ret == 0:
        for i in range(retSignalLength.value):
            a.append(retSignalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.165">def simxGetObjectGroupData(clientID, objectType, dataType, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handles =[]
    intData =[]
    floatData =[]
    stringData =[]
    handlesC = ct.c_int()
    handlesP = ct.POINTER(ct.c_int)()
    intDataC = ct.c_int()
    intDataP = ct.POINTER(ct.c_int)()
    floatDataC = ct.c_int()
    floatDataP = ct.POINTER(ct.c_float)()
    stringDataC = ct.c_int()
    stringDataP = ct.POINTER(ct.c_char)()
    ret = c_GetObjectGroupData(clientID, objectType, dataType, ct.byref(handlesC), ct.byref(handlesP), ct.byref(intDataC), ct.byref(intDataP), ct.byref(floatDataC), ct.byref(floatDataP), ct.byref(stringDataC), ct.byref(stringDataP), operationMode)

    if ret == 0:
        for i in range(handlesC.value):
            handles.append(handlesP[i])
        for i in range(intDataC.value):
            intData.append(intDataP[i])
        for i in range(floatDataC.value):
            floatData.append(floatDataP[i])
        s = 0
        for i in range(stringDataC.value):
            a = bytearray()
            while stringDataP[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(stringDataP[s],'big'))
                else:
                    a.append(stringDataP[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                a=str(a,'utf-8')
            else:
                a=str(a)
            stringData.append(a)

    return ret, handles, intData, floatData, stringData

</t>
<t tx="leo.20210713140956.166">def simxCallScriptFunction(clientID, scriptDescription, options, functionName, inputInts, inputFloats, inputStrings, inputBuffer, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    inputBufferV=inputBuffer
    if sys.version_info[0] == 3:
        if type(scriptDescription) is str:
            scriptDescription=scriptDescription.encode('utf-8')
        if type(functionName) is str:
            functionName=functionName.encode('utf-8')
        if type(inputBuffer) is bytearray:
            inputBufferV  = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
        if type(inputBuffer) is str:
            inputBuffer=inputBuffer.encode('utf-8')
            inputBufferV  = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
    else:
        if type(inputBuffer) is bytearray:
            inputBufferV = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
        if type(inputBuffer) is str:
            inputBuffer=bytearray(inputBuffer)
            inputBufferV = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
    inputBufferV=ct.cast(inputBufferV,ct.POINTER(ct.c_ubyte)) # IronPython needs this

    c_inInts  = (ct.c_int*len(inputInts))(*inputInts)
    c_inInts = ct.cast(c_inInts,ct.POINTER(ct.c_int)) # IronPython needs this
    c_inFloats  = (ct.c_float*len(inputFloats))(*inputFloats)
    c_inFloats = ct.cast(c_inFloats,ct.POINTER(ct.c_float)) # IronPython needs this

    concatStr=''.encode('utf-8')
    for i in range(len(inputStrings)):
        a=inputStrings[i]
        a=a+'\0'
        if type(a) is str:
            a=a.encode('utf-8')
        concatStr=concatStr+a
    c_inStrings  = (ct.c_char*len(concatStr))(*concatStr)

    intDataOut =[]
    floatDataOut =[]
    stringDataOut =[]
    bufferOut =bytearray()

    intDataC = ct.c_int()
    intDataP = ct.POINTER(ct.c_int)()
    floatDataC = ct.c_int()
    floatDataP = ct.POINTER(ct.c_float)()
    stringDataC = ct.c_int()
    stringDataP = ct.POINTER(ct.c_char)()
    bufferS = ct.c_int()
    bufferP = ct.POINTER(ct.c_ubyte)()

    ret = c_CallScriptFunction(clientID,scriptDescription,options,functionName,len(inputInts),c_inInts,len(inputFloats),c_inFloats,len(inputStrings),c_inStrings,len(inputBuffer),inputBufferV,ct.byref(intDataC),ct.byref(intDataP),ct.byref(floatDataC),ct.byref(floatDataP),ct.byref(stringDataC),ct.byref(stringDataP),ct.byref(bufferS),ct.byref(bufferP),operationMode)

    if ret == 0:
        for i in range(intDataC.value):
            intDataOut.append(intDataP[i])
        for i in range(floatDataC.value):
            floatDataOut.append(floatDataP[i])
        s = 0
        for i in range(stringDataC.value):
            a = bytearray()
            while stringDataP[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(stringDataP[s],'big'))
                else:
                    a.append(stringDataP[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                a=str(a,'utf-8')
            else:
                a=str(a)
            stringDataOut.append(a)
        for i in range(bufferS.value):
            bufferOut.append(bufferP[i])
    if sys.version_info[0] != 3:
        bufferOut=str(bufferOut)

    return ret, intDataOut, floatDataOut, stringDataOut, bufferOut

</t>
<t tx="leo.20210713140956.167">def simxGetObjectVelocity(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    linearVel  = (ct.c_float*3)()
    angularVel = (ct.c_float*3)()
    ret = c_GetObjectVelocity(clientID, objectHandle, linearVel, angularVel, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(linearVel[i])
    arr2 = []
    for i in range(3):
        arr2.append(angularVel[i])
    return ret, arr1, arr2

</t>
<t tx="leo.20210713140956.168">def simxPackInts(intList):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        s=bytes()
        for i in range(len(intList)):
            s=s+struct.pack('&lt;i',intList[i])
        s=bytearray(s)
    else:
        s=''
        for i in range(len(intList)):
            s+=struct.pack('&lt;i',intList[i])
    return s

</t>
<t tx="leo.20210713140956.169">def simxUnpackInts(intsPackedInString):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    b=[]
    for i in range(int(len(intsPackedInString)/4)):
        b.append(struct.unpack('&lt;i',intsPackedInString[4*i:4*(i+1)])[0])
    return b

</t>
<t tx="leo.20210713140956.17">def render(self, mode='human'):
    screen_width = 600
    screen_height = 400
    
    world_width = self.x_threshold*2
    scale = screen_width/world_width
    carty = 100 # TOP OF CART
    polewidth = 10.0
    polelen = scale * 1.0
    cartwidth = 50.0
    cartheight = 30.0
    
    if self.viewer is None:
        from gym.envs.classic_control import rendering
        self.viewer = rendering.Viewer(screen_width, screen_height)
        l,r,t,b = -cartwidth/2, cartwidth/2, cartheight/2, -cartheight/2
        axleoffset =cartheight/4.0
        cart = rendering.FilledPolygon([(l,b), (l,t), (r,t), (r,b)])
        self.carttrans = rendering.Transform()
        cart.add_attr(self.carttrans)
        self.viewer.add_geom(cart)
        l,r,t,b = -polewidth/2,polewidth/2,polelen-polewidth/2,-polewidth/2
        pole = rendering.FilledPolygon([(l,b), (l,t), (r,t), (r,b)])
        pole.set_color(.8,.6,.4)
        self.poletrans = rendering.Transform(translation=(0, axleoffset))
        pole.add_attr(self.poletrans)
        pole.add_attr(self.carttrans)
        self.viewer.add_geom(pole)
        self.axle = rendering.make_circle(polewidth/2)
        self.axle.add_attr(self.poletrans)
        self.axle.add_attr(self.carttrans)
        self.axle.set_color(.5,.5,.8)
        self.viewer.add_geom(self.axle)
        self.track = rendering.Line((0,carty), (screen_width,carty))
        self.track.set_color(0,0,0)
        self.viewer.add_geom(self.track)
    
    if self.state is None: return None
    
    x = self.state
    cartx = x[0]*scale+screen_width/2.0 # MIDDLE OF CART
    self.carttrans.set_translation(cartx, carty)
    self.poletrans.set_rotation(-x[2])
    
    return self.viewer.render(return_rgb_array = mode=='rgb_array')

</t>
<t tx="leo.20210713140956.170">def simxPackFloats(floatList):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        s=bytes()
        for i in range(len(floatList)):
            s=s+struct.pack('&lt;f',floatList[i])
        s=bytearray(s)
    else:
        s=''
        for i in range(len(floatList)):
            s+=struct.pack('&lt;f',floatList[i])
    return s

</t>
<t tx="leo.20210713140956.171">def simxUnpackFloats(floatsPackedInString):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    b=[]
    for i in range(int(len(floatsPackedInString)/4)):
        b.append(struct.unpack('&lt;f',floatsPackedInString[4*i:4*(i+1)])[0])
    return b
</t>
<t tx="leo.20210713140956.172">
#constants
#Scene object types. Values are serialized
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210713140956.173">sim_object_shape_type           =0
sim_object_joint_type           =1
sim_object_graph_type           =2
sim_object_camera_type          =3
sim_object_dummy_type           =4
sim_object_proximitysensor_type =5
sim_object_reserved1            =6
sim_object_reserved2            =7
sim_object_path_type            =8
sim_object_visionsensor_type    =9
sim_object_volume_type          =10
sim_object_mill_type            =11
sim_object_forcesensor_type     =12
sim_object_light_type           =13
sim_object_mirror_type          =14

#General object types. Values are serialized
sim_appobj_object_type          =109
sim_appobj_collision_type       =110
sim_appobj_distance_type        =111
sim_appobj_simulation_type      =112
sim_appobj_ik_type              =113
sim_appobj_constraintsolver_type=114
sim_appobj_collection_type      =115
sim_appobj_ui_type              =116
sim_appobj_script_type          =117
sim_appobj_pathplanning_type    =118
sim_appobj_RESERVED_type        =119
sim_appobj_texture_type         =120

# Ik calculation methods. Values are serialized
sim_ik_pseudo_inverse_method        =0
sim_ik_damped_least_squares_method  =1
sim_ik_jacobian_transpose_method    =2

# Ik constraints. Values are serialized
sim_ik_x_constraint         =1
sim_ik_y_constraint         =2
sim_ik_z_constraint         =4
sim_ik_alpha_beta_constraint=8
sim_ik_gamma_constraint     =16
sim_ik_avoidance_constraint =64

# Ik calculation results 
sim_ikresult_not_performed  =0
sim_ikresult_success        =1
sim_ikresult_fail           =2

# Scene object sub-types. Values are serialized 
# Light sub-types 
sim_light_omnidirectional_subtype   =1
sim_light_spot_subtype              =2
sim_light_directional_subtype       =3
# Joint sub-types 
sim_joint_revolute_subtype          =10
sim_joint_prismatic_subtype         =11
sim_joint_spherical_subtype         =12
# Shape sub-types 
sim_shape_simpleshape_subtype       =20
sim_shape_multishape_subtype        =21
# Proximity sensor sub-types 
sim_proximitysensor_pyramid_subtype =30
sim_proximitysensor_cylinder_subtype=31
sim_proximitysensor_disc_subtype    =32
sim_proximitysensor_cone_subtype    =33
sim_proximitysensor_ray_subtype     =34
# Mill sub-types 
sim_mill_pyramid_subtype            =40
sim_mill_cylinder_subtype           =41
sim_mill_disc_subtype               =42
sim_mill_cone_subtype               =42
# No sub-type 
sim_object_no_subtype               =200


#Scene object main properties (serialized)
sim_objectspecialproperty_collidable                    =0x0001
sim_objectspecialproperty_measurable                    =0x0002
#reserved                        =0x0004 
#reserved                        =0x0008 
sim_objectspecialproperty_detectable_ultrasonic            =0x0010
sim_objectspecialproperty_detectable_infrared            =0x0020
sim_objectspecialproperty_detectable_laser                =0x0040
sim_objectspecialproperty_detectable_inductive            =0x0080
sim_objectspecialproperty_detectable_capacitive            =0x0100
sim_objectspecialproperty_renderable                    =0x0200
sim_objectspecialproperty_detectable_all =sim_objectspecialproperty_detectable_ultrasonic|sim_objectspecialproperty_detectable_infrared|sim_objectspecialproperty_detectable_laser|sim_objectspecialproperty_detectable_inductive|sim_objectspecialproperty_detectable_capacitive
sim_objectspecialproperty_cuttable                        =0x0400
sim_objectspecialproperty_pathplanning_ignored            =0x0800

# Model properties (serialized)
sim_modelproperty_not_collidable                =0x0001
sim_modelproperty_not_measurable                =0x0002
sim_modelproperty_not_renderable                =0x0004
sim_modelproperty_not_detectable                =0x0008
sim_modelproperty_not_cuttable                    =0x0010
sim_modelproperty_not_dynamic                    =0x0020
sim_modelproperty_not_respondable                =0x0040 # cannot be selected if sim_modelproperty_not_dynamic is not selected 
sim_modelproperty_not_reset                        =0x0080 # Model is not reset at simulation end. This flag is cleared at simulation end 
sim_modelproperty_not_visible                    =0x0100 # Whole model is invisible independent of local visibility settings 
sim_modelproperty_not_model                        =0xf000 # object is not a model 


# Check the documentation instead of comments below!! 
# Following messages are dispatched to the Lua-message container 
sim_message_ui_button_state_change  =0    # a UI button slider etc. changed (due to a user's action). aux[0]=UI handle aux[1]=button handle aux[2]=button attributes aux[3]=slider position (if slider) 
sim_message_reserved9               =1    # Do not use 
sim_message_object_selection_changed=2
sim_message_reserved10                =3    # do not use 
sim_message_model_loaded            =4
sim_message_reserved11                =5    # do not use 
sim_message_keypress                =6    # a key was pressed while the focus was on a page (aux[0]=key aux[1]=ctrl and shift key state) 
sim_message_bannerclicked            =7    # a banner was clicked (aux[0]=banner ID) 


# Following messages are dispatched only to the C-API (not available from Lua) 
sim_message_for_c_api_only_start        =0x100      # Do not use 
sim_message_reserved1                   =0x101      # Do not use 
sim_message_reserved2                    =0x102      # Do not use 
sim_message_reserved3                    =0x103      # Do not use 
sim_message_eventcallback_scenesave        =0x104        # about to save a scene 
sim_message_eventcallback_modelsave        =0x105      # about to save a model (current selection will be saved) 
sim_message_eventcallback_moduleopen    =0x106        # called when simOpenModule in Lua is called 
sim_message_eventcallback_modulehandle    =0x107        # called when simHandleModule in Lua is called with argument false 
sim_message_eventcallback_moduleclose    =0x108        # called when simCloseModule in Lua is called 
sim_message_reserved4                    =0x109      # Do not use 
sim_message_reserved5                    =0x10a        # Do not use 
sim_message_reserved6                    =0x10b        # Do not use 
sim_message_reserved7                    =0x10c        # Do not use 
sim_message_eventcallback_instancepass    =0x10d        # Called once every main application loop pass. auxiliaryData[0] contains event flags of events that happened since last time 
sim_message_eventcallback_broadcast     =0x10e
sim_message_eventcallback_imagefilter_enumreset =0x10f
sim_message_eventcallback_imagefilter_enumerate      =0x110
sim_message_eventcallback_imagefilter_adjustparams   =0x111
sim_message_eventcallback_imagefilter_reserved       =0x112
sim_message_eventcallback_imagefilter_process        =0x113
sim_message_eventcallback_reserved1                  =0x114   # do not use 
sim_message_eventcallback_reserved2                  =0x115   # do not use 
sim_message_eventcallback_reserved3                  =0x116   # do not use 
sim_message_eventcallback_reserved4                  =0x117   # do not use 
sim_message_eventcallback_abouttoundo                 =0x118   # the undo button was hit and a previous state is about to be restored 
sim_message_eventcallback_undoperformed                 =0x119   # the undo button was hit and a previous state restored 
sim_message_eventcallback_abouttoredo                 =0x11a   # the redo button was hit and a future state is about to be restored  
sim_message_eventcallback_redoperformed                 =0x11b   # the redo button was hit and a future state restored  
sim_message_eventcallback_scripticondblclick         =0x11c   # scipt icon was double clicked.  (aux[0]=object handle associated with script set replyData[0] to 1 if script should not be opened)  
sim_message_eventcallback_simulationabouttostart     =0x11d
sim_message_eventcallback_simulationended            =0x11e
sim_message_eventcallback_reserved5                     =0x11f   # do not use 
sim_message_eventcallback_keypress                     =0x120   # a key was pressed while the focus was on a page (aux[0]=key aux[1]=ctrl and shift key state) 
sim_message_eventcallback_modulehandleinsensingpart  =0x121   # called when simHandleModule in Lua is called with argument true 
sim_message_eventcallback_renderingpass              =0x122   # called just before the scene is rendered 
sim_message_eventcallback_bannerclicked              =0x123   # called when a banner was clicked (aux[0]=banner ID) 
sim_message_eventcallback_menuitemselected           =0x124   # auxiliaryData[0] indicates the handle of the item auxiliaryData[1] indicates the state of the item 
sim_message_eventcallback_refreshdialogs             =0x125   # aux[0]=refresh degree (0=light 1=medium 2=full) 
sim_message_eventcallback_sceneloaded                =0x126
sim_message_eventcallback_modelloaded                =0x127
sim_message_eventcallback_instanceswitch             =0x128
sim_message_eventcallback_guipass                    =0x129
sim_message_eventcallback_mainscriptabouttobecalled  =0x12a
sim_message_eventcallback_rmlposition                =0x12b   #the command simRMLPosition was called. The appropriate plugin should handle the call
sim_message_eventcallback_rmlvelocity                =0x12c   # the command simRMLVelocity was called. The appropriate plugin should handle the call
sim_message_simulation_start_resume_request          =0x1000
sim_message_simulation_pause_request                 =0x1001
sim_message_simulation_stop_request                  =0x1002

# Scene object properties. Combine with the | operator 
sim_objectproperty_reserved1                =0x0000
sim_objectproperty_reserved2                =0x0001
sim_objectproperty_reserved3                =0x0002
sim_objectproperty_reserved4                =0x0003
sim_objectproperty_reserved5                =0x0004 # formely sim_objectproperty_visible 
sim_objectproperty_reserved6                =0x0008 # formely sim_objectproperty_wireframe 
sim_objectproperty_collapsed                =0x0010
sim_objectproperty_selectable                =0x0020
sim_objectproperty_reserved7                =0x0040
sim_objectproperty_selectmodelbaseinstead    =0x0080
sim_objectproperty_dontshowasinsidemodel    =0x0100
# reserved                                    =0x0200 
sim_objectproperty_canupdatedna                =0x0400
sim_objectproperty_selectinvisible            =0x0800
sim_objectproperty_depthinvisible            =0x1000


# type of arguments (input and output) for custom lua commands 
sim_lua_arg_nil     =0
sim_lua_arg_bool    =1    
sim_lua_arg_int     =2
sim_lua_arg_float   =3
sim_lua_arg_string  =4
sim_lua_arg_invalid =5
sim_lua_arg_table   =8

# custom user interface properties. Values are serialized. 
sim_ui_property_visible                        =0x0001
sim_ui_property_visibleduringsimulationonly    =0x0002
sim_ui_property_moveable                    =0x0004
sim_ui_property_relativetoleftborder        =0x0008
sim_ui_property_relativetotopborder            =0x0010
sim_ui_property_fixedwidthfont                =0x0020
sim_ui_property_systemblock                    =0x0040
sim_ui_property_settocenter                    =0x0080
sim_ui_property_rolledup                    =0x0100
sim_ui_property_selectassociatedobject        =0x0200
sim_ui_property_visiblewhenobjectselected    =0x0400


# button properties. Values are serialized. 
sim_buttonproperty_button                =0x0000
sim_buttonproperty_label                =0x0001
sim_buttonproperty_slider                =0x0002
sim_buttonproperty_editbox                =0x0003
sim_buttonproperty_staydown                =0x0008
sim_buttonproperty_enabled                =0x0010
sim_buttonproperty_borderless            =0x0020
sim_buttonproperty_horizontallycentered    =0x0040
sim_buttonproperty_ignoremouse            =0x0080
sim_buttonproperty_isdown                =0x0100
sim_buttonproperty_transparent            =0x0200
sim_buttonproperty_nobackgroundcolor    =0x0400
sim_buttonproperty_rollupaction            =0x0800
sim_buttonproperty_closeaction            =0x1000
sim_buttonproperty_verticallycentered    =0x2000
sim_buttonproperty_downupevent            =0x4000


# Simulation status 
sim_simulation_stopped                        =0x00                                # Simulation is stopped 
sim_simulation_paused                        =0x08                                # Simulation is paused 
sim_simulation_advancing                    =0x10                                # Simulation is advancing 
sim_simulation_advancing_firstafterstop        =sim_simulation_advancing|0x00        # First simulation pass (1x) 
sim_simulation_advancing_running            =sim_simulation_advancing|0x01        # Normal simulation pass (&gt;=1x) 
# reserved                                    =sim_simulation_advancing|0x02 
sim_simulation_advancing_lastbeforepause    =sim_simulation_advancing|0x03        # Last simulation pass before pause (1x) 
sim_simulation_advancing_firstafterpause    =sim_simulation_advancing|0x04        # First simulation pass after pause (1x) 
sim_simulation_advancing_abouttostop        =sim_simulation_advancing|0x05        # "Trying to stop" simulation pass (&gt;=1x) 
sim_simulation_advancing_lastbeforestop        =sim_simulation_advancing|0x06        # Last simulation pass (1x) 


# Script execution result (first return value) 
sim_script_no_error                    =0
sim_script_main_script_nonexistent    =1
sim_script_main_script_not_called    =2
sim_script_reentrance_error            =4
sim_script_lua_error                =8
sim_script_call_error                =16


 # Script types (serialized!) 
sim_scripttype_mainscript   =0
sim_scripttype_childscript  =1
sim_scripttype_jointctrlcallback  =4
sim_scripttype_contactcallback  =5
sim_scripttype_customizationscript  =6
sim_scripttype_generalcallback  =7

# API call error messages 
sim_api_errormessage_ignore    =0    # does not memorize nor output errors 
sim_api_errormessage_report    =1    # memorizes errors (default for C-API calls) 
sim_api_errormessage_output    =2  # memorizes and outputs errors (default for Lua-API calls) 


# special argument of some functions 
sim_handle_all                        =-2
sim_handle_all_except_explicit        =-3
sim_handle_self                        =-4
sim_handle_main_script                =-5
sim_handle_tree                        =-6
sim_handle_chain                    =-7
sim_handle_single                    =-8
sim_handle_default                    =-9
sim_handle_all_except_self            =-10
sim_handle_parent                    =-11


# special handle flags
sim_handleflag_assembly                =0x400000
sim_handleflag_model                =0x800000


# distance calculation methods (serialized) 
sim_distcalcmethod_dl               =0
sim_distcalcmethod_dac              =1
sim_distcalcmethod_max_dl_dac       =2
sim_distcalcmethod_dl_and_dac       =3
sim_distcalcmethod_sqrt_dl2_and_dac2=4
sim_distcalcmethod_dl_if_nonzero    =5
sim_distcalcmethod_dac_if_nonzero   =6


 # Generic dialog styles 
sim_dlgstyle_message        =0
sim_dlgstyle_input          =1
sim_dlgstyle_ok             =2
sim_dlgstyle_ok_cancel      =3
sim_dlgstyle_yes_no         =4
sim_dlgstyle_dont_center    =32# can be combined with one of above values. Only with this flag can the position of the related UI be set just after dialog creation  

 # Generic dialog return values 
sim_dlgret_still_open   =0
sim_dlgret_ok           =1
sim_dlgret_cancel       =2
sim_dlgret_yes          =3
sim_dlgret_no           =4


# Path properties 
sim_pathproperty_show_line                            =0x0001
sim_pathproperty_show_orientation                    =0x0002
sim_pathproperty_closed_path                        =0x0004
sim_pathproperty_automatic_orientation                =0x0008
sim_pathproperty_invert_velocity                    =0x0010
sim_pathproperty_infinite_acceleration                =0x0020
sim_pathproperty_flat_path                            =0x0040
sim_pathproperty_show_position                        =0x0080
sim_pathproperty_auto_velocity_profile_translation    =0x0100
sim_pathproperty_auto_velocity_profile_rotation        =0x0200
sim_pathproperty_endpoints_at_zero                    =0x0400
sim_pathproperty_keep_x_up                            =0x0800


 # drawing objects 
# following are mutually exclusive 
sim_drawing_points          =0            # 3 values per point (point size in pixels) 
sim_drawing_lines            =1            # 6 values per line (line size in pixels) 
sim_drawing_triangles        =2            # 9 values per triangle 
sim_drawing_trianglepoints    =3            # 6 values per point (3 for triangle position 3 for triangle normal vector) (triangle size in meters) 
sim_drawing_quadpoints        =4            # 6 values per point (3 for quad position 3 for quad normal vector) (quad size in meters) 
sim_drawing_discpoints        =5            # 6 values per point (3 for disc position 3 for disc normal vector) (disc size in meters) 
sim_drawing_cubepoints        =6          # 6 values per point (3 for cube position 3 for cube normal vector) (cube size in meters) 
sim_drawing_spherepoints    =7          # 3 values per point (sphere size in meters) 

# following can be or-combined 
sim_drawing_itemcolors                =0x00020 # +3 values per item (each item has its own ambient color (rgb values)).
                                             # Mutually exclusive with sim_drawing_vertexcolors 
sim_drawing_vertexcolors            =0x00040 # +3 values per vertex (each vertex has its own ambient color (rgb values). Only for sim_drawing_lines (+6) and for sim_drawing_triangles(+9)). Mutually exclusive with sim_drawing_itemcolors 
sim_drawing_itemsizes                =0x00080 # +1 value per item (each item has its own size). Not for sim_drawing_triangles 
sim_drawing_backfaceculling            =0x00100 # back faces are not displayed for all items 
sim_drawing_wireframe                =0x00200 # all items displayed in wireframe 
sim_drawing_painttag                =0x00400 # all items are tagged as paint (for additinal processing at a later stage) 
sim_drawing_followparentvisibility    =0x00800 # if the object is associated with a scene object then it follows that visibility otherwise it is always visible 
sim_drawing_cyclic                    =0x01000 # if the max item count was reached then the first items are overwritten. 
sim_drawing_50percenttransparency    =0x02000 # the drawing object will be 50% transparent 
sim_drawing_25percenttransparency    =0x04000 # the drawing object will be 25% transparent 
sim_drawing_12percenttransparency    =0x08000 # the drawing object will be 12.5% transparent 
sim_drawing_emissioncolor            =0x10000 # When used in combination with sim_drawing_itemcolors or sim_drawing_vertexcolors then the specified colors will be for the emissive component 
sim_drawing_facingcamera            =0x20000 # Only for trianglepoints quadpoints discpoints and cubepoints. If specified the normal verctor is calculated to face the camera (each item data requires 3 values less) 
sim_drawing_overlay                    =0x40000 # When specified objects are always drawn on top of "regular objects" 
sim_drawing_itemtransparency        =0x80000  # +1 value per item (each item has its own transparency value (0-1)). Not compatible with sim_drawing_vertexcolors 

# banner values 
# following can be or-combined 
sim_banner_left                        =0x00001 # Banners display on the left of the specified point 
sim_banner_right                    =0x00002 # Banners display on the right of the specified point 
sim_banner_nobackground                =0x00004 # Banners have no background rectangle 
sim_banner_overlay                    =0x00008 # When specified banners are always drawn on top of "regular objects" 
sim_banner_followparentvisibility    =0x00010 # if the object is associated with a scene object then it follows that visibility otherwise it is always visible 
sim_banner_clickselectsparent        =0x00020 # if the object is associated with a scene object then clicking the banner will select the scene object 
sim_banner_clicktriggersevent        =0x00040 # if the banner is clicked an event is triggered (sim_message_eventcallback_bannerclicked and sim_message_bannerclicked are generated) 
sim_banner_facingcamera                =0x00080 # If specified the banner will always face the camera by rotating around the banner's vertical axis (y-axis) 
sim_banner_fullyfacingcamera        =0x00100 # If specified the banner will always fully face the camera (the banner's orientation is same as the camera looking at it) 
sim_banner_backfaceculling            =0x00200 # If specified the banner will only be visible from one side 
sim_banner_keepsamesize                =0x00400 # If specified the banner will always appear in the same size. In that case size represents the character height in pixels 
sim_banner_bitmapfont                =0x00800 # If specified a fixed-size bitmap font is used. The text will also always fully face the camera and be right 
                                             # to the specified position. Bitmap fonts are not clickable 


# particle objects following are mutually exclusive 
sim_particle_points1        =0  # 6 values per point (pt1 and pt2. Pt1 is start position pt2-pt1 is the initial velocity vector). i
                                #Point is 1 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_points2        =1    # 6 values per point. Point is 2 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_points4        =2    # 6 values per point. Point is 4 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_roughspheres    =3    # 6 values per sphere. Only appearance is rough. Internally a perfect sphere 
sim_particle_spheres        =4    # 6 values per sphere. Internally a perfect sphere 




# following can be or-combined 
sim_particle_respondable1to4        =0x0020 # the particles are respondable against shapes (against all objects that have at least one bit 1-4 activated in the global respondable mask) 
sim_particle_respondable5to8        =0x0040 # the particles are respondable against shapes (against all objects that have at least one bit 5-8 activated in the global respondable mask) 
sim_particle_particlerespondable    =0x0080 # the particles are respondable against each other 
sim_particle_ignoresgravity            =0x0100 # the particles ignore the effect of gravity. Not compatible with sim_particle_water 
sim_particle_invisible                =0x0200 # the particles are invisible 
sim_particle_itemsizes                =0x0400 # +1 value per particle (each particle can have a different size) 
sim_particle_itemdensities            =0x0800 # +1 value per particle (each particle can have a different density) 
sim_particle_itemcolors                =0x1000 # +3 values per particle (each particle can have a different color) 
sim_particle_cyclic                    =0x2000 # if the max item count was reached then the first items are overwritten. 
sim_particle_emissioncolor            =0x4000 # When used in combination with sim_particle_itemcolors then the specified colors will be for the emissive component 
sim_particle_water                    =0x8000 # the particles are water particles (no weight in the water (i.e. when z&lt;0)). Not compatible with sim_particle_ignoresgravity 
sim_particle_painttag                =0x10000 # The particles can be seen by vision sensors (sim_particle_invisible must not be set) 




# custom user interface menu attributes 
sim_ui_menu_title        =1
sim_ui_menu_minimize    =2
sim_ui_menu_close        =4
sim_ui_menu_systemblock =8



# Boolean parameters 
sim_boolparam_hierarchy_visible                 =0
sim_boolparam_console_visible                   =1
sim_boolparam_collision_handling_enabled        =2
sim_boolparam_distance_handling_enabled         =3
sim_boolparam_ik_handling_enabled               =4
sim_boolparam_gcs_handling_enabled              =5
sim_boolparam_dynamics_handling_enabled         =6
sim_boolparam_joint_motion_handling_enabled     =7
sim_boolparam_path_motion_handling_enabled      =8
sim_boolparam_proximity_sensor_handling_enabled =9
sim_boolparam_vision_sensor_handling_enabled    =10
sim_boolparam_mill_handling_enabled             =11
sim_boolparam_browser_visible                   =12
sim_boolparam_scene_and_model_load_messages     =13
sim_reserved0                                   =14
sim_boolparam_shape_textures_are_visible        =15
sim_boolparam_display_enabled                   =16
sim_boolparam_infotext_visible                  =17
sim_boolparam_statustext_open                   =18
sim_boolparam_fog_enabled                       =19
sim_boolparam_rml2_available                    =20
sim_boolparam_rml4_available                    =21
sim_boolparam_mirrors_enabled                    =22
sim_boolparam_aux_clip_planes_enabled            =23
sim_boolparam_full_model_copy_from_api            =24
sim_boolparam_realtime_simulation                =25
sim_boolparam_force_show_wireless_emission        =27
sim_boolparam_force_show_wireless_reception        =28
sim_boolparam_video_recording_triggered            =29
sim_boolparam_threaded_rendering_enabled        =32
sim_boolparam_fullscreen                        =33
sim_boolparam_headless                            =34
sim_boolparam_hierarchy_toolbarbutton_enabled    =35
sim_boolparam_browser_toolbarbutton_enabled        =36
sim_boolparam_objectshift_toolbarbutton_enabled    =37
sim_boolparam_objectrotate_toolbarbutton_enabled=38
sim_boolparam_force_calcstruct_all_visible        =39
sim_boolparam_force_calcstruct_all                =40
sim_boolparam_exit_request                        =41
sim_boolparam_play_toolbarbutton_enabled        =42
sim_boolparam_pause_toolbarbutton_enabled        =43
sim_boolparam_stop_toolbarbutton_enabled        =44
sim_boolparam_waiting_for_trigger                =45


# Integer parameters 
sim_intparam_error_report_mode      =0  # Check sim_api_errormessage_... constants above for valid values 
sim_intparam_program_version        =1  # e.g Version 2.1.4 --&gt; 20104. Can only be read 
sim_intparam_instance_count         =2  # do not use anymore (always returns 1 since CoppeliaSim 2.5.11) 
sim_intparam_custom_cmd_start_id    =3  # can only be read 
sim_intparam_compilation_version    =4  # 0=evaluation version 1=full version 2=player version. Can only be read 
sim_intparam_current_page           =5
sim_intparam_flymode_camera_handle  =6  # can only be read 
sim_intparam_dynamic_step_divider   =7  # can only be read 
sim_intparam_dynamic_engine         =8  # 0=Bullet 1=ODE. 2=Vortex.
sim_intparam_server_port_start      =9  # can only be read 
sim_intparam_server_port_range      =10 # can only be read 
sim_intparam_visible_layers         =11
sim_intparam_infotext_style         =12
sim_intparam_settings               =13
sim_intparam_edit_mode_type         =14 # can only be read 
sim_intparam_server_port_next       =15 # is initialized at sim_intparam_server_port_start 
sim_intparam_qt_version             =16 # version of the used Qt framework 
sim_intparam_event_flags_read       =17 # can only be read 
sim_intparam_event_flags_read_clear =18 # can only be read 
sim_intparam_platform               =19 # can only be read 
sim_intparam_scene_unique_id        =20 # can only be read 
sim_intparam_work_thread_count      =21
sim_intparam_mouse_x                =22
sim_intparam_mouse_y                =23
sim_intparam_core_count             =24
sim_intparam_work_thread_calc_time_ms =25
sim_intparam_idle_fps               =26
sim_intparam_prox_sensor_select_down =27
sim_intparam_prox_sensor_select_up  =28
sim_intparam_stop_request_counter   =29
sim_intparam_program_revision       =30
sim_intparam_mouse_buttons          =31
sim_intparam_dynamic_warning_disabled_mask =32
sim_intparam_simulation_warning_disabled_mask =33
sim_intparam_scene_index            =34
sim_intparam_motionplanning_seed    =35
sim_intparam_speedmodifier          =36

# Float parameters 
sim_floatparam_rand=0 # random value (0.0-1.0) 
sim_floatparam_simulation_time_step =1
sim_floatparam_stereo_distance        =2

# String parameters 
sim_stringparam_application_path=0 # path of CoppeliaSim's executable 
sim_stringparam_video_filename=1
sim_stringparam_app_arg1            =2
sim_stringparam_app_arg2            =3
sim_stringparam_app_arg3            =4
sim_stringparam_app_arg4            =5
sim_stringparam_app_arg5            =6
sim_stringparam_app_arg6            =7
sim_stringparam_app_arg7            =8
sim_stringparam_app_arg8            =9
sim_stringparam_app_arg9            =10
sim_stringparam_scene_path_and_name    =13

# Array parameters 
sim_arrayparam_gravity          =0
sim_arrayparam_fog              =1
sim_arrayparam_fog_color        =2
sim_arrayparam_background_color1=3
sim_arrayparam_background_color2=4
sim_arrayparam_ambient_light    =5
sim_arrayparam_random_euler        =6

sim_objintparam_visibility_layer= 10
sim_objfloatparam_abs_x_velocity= 11
sim_objfloatparam_abs_y_velocity= 12
sim_objfloatparam_abs_z_velocity= 13
sim_objfloatparam_abs_rot_velocity= 14
sim_objfloatparam_objbbox_min_x= 15
sim_objfloatparam_objbbox_min_y= 16
sim_objfloatparam_objbbox_min_z= 17
sim_objfloatparam_objbbox_max_x= 18
sim_objfloatparam_objbbox_max_y= 19
sim_objfloatparam_objbbox_max_z= 20
sim_objfloatparam_modelbbox_min_x= 21
sim_objfloatparam_modelbbox_min_y= 22
sim_objfloatparam_modelbbox_min_z= 23
sim_objfloatparam_modelbbox_max_x= 24
sim_objfloatparam_modelbbox_max_y= 25
sim_objfloatparam_modelbbox_max_z= 26
sim_objintparam_collection_self_collision_indicator= 27
sim_objfloatparam_transparency_offset= 28
sim_objintparam_child_role= 29
sim_objintparam_parent_role= 30
sim_objintparam_manipulation_permissions= 31
sim_objintparam_illumination_handle= 32

sim_visionfloatparam_near_clipping= 1000
sim_visionfloatparam_far_clipping= 1001
sim_visionintparam_resolution_x= 1002
sim_visionintparam_resolution_y= 1003
sim_visionfloatparam_perspective_angle= 1004
sim_visionfloatparam_ortho_size= 1005
sim_visionintparam_disabled_light_components= 1006
sim_visionintparam_rendering_attributes= 1007
sim_visionintparam_entity_to_render= 1008
sim_visionintparam_windowed_size_x= 1009
sim_visionintparam_windowed_size_y= 1010
sim_visionintparam_windowed_pos_x= 1011
sim_visionintparam_windowed_pos_y= 1012
sim_visionintparam_pov_focal_blur= 1013
sim_visionfloatparam_pov_blur_distance= 1014
sim_visionfloatparam_pov_aperture= 1015
sim_visionintparam_pov_blur_sampled= 1016
sim_visionintparam_render_mode= 1017

sim_jointintparam_motor_enabled= 2000
sim_jointintparam_ctrl_enabled= 2001
sim_jointfloatparam_pid_p= 2002
sim_jointfloatparam_pid_i= 2003
sim_jointfloatparam_pid_d= 2004
sim_jointfloatparam_intrinsic_x= 2005
sim_jointfloatparam_intrinsic_y= 2006
sim_jointfloatparam_intrinsic_z= 2007
sim_jointfloatparam_intrinsic_qx= 2008
sim_jointfloatparam_intrinsic_qy= 2009
sim_jointfloatparam_intrinsic_qz= 2010
sim_jointfloatparam_intrinsic_qw= 2011
sim_jointfloatparam_velocity= 2012
sim_jointfloatparam_spherical_qx= 2013
sim_jointfloatparam_spherical_qy= 2014
sim_jointfloatparam_spherical_qz= 2015
sim_jointfloatparam_spherical_qw= 2016
sim_jointfloatparam_upper_limit= 2017
sim_jointfloatparam_kc_k= 2018
sim_jointfloatparam_kc_c= 2019
sim_jointfloatparam_ik_weight= 2021
sim_jointfloatparam_error_x= 2022
sim_jointfloatparam_error_y= 2023
sim_jointfloatparam_error_z= 2024
sim_jointfloatparam_error_a= 2025
sim_jointfloatparam_error_b= 2026
sim_jointfloatparam_error_g= 2027
sim_jointfloatparam_error_pos= 2028
sim_jointfloatparam_error_angle= 2029
sim_jointintparam_velocity_lock= 2030
sim_jointintparam_vortex_dep_handle= 2031
sim_jointfloatparam_vortex_dep_multiplication= 2032
sim_jointfloatparam_vortex_dep_offset= 2033

sim_shapefloatparam_init_velocity_x= 3000
sim_shapefloatparam_init_velocity_y= 3001
sim_shapefloatparam_init_velocity_z= 3002
sim_shapeintparam_static= 3003
sim_shapeintparam_respondable= 3004
sim_shapefloatparam_mass= 3005
sim_shapefloatparam_texture_x= 3006
sim_shapefloatparam_texture_y= 3007
sim_shapefloatparam_texture_z= 3008
sim_shapefloatparam_texture_a= 3009
sim_shapefloatparam_texture_b= 3010
sim_shapefloatparam_texture_g= 3011
sim_shapefloatparam_texture_scaling_x= 3012
sim_shapefloatparam_texture_scaling_y= 3013
sim_shapeintparam_culling= 3014
sim_shapeintparam_wireframe= 3015
sim_shapeintparam_compound= 3016
sim_shapeintparam_convex= 3017
sim_shapeintparam_convex_check= 3018
sim_shapeintparam_respondable_mask= 3019
sim_shapefloatparam_init_velocity_a= 3020
sim_shapefloatparam_init_velocity_b= 3021
sim_shapefloatparam_init_velocity_g= 3022
sim_shapestringparam_color_name= 3023
sim_shapeintparam_edge_visibility= 3024
sim_shapefloatparam_shading_angle= 3025
sim_shapefloatparam_edge_angle= 3026
sim_shapeintparam_edge_borders_hidden= 3027

sim_proxintparam_ray_invisibility= 4000

sim_forcefloatparam_error_x= 5000
sim_forcefloatparam_error_y= 5001
sim_forcefloatparam_error_z= 5002
sim_forcefloatparam_error_a= 5003
sim_forcefloatparam_error_b= 5004
sim_forcefloatparam_error_g= 5005
sim_forcefloatparam_error_pos= 5006
sim_forcefloatparam_error_angle= 5007

sim_lightintparam_pov_casts_shadows= 8000

sim_cameraintparam_disabled_light_components= 9000
sim_camerafloatparam_perspective_angle= 9001
sim_camerafloatparam_ortho_size= 9002
sim_cameraintparam_rendering_attributes= 9003
sim_cameraintparam_pov_focal_blur= 9004
sim_camerafloatparam_pov_blur_distance= 9005
sim_camerafloatparam_pov_aperture= 9006
sim_cameraintparam_pov_blur_samples= 9007

sim_dummyintparam_link_type= 10000

sim_mirrorfloatparam_width= 12000
sim_mirrorfloatparam_height= 12001
sim_mirrorfloatparam_reflectance= 12002
sim_mirrorintparam_enable= 12003

sim_pplanfloatparam_x_min= 20000
sim_pplanfloatparam_x_range= 20001
sim_pplanfloatparam_y_min= 20002
sim_pplanfloatparam_y_range= 20003
sim_pplanfloatparam_z_min= 20004
sim_pplanfloatparam_z_range= 20005
sim_pplanfloatparam_delta_min= 20006
sim_pplanfloatparam_delta_range= 20007

sim_mplanintparam_nodes_computed= 25000
sim_mplanintparam_prepare_nodes= 25001
sim_mplanintparam_clear_nodes= 25002

# User interface elements 
sim_gui_menubar                        =0x0001
sim_gui_popups                        =0x0002
sim_gui_toolbar1                    =0x0004
sim_gui_toolbar2                    =0x0008
sim_gui_hierarchy                    =0x0010
sim_gui_infobar                        =0x0020
sim_gui_statusbar                    =0x0040
sim_gui_scripteditor                =0x0080
sim_gui_scriptsimulationparameters    =0x0100
sim_gui_dialogs                        =0x0200
sim_gui_browser                        =0x0400
sim_gui_all                            =0xffff


# Joint modes 
sim_jointmode_passive       =0
sim_jointmode_motion        =1
sim_jointmode_ik            =2
sim_jointmode_ikdependent   =3
sim_jointmode_dependent     =4
sim_jointmode_force         =5


# Navigation and selection modes with the mouse. Lower byte values are mutually exclusive upper byte bits can be combined 
sim_navigation_passive                    =0x0000
sim_navigation_camerashift                =0x0001
sim_navigation_camerarotate                =0x0002
sim_navigation_camerazoom                =0x0003
sim_navigation_cameratilt                =0x0004
sim_navigation_cameraangle                =0x0005
sim_navigation_camerafly                =0x0006
sim_navigation_objectshift                =0x0007
sim_navigation_objectrotate                =0x0008
sim_navigation_reserved2                =0x0009
sim_navigation_reserved3                =0x000A
sim_navigation_jointpathtest            =0x000B
sim_navigation_ikmanip                    =0x000C
sim_navigation_objectmultipleselection    =0x000D
# Bit-combine following values and add them to one of above's values for a valid navigation mode 
sim_navigation_reserved4                =0x0100
sim_navigation_clickselection            =0x0200
sim_navigation_ctrlselection            =0x0400
sim_navigation_shiftselection            =0x0800
sim_navigation_camerazoomwheel            =0x1000
sim_navigation_camerarotaterightbutton    =0x2000



#Remote API constants
SIMX_VERSION                    =0 
# Remote API message header structure 
SIMX_HEADER_SIZE                =18
simx_headeroffset_crc           =0    # 1 simxUShort. Generated by the client or server. The CRC for the message 
simx_headeroffset_version       =2    # 1 byte. Generated by the client or server. The version of the remote API software 
simx_headeroffset_message_id    =3    # 1 simxInt. Generated by the client (and used in a reply by the server) 
simx_headeroffset_client_time   =7    # 1 simxInt. Client time stamp generated by the client (and sent back by the server) 
simx_headeroffset_server_time   =11    # 1 simxInt. Generated by the server when a reply is generated. The server timestamp 
simx_headeroffset_scene_id      =15    # 1 simxUShort. Generated by the server. A unique ID identifying the scene currently displayed 
simx_headeroffset_server_state  =17    # 1 byte. Generated by the server. Bit coded 0 set --&gt; simulation not stopped 1 set --&gt; simulation paused 2 set --&gt; real-time switch on 3-5 edit mode type (0=no edit mode 1=triangle 2=vertex 3=edge 4=path 5=UI)  

# Remote API command header 
SIMX_SUBHEADER_SIZE                 =26
simx_cmdheaderoffset_mem_size       =0    # 1 simxInt. Generated by the client or server. The buffer size of the command. 
simx_cmdheaderoffset_full_mem_size  =4    # 1 simxInt. Generated by the client or server. The full buffer size of the command (applies to split chunks). 
simx_cmdheaderoffset_pdata_offset0  =8    # 1 simxUShort. Generated by the client or server. The amount of data that is part of the command identification. 
simx_cmdheaderoffset_pdata_offset1  =10    # 1 simxInt. Generated by the client or server. The amount of shift of the pure data buffer (applies to split chunks). 
simx_cmdheaderoffset_cmd=14    # 1 simxInt. Generated by the client (and used in a reply by the server). The command combined with the operation mode of the command. 
simx_cmdheaderoffset_delay_or_split =18    # 1 simxUShort. Generated by the client or server. The amount of delay in ms of a continuous command or the max. pure data size to send at once (applies to split commands). 
simx_cmdheaderoffset_sim_time       =20    # 1 simxInt. Generated by the server. The simulation time (in ms) when the command was executed (or 0 if simulation is not running) 
simx_cmdheaderoffset_status         =24    # 1 byte. Generated by the server. (1 bit 0 is set --&gt; error in function execution on server side). The client writes bit 1 if command cannot be overwritten
simx_cmdheaderoffset_reserved       =25    # 1 byte. Not yet used 





# Regular operation modes 
simx_opmode_oneshot                =0x000000 # sends command as one chunk. Reply will also come as one chunk. Doesn't wait for the reply. 
simx_opmode_blocking            =0x010000 # sends command as one chunk. Reply will also come as one chunk. Waits for the reply (_REPLY_WAIT_TIMEOUT_IN_MS is the timeout). 
simx_opmode_oneshot_wait        =0x010000 # sends command as one chunk. Reply will also come as one chunk. Waits for the reply (_REPLY_WAIT_TIMEOUT_IN_MS is the timeout). 
simx_opmode_continuous            =0x020000  
simx_opmode_streaming            =0x020000 # sends command as one chunk. Command will be stored on the server and always executed 
                                                      #(every x ms (as far as possible) where x can be 0-65535. just add x to opmode_continuous). 
                                                      # A reply will be sent continuously each time as one chunk. Doesn't wait for the reply. 

# Operation modes for heavy data 
simx_opmode_oneshot_split        =0x030000   # sends command as several chunks (max chunk size is x bytes where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to opmode_oneshot_split). Reply will also come as several chunks. Doesn't wait for the reply.      
simx_opmode_continuous_split    =0x040000
simx_opmode_streaming_split    =0x040000    # sends command as several chunks (max chunk size is x bytes where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to opmode_continuous_split). Command will be stored on the server and always executed. A reply will be sent continuously each time as several chunks. Doesn't wait for the reply. 

# Special operation modes 
simx_opmode_discontinue            =0x050000    # removes and cancels all commands stored on the client or server side (also continuous commands) 
simx_opmode_buffer                =0x060000    # doesn't send anything but checks if a reply for the given command is available in the input buffer (i.e. previously received from the server) 
simx_opmode_remove                =0x070000    # doesn't send anything and doesn't return any specific value. It just erases a similar command reply in the inbox (to free some memory) 


# Command return codes 
simx_return_ok                    =0x000000
simx_return_novalue_flag        =0x000001        # input buffer doesn't contain the specified command 
simx_return_timeout_flag        =0x000002        # command reply not received in time for opmode_oneshot_wait operation mode 
simx_return_illegal_opmode_flag    =0x000004        # command doesn't support the specified operation mode 
simx_return_remote_error_flag    =0x000008        # command caused an error on the server side 
simx_return_split_progress_flag    =0x000010        # previous similar command not yet fully processed (applies to opmode_oneshot_split operation modes) 
simx_return_local_error_flag    =0x000020        # command caused an error on the client side 
simx_return_initialize_error_flag    =0x000040        # simxStart was not yet called 

# Following for backward compatibility (same as above) 
simx_error_noerror                =0x000000
simx_error_novalue_flag            =0x000001        # input buffer doesn't contain the specified command 
simx_error_timeout_flag            =0x000002        # command reply not received in time for opmode_oneshot_wait operation mode 
simx_error_illegal_opmode_flag    =0x000004        # command doesn't support the specified operation mode 
simx_error_remote_error_flag    =0x000008        # command caused an error on the server side 
simx_error_split_progress_flag    =0x000010        # previous similar command not yet fully processed (applies to opmode_oneshot_split operation modes) 
simx_error_local_error_flag        =0x000020        # command caused an error on the client side 
simx_error_initialize_error_flag        =0x000040        # simxStart was not yet called 


</t>
<t tx="leo.20210713140956.174">
# for windows 64 bit coppeliasim 4.1.0 rev4
# put simConst content into sim.py
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210713140956.175">import platform
import struct
import sys
import os
import ctypes as ct
# directly bring simConst.py into sim.py
#from simConst import *

#constants
#Scene object types. Values are serialized
sim_object_shape_type           =0
sim_object_joint_type           =1
sim_object_graph_type           =2
sim_object_camera_type          =3
sim_object_dummy_type           =4
sim_object_proximitysensor_type =5
sim_object_reserved1            =6
sim_object_reserved2            =7
sim_object_path_type            =8
sim_object_visionsensor_type    =9
sim_object_volume_type          =10
sim_object_mill_type            =11
sim_object_forcesensor_type     =12
sim_object_light_type           =13
sim_object_mirror_type          =14

#General object types. Values are serialized
sim_appobj_object_type          =109
sim_appobj_collision_type       =110
sim_appobj_distance_type        =111
sim_appobj_simulation_type      =112
sim_appobj_ik_type              =113
sim_appobj_constraintsolver_type=114
sim_appobj_collection_type      =115
sim_appobj_ui_type              =116
sim_appobj_script_type          =117
sim_appobj_pathplanning_type    =118
sim_appobj_RESERVED_type        =119
sim_appobj_texture_type         =120

# Ik calculation methods. Values are serialized
sim_ik_pseudo_inverse_method        =0
sim_ik_damped_least_squares_method  =1
sim_ik_jacobian_transpose_method    =2

# Ik constraints. Values are serialized
sim_ik_x_constraint         =1
sim_ik_y_constraint         =2
sim_ik_z_constraint         =4
sim_ik_alpha_beta_constraint=8
sim_ik_gamma_constraint     =16
sim_ik_avoidance_constraint =64

# Ik calculation results 
sim_ikresult_not_performed  =0
sim_ikresult_success        =1
sim_ikresult_fail           =2

# Scene object sub-types. Values are serialized 
# Light sub-types 
sim_light_omnidirectional_subtype   =1
sim_light_spot_subtype              =2
sim_light_directional_subtype       =3
# Joint sub-types 
sim_joint_revolute_subtype          =10
sim_joint_prismatic_subtype         =11
sim_joint_spherical_subtype         =12
# Shape sub-types 
sim_shape_simpleshape_subtype       =20
sim_shape_multishape_subtype        =21
# Proximity sensor sub-types 
sim_proximitysensor_pyramid_subtype =30
sim_proximitysensor_cylinder_subtype=31
sim_proximitysensor_disc_subtype    =32
sim_proximitysensor_cone_subtype    =33
sim_proximitysensor_ray_subtype     =34
# Mill sub-types 
sim_mill_pyramid_subtype            =40
sim_mill_cylinder_subtype           =41
sim_mill_disc_subtype               =42
sim_mill_cone_subtype               =42
# No sub-type 
sim_object_no_subtype               =200


#Scene object main properties (serialized)
sim_objectspecialproperty_collidable                    =0x0001
sim_objectspecialproperty_measurable                    =0x0002
#reserved                        =0x0004 
#reserved                        =0x0008 
sim_objectspecialproperty_detectable_ultrasonic            =0x0010
sim_objectspecialproperty_detectable_infrared            =0x0020
sim_objectspecialproperty_detectable_laser                =0x0040
sim_objectspecialproperty_detectable_inductive            =0x0080
sim_objectspecialproperty_detectable_capacitive            =0x0100
sim_objectspecialproperty_renderable                    =0x0200
sim_objectspecialproperty_detectable_all =sim_objectspecialproperty_detectable_ultrasonic|sim_objectspecialproperty_detectable_infrared|sim_objectspecialproperty_detectable_laser|sim_objectspecialproperty_detectable_inductive|sim_objectspecialproperty_detectable_capacitive
sim_objectspecialproperty_cuttable                        =0x0400
sim_objectspecialproperty_pathplanning_ignored            =0x0800

# Model properties (serialized)
sim_modelproperty_not_collidable                =0x0001
sim_modelproperty_not_measurable                =0x0002
sim_modelproperty_not_renderable                =0x0004
sim_modelproperty_not_detectable                =0x0008
sim_modelproperty_not_cuttable                    =0x0010
sim_modelproperty_not_dynamic                    =0x0020
sim_modelproperty_not_respondable                =0x0040 # cannot be selected if sim_modelproperty_not_dynamic is not selected 
sim_modelproperty_not_reset                        =0x0080 # Model is not reset at simulation end. This flag is cleared at simulation end 
sim_modelproperty_not_visible                    =0x0100 # Whole model is invisible independent of local visibility settings 
sim_modelproperty_not_model                        =0xf000 # object is not a model 


# Check the documentation instead of comments below!! 
# Following messages are dispatched to the Lua-message container 
sim_message_ui_button_state_change  =0    # a UI button slider etc. changed (due to a user's action). aux[0]=UI handle aux[1]=button handle aux[2]=button attributes aux[3]=slider position (if slider) 
sim_message_reserved9               =1    # Do not use 
sim_message_object_selection_changed=2
sim_message_reserved10                =3    # do not use 
sim_message_model_loaded            =4
sim_message_reserved11                =5    # do not use 
sim_message_keypress                =6    # a key was pressed while the focus was on a page (aux[0]=key aux[1]=ctrl and shift key state) 
sim_message_bannerclicked            =7    # a banner was clicked (aux[0]=banner ID) 


# Following messages are dispatched only to the C-API (not available from Lua) 
sim_message_for_c_api_only_start        =0x100      # Do not use 
sim_message_reserved1                   =0x101      # Do not use 
sim_message_reserved2                    =0x102      # Do not use 
sim_message_reserved3                    =0x103      # Do not use 
sim_message_eventcallback_scenesave        =0x104        # about to save a scene 
sim_message_eventcallback_modelsave        =0x105      # about to save a model (current selection will be saved) 
sim_message_eventcallback_moduleopen    =0x106        # called when simOpenModule in Lua is called 
sim_message_eventcallback_modulehandle    =0x107        # called when simHandleModule in Lua is called with argument false 
sim_message_eventcallback_moduleclose    =0x108        # called when simCloseModule in Lua is called 
sim_message_reserved4                    =0x109      # Do not use 
sim_message_reserved5                    =0x10a        # Do not use 
sim_message_reserved6                    =0x10b        # Do not use 
sim_message_reserved7                    =0x10c        # Do not use 
sim_message_eventcallback_instancepass    =0x10d        # Called once every main application loop pass. auxiliaryData[0] contains event flags of events that happened since last time 
sim_message_eventcallback_broadcast     =0x10e
sim_message_eventcallback_imagefilter_enumreset =0x10f
sim_message_eventcallback_imagefilter_enumerate      =0x110
sim_message_eventcallback_imagefilter_adjustparams   =0x111
sim_message_eventcallback_imagefilter_reserved       =0x112
sim_message_eventcallback_imagefilter_process        =0x113
sim_message_eventcallback_reserved1                  =0x114   # do not use 
sim_message_eventcallback_reserved2                  =0x115   # do not use 
sim_message_eventcallback_reserved3                  =0x116   # do not use 
sim_message_eventcallback_reserved4                  =0x117   # do not use 
sim_message_eventcallback_abouttoundo                 =0x118   # the undo button was hit and a previous state is about to be restored 
sim_message_eventcallback_undoperformed                 =0x119   # the undo button was hit and a previous state restored 
sim_message_eventcallback_abouttoredo                 =0x11a   # the redo button was hit and a future state is about to be restored  
sim_message_eventcallback_redoperformed                 =0x11b   # the redo button was hit and a future state restored  
sim_message_eventcallback_scripticondblclick         =0x11c   # scipt icon was double clicked.  (aux[0]=object handle associated with script set replyData[0] to 1 if script should not be opened)  
sim_message_eventcallback_simulationabouttostart     =0x11d
sim_message_eventcallback_simulationended            =0x11e
sim_message_eventcallback_reserved5                     =0x11f   # do not use 
sim_message_eventcallback_keypress                     =0x120   # a key was pressed while the focus was on a page (aux[0]=key aux[1]=ctrl and shift key state) 
sim_message_eventcallback_modulehandleinsensingpart  =0x121   # called when simHandleModule in Lua is called with argument true 
sim_message_eventcallback_renderingpass              =0x122   # called just before the scene is rendered 
sim_message_eventcallback_bannerclicked              =0x123   # called when a banner was clicked (aux[0]=banner ID) 
sim_message_eventcallback_menuitemselected           =0x124   # auxiliaryData[0] indicates the handle of the item auxiliaryData[1] indicates the state of the item 
sim_message_eventcallback_refreshdialogs             =0x125   # aux[0]=refresh degree (0=light 1=medium 2=full) 
sim_message_eventcallback_sceneloaded                =0x126
sim_message_eventcallback_modelloaded                =0x127
sim_message_eventcallback_instanceswitch             =0x128
sim_message_eventcallback_guipass                    =0x129
sim_message_eventcallback_mainscriptabouttobecalled  =0x12a
sim_message_eventcallback_rmlposition                =0x12b   #the command simRMLPosition was called. The appropriate plugin should handle the call
sim_message_eventcallback_rmlvelocity                =0x12c   # the command simRMLVelocity was called. The appropriate plugin should handle the call
sim_message_simulation_start_resume_request          =0x1000
sim_message_simulation_pause_request                 =0x1001
sim_message_simulation_stop_request                  =0x1002

# Scene object properties. Combine with the | operator 
sim_objectproperty_reserved1                =0x0000
sim_objectproperty_reserved2                =0x0001
sim_objectproperty_reserved3                =0x0002
sim_objectproperty_reserved4                =0x0003
sim_objectproperty_reserved5                =0x0004 # formely sim_objectproperty_visible 
sim_objectproperty_reserved6                =0x0008 # formely sim_objectproperty_wireframe 
sim_objectproperty_collapsed                =0x0010
sim_objectproperty_selectable                =0x0020
sim_objectproperty_reserved7                =0x0040
sim_objectproperty_selectmodelbaseinstead    =0x0080
sim_objectproperty_dontshowasinsidemodel    =0x0100
# reserved                                    =0x0200 
sim_objectproperty_canupdatedna                =0x0400
sim_objectproperty_selectinvisible            =0x0800
sim_objectproperty_depthinvisible            =0x1000


# type of arguments (input and output) for custom lua commands 
sim_lua_arg_nil     =0
sim_lua_arg_bool    =1    
sim_lua_arg_int     =2
sim_lua_arg_float   =3
sim_lua_arg_string  =4
sim_lua_arg_invalid =5
sim_lua_arg_table   =8

# custom user interface properties. Values are serialized. 
sim_ui_property_visible                        =0x0001
sim_ui_property_visibleduringsimulationonly    =0x0002
sim_ui_property_moveable                    =0x0004
sim_ui_property_relativetoleftborder        =0x0008
sim_ui_property_relativetotopborder            =0x0010
sim_ui_property_fixedwidthfont                =0x0020
sim_ui_property_systemblock                    =0x0040
sim_ui_property_settocenter                    =0x0080
sim_ui_property_rolledup                    =0x0100
sim_ui_property_selectassociatedobject        =0x0200
sim_ui_property_visiblewhenobjectselected    =0x0400


# button properties. Values are serialized. 
sim_buttonproperty_button                =0x0000
sim_buttonproperty_label                =0x0001
sim_buttonproperty_slider                =0x0002
sim_buttonproperty_editbox                =0x0003
sim_buttonproperty_staydown                =0x0008
sim_buttonproperty_enabled                =0x0010
sim_buttonproperty_borderless            =0x0020
sim_buttonproperty_horizontallycentered    =0x0040
sim_buttonproperty_ignoremouse            =0x0080
sim_buttonproperty_isdown                =0x0100
sim_buttonproperty_transparent            =0x0200
sim_buttonproperty_nobackgroundcolor    =0x0400
sim_buttonproperty_rollupaction            =0x0800
sim_buttonproperty_closeaction            =0x1000
sim_buttonproperty_verticallycentered    =0x2000
sim_buttonproperty_downupevent            =0x4000


# Simulation status 
sim_simulation_stopped                        =0x00                                # Simulation is stopped 
sim_simulation_paused                        =0x08                                # Simulation is paused 
sim_simulation_advancing                    =0x10                                # Simulation is advancing 
sim_simulation_advancing_firstafterstop        =sim_simulation_advancing|0x00        # First simulation pass (1x) 
sim_simulation_advancing_running            =sim_simulation_advancing|0x01        # Normal simulation pass (&gt;=1x) 
# reserved                                    =sim_simulation_advancing|0x02 
sim_simulation_advancing_lastbeforepause    =sim_simulation_advancing|0x03        # Last simulation pass before pause (1x) 
sim_simulation_advancing_firstafterpause    =sim_simulation_advancing|0x04        # First simulation pass after pause (1x) 
sim_simulation_advancing_abouttostop        =sim_simulation_advancing|0x05        # "Trying to stop" simulation pass (&gt;=1x) 
sim_simulation_advancing_lastbeforestop        =sim_simulation_advancing|0x06        # Last simulation pass (1x) 


# Script execution result (first return value) 
sim_script_no_error                    =0
sim_script_main_script_nonexistent    =1
sim_script_main_script_not_called    =2
sim_script_reentrance_error            =4
sim_script_lua_error                =8
sim_script_call_error                =16


 # Script types (serialized!) 
sim_scripttype_mainscript   =0
sim_scripttype_childscript  =1
sim_scripttype_jointctrlcallback  =4
sim_scripttype_contactcallback  =5
sim_scripttype_customizationscript  =6
sim_scripttype_generalcallback  =7

# API call error messages 
sim_api_errormessage_ignore    =0    # does not memorize nor output errors 
sim_api_errormessage_report    =1    # memorizes errors (default for C-API calls) 
sim_api_errormessage_output    =2  # memorizes and outputs errors (default for Lua-API calls) 


# special argument of some functions 
sim_handle_all                        =-2
sim_handle_all_except_explicit        =-3
sim_handle_self                        =-4
sim_handle_main_script                =-5
sim_handle_tree                        =-6
sim_handle_chain                    =-7
sim_handle_single                    =-8
sim_handle_default                    =-9
sim_handle_all_except_self            =-10
sim_handle_parent                    =-11


# special handle flags
sim_handleflag_assembly                =0x400000
sim_handleflag_model                =0x800000


# distance calculation methods (serialized) 
sim_distcalcmethod_dl               =0
sim_distcalcmethod_dac              =1
sim_distcalcmethod_max_dl_dac       =2
sim_distcalcmethod_dl_and_dac       =3
sim_distcalcmethod_sqrt_dl2_and_dac2=4
sim_distcalcmethod_dl_if_nonzero    =5
sim_distcalcmethod_dac_if_nonzero   =6


 # Generic dialog styles 
sim_dlgstyle_message        =0
sim_dlgstyle_input          =1
sim_dlgstyle_ok             =2
sim_dlgstyle_ok_cancel      =3
sim_dlgstyle_yes_no         =4
sim_dlgstyle_dont_center    =32# can be combined with one of above values. Only with this flag can the position of the related UI be set just after dialog creation  

 # Generic dialog return values 
sim_dlgret_still_open   =0
sim_dlgret_ok           =1
sim_dlgret_cancel       =2
sim_dlgret_yes          =3
sim_dlgret_no           =4


# Path properties 
sim_pathproperty_show_line                            =0x0001
sim_pathproperty_show_orientation                    =0x0002
sim_pathproperty_closed_path                        =0x0004
sim_pathproperty_automatic_orientation                =0x0008
sim_pathproperty_invert_velocity                    =0x0010
sim_pathproperty_infinite_acceleration                =0x0020
sim_pathproperty_flat_path                            =0x0040
sim_pathproperty_show_position                        =0x0080
sim_pathproperty_auto_velocity_profile_translation    =0x0100
sim_pathproperty_auto_velocity_profile_rotation        =0x0200
sim_pathproperty_endpoints_at_zero                    =0x0400
sim_pathproperty_keep_x_up                            =0x0800


 # drawing objects 
# following are mutually exclusive 
sim_drawing_points          =0            # 3 values per point (point size in pixels) 
sim_drawing_lines            =1            # 6 values per line (line size in pixels) 
sim_drawing_triangles        =2            # 9 values per triangle 
sim_drawing_trianglepoints    =3            # 6 values per point (3 for triangle position 3 for triangle normal vector) (triangle size in meters) 
sim_drawing_quadpoints        =4            # 6 values per point (3 for quad position 3 for quad normal vector) (quad size in meters) 
sim_drawing_discpoints        =5            # 6 values per point (3 for disc position 3 for disc normal vector) (disc size in meters) 
sim_drawing_cubepoints        =6          # 6 values per point (3 for cube position 3 for cube normal vector) (cube size in meters) 
sim_drawing_spherepoints    =7          # 3 values per point (sphere size in meters) 

# following can be or-combined 
sim_drawing_itemcolors                =0x00020 # +3 values per item (each item has its own ambient color (rgb values)).
                                             # Mutually exclusive with sim_drawing_vertexcolors 
sim_drawing_vertexcolors            =0x00040 # +3 values per vertex (each vertex has its own ambient color (rgb values). Only for sim_drawing_lines (+6) and for sim_drawing_triangles(+9)). Mutually exclusive with sim_drawing_itemcolors 
sim_drawing_itemsizes                =0x00080 # +1 value per item (each item has its own size). Not for sim_drawing_triangles 
sim_drawing_backfaceculling            =0x00100 # back faces are not displayed for all items 
sim_drawing_wireframe                =0x00200 # all items displayed in wireframe 
sim_drawing_painttag                =0x00400 # all items are tagged as paint (for additinal processing at a later stage) 
sim_drawing_followparentvisibility    =0x00800 # if the object is associated with a scene object then it follows that visibility otherwise it is always visible 
sim_drawing_cyclic                    =0x01000 # if the max item count was reached then the first items are overwritten. 
sim_drawing_50percenttransparency    =0x02000 # the drawing object will be 50% transparent 
sim_drawing_25percenttransparency    =0x04000 # the drawing object will be 25% transparent 
sim_drawing_12percenttransparency    =0x08000 # the drawing object will be 12.5% transparent 
sim_drawing_emissioncolor            =0x10000 # When used in combination with sim_drawing_itemcolors or sim_drawing_vertexcolors then the specified colors will be for the emissive component 
sim_drawing_facingcamera            =0x20000 # Only for trianglepoints quadpoints discpoints and cubepoints. If specified the normal verctor is calculated to face the camera (each item data requires 3 values less) 
sim_drawing_overlay                    =0x40000 # When specified objects are always drawn on top of "regular objects" 
sim_drawing_itemtransparency        =0x80000  # +1 value per item (each item has its own transparency value (0-1)). Not compatible with sim_drawing_vertexcolors 

# banner values 
# following can be or-combined 
sim_banner_left                        =0x00001 # Banners display on the left of the specified point 
sim_banner_right                    =0x00002 # Banners display on the right of the specified point 
sim_banner_nobackground                =0x00004 # Banners have no background rectangle 
sim_banner_overlay                    =0x00008 # When specified banners are always drawn on top of "regular objects" 
sim_banner_followparentvisibility    =0x00010 # if the object is associated with a scene object then it follows that visibility otherwise it is always visible 
sim_banner_clickselectsparent        =0x00020 # if the object is associated with a scene object then clicking the banner will select the scene object 
sim_banner_clicktriggersevent        =0x00040 # if the banner is clicked an event is triggered (sim_message_eventcallback_bannerclicked and sim_message_bannerclicked are generated) 
sim_banner_facingcamera                =0x00080 # If specified the banner will always face the camera by rotating around the banner's vertical axis (y-axis) 
sim_banner_fullyfacingcamera        =0x00100 # If specified the banner will always fully face the camera (the banner's orientation is same as the camera looking at it) 
sim_banner_backfaceculling            =0x00200 # If specified the banner will only be visible from one side 
sim_banner_keepsamesize                =0x00400 # If specified the banner will always appear in the same size. In that case size represents the character height in pixels 
sim_banner_bitmapfont                =0x00800 # If specified a fixed-size bitmap font is used. The text will also always fully face the camera and be right 
                                             # to the specified position. Bitmap fonts are not clickable 


# particle objects following are mutually exclusive 
sim_particle_points1        =0  # 6 values per point (pt1 and pt2. Pt1 is start position pt2-pt1 is the initial velocity vector). i
                                #Point is 1 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_points2        =1    # 6 values per point. Point is 2 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_points4        =2    # 6 values per point. Point is 4 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_roughspheres    =3    # 6 values per sphere. Only appearance is rough. Internally a perfect sphere 
sim_particle_spheres        =4    # 6 values per sphere. Internally a perfect sphere 




# following can be or-combined 
sim_particle_respondable1to4        =0x0020 # the particles are respondable against shapes (against all objects that have at least one bit 1-4 activated in the global respondable mask) 
sim_particle_respondable5to8        =0x0040 # the particles are respondable against shapes (against all objects that have at least one bit 5-8 activated in the global respondable mask) 
sim_particle_particlerespondable    =0x0080 # the particles are respondable against each other 
sim_particle_ignoresgravity            =0x0100 # the particles ignore the effect of gravity. Not compatible with sim_particle_water 
sim_particle_invisible                =0x0200 # the particles are invisible 
sim_particle_itemsizes                =0x0400 # +1 value per particle (each particle can have a different size) 
sim_particle_itemdensities            =0x0800 # +1 value per particle (each particle can have a different density) 
sim_particle_itemcolors                =0x1000 # +3 values per particle (each particle can have a different color) 
sim_particle_cyclic                    =0x2000 # if the max item count was reached then the first items are overwritten. 
sim_particle_emissioncolor            =0x4000 # When used in combination with sim_particle_itemcolors then the specified colors will be for the emissive component 
sim_particle_water                    =0x8000 # the particles are water particles (no weight in the water (i.e. when z&lt;0)). Not compatible with sim_particle_ignoresgravity 
sim_particle_painttag                =0x10000 # The particles can be seen by vision sensors (sim_particle_invisible must not be set) 




# custom user interface menu attributes 
sim_ui_menu_title        =1
sim_ui_menu_minimize    =2
sim_ui_menu_close        =4
sim_ui_menu_systemblock =8



# Boolean parameters 
sim_boolparam_hierarchy_visible                 =0
sim_boolparam_console_visible                   =1
sim_boolparam_collision_handling_enabled        =2
sim_boolparam_distance_handling_enabled         =3
sim_boolparam_ik_handling_enabled               =4
sim_boolparam_gcs_handling_enabled              =5
sim_boolparam_dynamics_handling_enabled         =6
sim_boolparam_joint_motion_handling_enabled     =7
sim_boolparam_path_motion_handling_enabled      =8
sim_boolparam_proximity_sensor_handling_enabled =9
sim_boolparam_vision_sensor_handling_enabled    =10
sim_boolparam_mill_handling_enabled             =11
sim_boolparam_browser_visible                   =12
sim_boolparam_scene_and_model_load_messages     =13
sim_reserved0                                   =14
sim_boolparam_shape_textures_are_visible        =15
sim_boolparam_display_enabled                   =16
sim_boolparam_infotext_visible                  =17
sim_boolparam_statustext_open                   =18
sim_boolparam_fog_enabled                       =19
sim_boolparam_rml2_available                    =20
sim_boolparam_rml4_available                    =21
sim_boolparam_mirrors_enabled                    =22
sim_boolparam_aux_clip_planes_enabled            =23
sim_boolparam_full_model_copy_from_api            =24
sim_boolparam_realtime_simulation                =25
sim_boolparam_force_show_wireless_emission        =27
sim_boolparam_force_show_wireless_reception        =28
sim_boolparam_video_recording_triggered            =29
sim_boolparam_threaded_rendering_enabled        =32
sim_boolparam_fullscreen                        =33
sim_boolparam_headless                            =34
sim_boolparam_hierarchy_toolbarbutton_enabled    =35
sim_boolparam_browser_toolbarbutton_enabled        =36
sim_boolparam_objectshift_toolbarbutton_enabled    =37
sim_boolparam_objectrotate_toolbarbutton_enabled=38
sim_boolparam_force_calcstruct_all_visible        =39
sim_boolparam_force_calcstruct_all                =40
sim_boolparam_exit_request                        =41
sim_boolparam_play_toolbarbutton_enabled        =42
sim_boolparam_pause_toolbarbutton_enabled        =43
sim_boolparam_stop_toolbarbutton_enabled        =44
sim_boolparam_waiting_for_trigger                =45


# Integer parameters 
sim_intparam_error_report_mode      =0  # Check sim_api_errormessage_... constants above for valid values 
sim_intparam_program_version        =1  # e.g Version 2.1.4 --&gt; 20104. Can only be read 
sim_intparam_instance_count         =2  # do not use anymore (always returns 1 since CoppeliaSim 2.5.11) 
sim_intparam_custom_cmd_start_id    =3  # can only be read 
sim_intparam_compilation_version    =4  # 0=evaluation version 1=full version 2=player version. Can only be read 
sim_intparam_current_page           =5
sim_intparam_flymode_camera_handle  =6  # can only be read 
sim_intparam_dynamic_step_divider   =7  # can only be read 
sim_intparam_dynamic_engine         =8  # 0=Bullet 1=ODE. 2=Vortex.
sim_intparam_server_port_start      =9  # can only be read 
sim_intparam_server_port_range      =10 # can only be read 
sim_intparam_visible_layers         =11
sim_intparam_infotext_style         =12
sim_intparam_settings               =13
sim_intparam_edit_mode_type         =14 # can only be read 
sim_intparam_server_port_next       =15 # is initialized at sim_intparam_server_port_start 
sim_intparam_qt_version             =16 # version of the used Qt framework 
sim_intparam_event_flags_read       =17 # can only be read 
sim_intparam_event_flags_read_clear =18 # can only be read 
sim_intparam_platform               =19 # can only be read 
sim_intparam_scene_unique_id        =20 # can only be read 
sim_intparam_work_thread_count      =21
sim_intparam_mouse_x                =22
sim_intparam_mouse_y                =23
sim_intparam_core_count             =24
sim_intparam_work_thread_calc_time_ms =25
sim_intparam_idle_fps               =26
sim_intparam_prox_sensor_select_down =27
sim_intparam_prox_sensor_select_up  =28
sim_intparam_stop_request_counter   =29
sim_intparam_program_revision       =30
sim_intparam_mouse_buttons          =31
sim_intparam_dynamic_warning_disabled_mask =32
sim_intparam_simulation_warning_disabled_mask =33
sim_intparam_scene_index            =34
sim_intparam_motionplanning_seed    =35
sim_intparam_speedmodifier          =36

# Float parameters 
sim_floatparam_rand=0 # random value (0.0-1.0) 
sim_floatparam_simulation_time_step =1
sim_floatparam_stereo_distance        =2

# String parameters 
sim_stringparam_application_path=0 # path of CoppeliaSim's executable 
sim_stringparam_video_filename=1
sim_stringparam_app_arg1            =2
sim_stringparam_app_arg2            =3
sim_stringparam_app_arg3            =4
sim_stringparam_app_arg4            =5
sim_stringparam_app_arg5            =6
sim_stringparam_app_arg6            =7
sim_stringparam_app_arg7            =8
sim_stringparam_app_arg8            =9
sim_stringparam_app_arg9            =10
sim_stringparam_scene_path_and_name    =13

# Array parameters 
sim_arrayparam_gravity          =0
sim_arrayparam_fog              =1
sim_arrayparam_fog_color        =2
sim_arrayparam_background_color1=3
sim_arrayparam_background_color2=4
sim_arrayparam_ambient_light    =5
sim_arrayparam_random_euler        =6

sim_objintparam_visibility_layer= 10
sim_objfloatparam_abs_x_velocity= 11
sim_objfloatparam_abs_y_velocity= 12
sim_objfloatparam_abs_z_velocity= 13
sim_objfloatparam_abs_rot_velocity= 14
sim_objfloatparam_objbbox_min_x= 15
sim_objfloatparam_objbbox_min_y= 16
sim_objfloatparam_objbbox_min_z= 17
sim_objfloatparam_objbbox_max_x= 18
sim_objfloatparam_objbbox_max_y= 19
sim_objfloatparam_objbbox_max_z= 20
sim_objfloatparam_modelbbox_min_x= 21
sim_objfloatparam_modelbbox_min_y= 22
sim_objfloatparam_modelbbox_min_z= 23
sim_objfloatparam_modelbbox_max_x= 24
sim_objfloatparam_modelbbox_max_y= 25
sim_objfloatparam_modelbbox_max_z= 26
sim_objintparam_collection_self_collision_indicator= 27
sim_objfloatparam_transparency_offset= 28
sim_objintparam_child_role= 29
sim_objintparam_parent_role= 30
sim_objintparam_manipulation_permissions= 31
sim_objintparam_illumination_handle= 32

sim_visionfloatparam_near_clipping= 1000
sim_visionfloatparam_far_clipping= 1001
sim_visionintparam_resolution_x= 1002
sim_visionintparam_resolution_y= 1003
sim_visionfloatparam_perspective_angle= 1004
sim_visionfloatparam_ortho_size= 1005
sim_visionintparam_disabled_light_components= 1006
sim_visionintparam_rendering_attributes= 1007
sim_visionintparam_entity_to_render= 1008
sim_visionintparam_windowed_size_x= 1009
sim_visionintparam_windowed_size_y= 1010
sim_visionintparam_windowed_pos_x= 1011
sim_visionintparam_windowed_pos_y= 1012
sim_visionintparam_pov_focal_blur= 1013
sim_visionfloatparam_pov_blur_distance= 1014
sim_visionfloatparam_pov_aperture= 1015
sim_visionintparam_pov_blur_sampled= 1016
sim_visionintparam_render_mode= 1017

sim_jointintparam_motor_enabled= 2000
sim_jointintparam_ctrl_enabled= 2001
sim_jointfloatparam_pid_p= 2002
sim_jointfloatparam_pid_i= 2003
sim_jointfloatparam_pid_d= 2004
sim_jointfloatparam_intrinsic_x= 2005
sim_jointfloatparam_intrinsic_y= 2006
sim_jointfloatparam_intrinsic_z= 2007
sim_jointfloatparam_intrinsic_qx= 2008
sim_jointfloatparam_intrinsic_qy= 2009
sim_jointfloatparam_intrinsic_qz= 2010
sim_jointfloatparam_intrinsic_qw= 2011
sim_jointfloatparam_velocity= 2012
sim_jointfloatparam_spherical_qx= 2013
sim_jointfloatparam_spherical_qy= 2014
sim_jointfloatparam_spherical_qz= 2015
sim_jointfloatparam_spherical_qw= 2016
sim_jointfloatparam_upper_limit= 2017
sim_jointfloatparam_kc_k= 2018
sim_jointfloatparam_kc_c= 2019
sim_jointfloatparam_ik_weight= 2021
sim_jointfloatparam_error_x= 2022
sim_jointfloatparam_error_y= 2023
sim_jointfloatparam_error_z= 2024
sim_jointfloatparam_error_a= 2025
sim_jointfloatparam_error_b= 2026
sim_jointfloatparam_error_g= 2027
sim_jointfloatparam_error_pos= 2028
sim_jointfloatparam_error_angle= 2029
sim_jointintparam_velocity_lock= 2030
sim_jointintparam_vortex_dep_handle= 2031
sim_jointfloatparam_vortex_dep_multiplication= 2032
sim_jointfloatparam_vortex_dep_offset= 2033

sim_shapefloatparam_init_velocity_x= 3000
sim_shapefloatparam_init_velocity_y= 3001
sim_shapefloatparam_init_velocity_z= 3002
sim_shapeintparam_static= 3003
sim_shapeintparam_respondable= 3004
sim_shapefloatparam_mass= 3005
sim_shapefloatparam_texture_x= 3006
sim_shapefloatparam_texture_y= 3007
sim_shapefloatparam_texture_z= 3008
sim_shapefloatparam_texture_a= 3009
sim_shapefloatparam_texture_b= 3010
sim_shapefloatparam_texture_g= 3011
sim_shapefloatparam_texture_scaling_x= 3012
sim_shapefloatparam_texture_scaling_y= 3013
sim_shapeintparam_culling= 3014
sim_shapeintparam_wireframe= 3015
sim_shapeintparam_compound= 3016
sim_shapeintparam_convex= 3017
sim_shapeintparam_convex_check= 3018
sim_shapeintparam_respondable_mask= 3019
sim_shapefloatparam_init_velocity_a= 3020
sim_shapefloatparam_init_velocity_b= 3021
sim_shapefloatparam_init_velocity_g= 3022
sim_shapestringparam_color_name= 3023
sim_shapeintparam_edge_visibility= 3024
sim_shapefloatparam_shading_angle= 3025
sim_shapefloatparam_edge_angle= 3026
sim_shapeintparam_edge_borders_hidden= 3027

sim_proxintparam_ray_invisibility= 4000

sim_forcefloatparam_error_x= 5000
sim_forcefloatparam_error_y= 5001
sim_forcefloatparam_error_z= 5002
sim_forcefloatparam_error_a= 5003
sim_forcefloatparam_error_b= 5004
sim_forcefloatparam_error_g= 5005
sim_forcefloatparam_error_pos= 5006
sim_forcefloatparam_error_angle= 5007

sim_lightintparam_pov_casts_shadows= 8000

sim_cameraintparam_disabled_light_components= 9000
sim_camerafloatparam_perspective_angle= 9001
sim_camerafloatparam_ortho_size= 9002
sim_cameraintparam_rendering_attributes= 9003
sim_cameraintparam_pov_focal_blur= 9004
sim_camerafloatparam_pov_blur_distance= 9005
sim_camerafloatparam_pov_aperture= 9006
sim_cameraintparam_pov_blur_samples= 9007

sim_dummyintparam_link_type= 10000

sim_mirrorfloatparam_width= 12000
sim_mirrorfloatparam_height= 12001
sim_mirrorfloatparam_reflectance= 12002
sim_mirrorintparam_enable= 12003

sim_pplanfloatparam_x_min= 20000
sim_pplanfloatparam_x_range= 20001
sim_pplanfloatparam_y_min= 20002
sim_pplanfloatparam_y_range= 20003
sim_pplanfloatparam_z_min= 20004
sim_pplanfloatparam_z_range= 20005
sim_pplanfloatparam_delta_min= 20006
sim_pplanfloatparam_delta_range= 20007

sim_mplanintparam_nodes_computed= 25000
sim_mplanintparam_prepare_nodes= 25001
sim_mplanintparam_clear_nodes= 25002

# User interface elements 
sim_gui_menubar                        =0x0001
sim_gui_popups                        =0x0002
sim_gui_toolbar1                    =0x0004
sim_gui_toolbar2                    =0x0008
sim_gui_hierarchy                    =0x0010
sim_gui_infobar                        =0x0020
sim_gui_statusbar                    =0x0040
sim_gui_scripteditor                =0x0080
sim_gui_scriptsimulationparameters    =0x0100
sim_gui_dialogs                        =0x0200
sim_gui_browser                        =0x0400
sim_gui_all                            =0xffff


# Joint modes 
sim_jointmode_passive       =0
sim_jointmode_motion        =1
sim_jointmode_ik            =2
sim_jointmode_ikdependent   =3
sim_jointmode_dependent     =4
sim_jointmode_force         =5


# Navigation and selection modes with the mouse. Lower byte values are mutually exclusive upper byte bits can be combined 
sim_navigation_passive                    =0x0000
sim_navigation_camerashift                =0x0001
sim_navigation_camerarotate                =0x0002
sim_navigation_camerazoom                =0x0003
sim_navigation_cameratilt                =0x0004
sim_navigation_cameraangle                =0x0005
sim_navigation_camerafly                =0x0006
sim_navigation_objectshift                =0x0007
sim_navigation_objectrotate                =0x0008
sim_navigation_reserved2                =0x0009
sim_navigation_reserved3                =0x000A
sim_navigation_jointpathtest            =0x000B
sim_navigation_ikmanip                    =0x000C
sim_navigation_objectmultipleselection    =0x000D
# Bit-combine following values and add them to one of above's values for a valid navigation mode 
sim_navigation_reserved4                =0x0100
sim_navigation_clickselection            =0x0200
sim_navigation_ctrlselection            =0x0400
sim_navigation_shiftselection            =0x0800
sim_navigation_camerazoomwheel            =0x1000
sim_navigation_camerarotaterightbutton    =0x2000



#Remote API constants
SIMX_VERSION                    =0 
# Remote API message header structure 
SIMX_HEADER_SIZE                =18
simx_headeroffset_crc           =0    # 1 simxUShort. Generated by the client or server. The CRC for the message 
simx_headeroffset_version       =2    # 1 byte. Generated by the client or server. The version of the remote API software 
simx_headeroffset_message_id    =3    # 1 simxInt. Generated by the client (and used in a reply by the server) 
simx_headeroffset_client_time   =7    # 1 simxInt. Client time stamp generated by the client (and sent back by the server) 
simx_headeroffset_server_time   =11    # 1 simxInt. Generated by the server when a reply is generated. The server timestamp 
simx_headeroffset_scene_id      =15    # 1 simxUShort. Generated by the server. A unique ID identifying the scene currently displayed 
simx_headeroffset_server_state  =17    # 1 byte. Generated by the server. Bit coded 0 set --&gt; simulation not stopped 1 set --&gt; simulation paused 2 set --&gt; real-time switch on 3-5 edit mode type (0=no edit mode 1=triangle 2=vertex 3=edge 4=path 5=UI)  

# Remote API command header 
SIMX_SUBHEADER_SIZE                 =26
simx_cmdheaderoffset_mem_size       =0    # 1 simxInt. Generated by the client or server. The buffer size of the command. 
simx_cmdheaderoffset_full_mem_size  =4    # 1 simxInt. Generated by the client or server. The full buffer size of the command (applies to split chunks). 
simx_cmdheaderoffset_pdata_offset0  =8    # 1 simxUShort. Generated by the client or server. The amount of data that is part of the command identification. 
simx_cmdheaderoffset_pdata_offset1  =10    # 1 simxInt. Generated by the client or server. The amount of shift of the pure data buffer (applies to split chunks). 
simx_cmdheaderoffset_cmd=14    # 1 simxInt. Generated by the client (and used in a reply by the server). The command combined with the operation mode of the command. 
simx_cmdheaderoffset_delay_or_split =18    # 1 simxUShort. Generated by the client or server. The amount of delay in ms of a continuous command or the max. pure data size to send at once (applies to split commands). 
simx_cmdheaderoffset_sim_time       =20    # 1 simxInt. Generated by the server. The simulation time (in ms) when the command was executed (or 0 if simulation is not running) 
simx_cmdheaderoffset_status         =24    # 1 byte. Generated by the server. (1 bit 0 is set --&gt; error in function execution on server side). The client writes bit 1 if command cannot be overwritten
simx_cmdheaderoffset_reserved       =25    # 1 byte. Not yet used 





# Regular operation modes 
simx_opmode_oneshot                =0x000000 # sends command as one chunk. Reply will also come as one chunk. Doesn't wait for the reply. 
simx_opmode_blocking            =0x010000 # sends command as one chunk. Reply will also come as one chunk. Waits for the reply (_REPLY_WAIT_TIMEOUT_IN_MS is the timeout). 
simx_opmode_oneshot_wait        =0x010000 # sends command as one chunk. Reply will also come as one chunk. Waits for the reply (_REPLY_WAIT_TIMEOUT_IN_MS is the timeout). 
simx_opmode_continuous            =0x020000  
simx_opmode_streaming            =0x020000 # sends command as one chunk. Command will be stored on the server and always executed 
                                                      #(every x ms (as far as possible) where x can be 0-65535. just add x to opmode_continuous). 
                                                      # A reply will be sent continuously each time as one chunk. Doesn't wait for the reply. 

# Operation modes for heavy data 
simx_opmode_oneshot_split        =0x030000   # sends command as several chunks (max chunk size is x bytes where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to opmode_oneshot_split). Reply will also come as several chunks. Doesn't wait for the reply.      
simx_opmode_continuous_split    =0x040000
simx_opmode_streaming_split    =0x040000    # sends command as several chunks (max chunk size is x bytes where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to opmode_continuous_split). Command will be stored on the server and always executed. A reply will be sent continuously each time as several chunks. Doesn't wait for the reply. 

# Special operation modes 
simx_opmode_discontinue            =0x050000    # removes and cancels all commands stored on the client or server side (also continuous commands) 
simx_opmode_buffer                =0x060000    # doesn't send anything but checks if a reply for the given command is available in the input buffer (i.e. previously received from the server) 
simx_opmode_remove                =0x070000    # doesn't send anything and doesn't return any specific value. It just erases a similar command reply in the inbox (to free some memory) 


# Command return codes 
simx_return_ok                    =0x000000
simx_return_novalue_flag        =0x000001        # input buffer doesn't contain the specified command 
simx_return_timeout_flag        =0x000002        # command reply not received in time for opmode_oneshot_wait operation mode 
simx_return_illegal_opmode_flag    =0x000004        # command doesn't support the specified operation mode 
simx_return_remote_error_flag    =0x000008        # command caused an error on the server side 
simx_return_split_progress_flag    =0x000010        # previous similar command not yet fully processed (applies to opmode_oneshot_split operation modes) 
simx_return_local_error_flag    =0x000020        # command caused an error on the client side 
simx_return_initialize_error_flag    =0x000040        # simxStart was not yet called 

# Following for backward compatibility (same as above) 
simx_error_noerror                =0x000000
simx_error_novalue_flag            =0x000001        # input buffer doesn't contain the specified command 
simx_error_timeout_flag            =0x000002        # command reply not received in time for opmode_oneshot_wait operation mode 
simx_error_illegal_opmode_flag    =0x000004        # command doesn't support the specified operation mode 
simx_error_remote_error_flag    =0x000008        # command caused an error on the server side 
simx_error_split_progress_flag    =0x000010        # previous similar command not yet fully processed (applies to opmode_oneshot_split operation modes) 
simx_error_local_error_flag        =0x000020        # command caused an error on the client side 
simx_error_initialize_error_flag        =0x000040        # simxStart was not yet called 




#load library
libsimx = None
try:
    file_extension = '.so'
    if platform.system() =='cli':
        file_extension = '.dll'
    elif platform.system() =='Windows':
        file_extension = '.dll'
    elif platform.system() == 'Darwin':
        file_extension = '.dylib'
    else:
        file_extension = '.so'
    libfullpath = os.path.join(os.path.dirname(__file__), 'remoteApi' + file_extension)
    libsimx = ct.CDLL(libfullpath)
except:
    print ('----------------------------------------------------')
    print ('The remoteApi library could not be loaded. Make sure')
    print ('it is located in the same folder as "sim.py", or')
    print ('appropriately adjust the file "sim.py"')
    print ('----------------------------------------------------')
    print ('')

#ctypes wrapper prototypes
c_GetJointPosition          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointPosition", libsimx))
c_SetJointPosition          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointPosition", libsimx))
c_GetJointMatrix            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointMatrix", libsimx))
c_SetSphericalJointMatrix   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetSphericalJointMatrix", libsimx))
c_SetJointTargetVelocity    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointTargetVelocity", libsimx))
c_SetJointTargetPosition    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointTargetPosition", libsimx))
c_GetJointForce             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointForce", libsimx))
c_GetJointMaxForce          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointMaxForce", libsimx))
c_SetJointForce             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointMaxForce", libsimx))
c_SetJointMaxForce          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointMaxForce", libsimx))
c_ReadForceSensor           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.c_int32)(("simxReadForceSensor", libsimx))
c_BreakForceSensor          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxBreakForceSensor", libsimx))
c_ReadVisionSensor          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.POINTER(ct.c_float)), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxReadVisionSensor", libsimx))
c_GetObjectHandle           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectHandle", libsimx))
c_GetVisionSensorImage      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_byte)), ct.c_ubyte, ct.c_int32)(("simxGetVisionSensorImage", libsimx))
c_SetVisionSensorImage      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_byte), ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetVisionSensorImage", libsimx))
c_GetVisionSensorDepthBuffer= ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)), ct.c_int32)(("simxGetVisionSensorDepthBuffer", libsimx))
c_GetObjectChild            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectChild", libsimx))
c_GetObjectParent           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectParent", libsimx))
c_ReadProximitySensor       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_float), ct.c_int32)(("simxReadProximitySensor", libsimx))
c_LoadModel                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.POINTER(ct.c_int32), ct.c_int32)(("simxLoadModel", libsimx))
c_LoadUI                    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxLoadUI", libsimx))
c_LoadScene                 =  ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.c_int32)(("simxLoadScene", libsimx))
c_StartSimulation           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxStartSimulation", libsimx))
c_PauseSimulation           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxPauseSimulation", libsimx))
c_StopSimulation            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxStopSimulation", libsimx))
c_GetUIHandle               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIHandle", libsimx))
c_GetUISlider               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUISlider", libsimx))
c_SetUISlider               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetUISlider", libsimx))
c_GetUIEventButton          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIEventButton", libsimx))
c_GetUIButtonProperty       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIButtonProperty", libsimx))
c_SetUIButtonProperty       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetUIButtonProperty", libsimx))
c_AddStatusbarMessage       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxAddStatusbarMessage", libsimx))
c_AuxiliaryConsoleOpen      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.c_int32)(("simxAuxiliaryConsoleOpen", libsimx))
c_AuxiliaryConsoleClose     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxAuxiliaryConsoleClose", libsimx))
c_AuxiliaryConsolePrint     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxAuxiliaryConsolePrint", libsimx))
c_AuxiliaryConsoleShow      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxAuxiliaryConsoleShow", libsimx))
c_GetObjectOrientation      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectOrientation", libsimx))
c_GetObjectQuaternion       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectQuaternion", libsimx))
c_GetObjectPosition         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectPosition", libsimx))
c_SetObjectOrientation      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectOrientation", libsimx))
c_SetObjectQuaternion       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectQuaternion", libsimx))
c_SetObjectPosition         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectPosition", libsimx))
c_SetObjectParent           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetObjectParent", libsimx))
c_SetUIButtonLabel          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32)(("simxSetUIButtonLabel", libsimx))
c_GetLastErrors             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetLastErrors", libsimx))
c_GetArrayParameter         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetArrayParameter", libsimx))
c_SetArrayParameter         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetArrayParameter", libsimx))
c_GetBooleanParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxGetBooleanParameter", libsimx))
c_SetBooleanParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetBooleanParameter", libsimx))
c_GetIntegerParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetIntegerParameter", libsimx))
c_SetIntegerParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetIntegerParameter", libsimx))
c_GetFloatingParameter      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetFloatingParameter", libsimx))
c_SetFloatingParameter      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetFloatingParameter", libsimx))
c_GetStringParameter        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetStringParameter", libsimx))
c_GetCollisionHandle        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetCollisionHandle", libsimx))
c_GetDistanceHandle         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetDistanceHandle", libsimx))
c_GetCollectionHandle       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetCollectionHandle", libsimx))
c_ReadCollision             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxReadCollision", libsimx))
c_ReadDistance              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxReadDistance", libsimx))
c_RemoveObject              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveObject", libsimx))
c_RemoveModel               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveModel", libsimx))
c_RemoveUI                  = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveUI", libsimx))
c_CloseScene                = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxCloseScene", libsimx))
c_GetObjects                = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxGetObjects", libsimx))
c_DisplayDialog             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.c_int32)(("simxDisplayDialog", libsimx))
c_EndDialog                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxEndDialog", libsimx))
c_GetDialogInput            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetDialogInput", libsimx))
c_GetDialogResult           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetDialogResult", libsimx))
c_CopyPasteObjects          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32, ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxCopyPasteObjects", libsimx))
c_GetObjectSelection        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectSelection", libsimx))
c_SetObjectSelection        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32, ct.c_int32)(("simxSetObjectSelection", libsimx))
c_ClearFloatSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearFloatSignal", libsimx))
c_ClearIntegerSignal        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearIntegerSignal", libsimx))
c_ClearStringSignal         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearStringSignal", libsimx))
c_GetFloatSignal            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_float), ct.c_int32)(("simxGetFloatSignal", libsimx))
c_GetIntegerSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetIntegerSignal", libsimx))
c_GetStringSignal           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetStringSignal", libsimx))
c_SetFloatSignal            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_float, ct.c_int32)(("simxSetFloatSignal", libsimx))
c_SetIntegerSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32)(("simxSetIntegerSignal", libsimx))
c_SetStringSignal           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxSetStringSignal", libsimx))
c_AppendStringSignal        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxAppendStringSignal", libsimx))
c_WriteStringStream         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxWriteStringStream", libsimx))
c_GetObjectFloatParameter   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectFloatParameter", libsimx))
c_SetObjectFloatParameter   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetObjectFloatParameter", libsimx))
c_GetObjectIntParameter     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectIntParameter", libsimx))
c_SetObjectIntParameter     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetObjectIntParameter", libsimx))
c_GetModelProperty          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetModelProperty", libsimx))
c_SetModelProperty          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetModelProperty", libsimx))
c_Start                     = ct.CFUNCTYPE(ct.c_int32,ct.POINTER(ct.c_char), ct.c_int32, ct.c_ubyte, ct.c_ubyte, ct.c_int32, ct.c_int32)(("simxStart", libsimx))
c_Finish                    = ct.CFUNCTYPE(None, ct.c_int32)(("simxFinish", libsimx))
c_GetPingTime               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetPingTime", libsimx))
c_GetLastCmdTime            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxGetLastCmdTime", libsimx))
c_SynchronousTrigger        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxSynchronousTrigger", libsimx))
c_Synchronous               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_ubyte)(("simxSynchronous", libsimx))
c_PauseCommunication        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_ubyte)(("simxPauseCommunication", libsimx))
c_GetInMessageInfo          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetInMessageInfo", libsimx))
c_GetOutMessageInfo         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetOutMessageInfo", libsimx))
c_GetConnectionId           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxGetConnectionId", libsimx))
c_CreateBuffer              = ct.CFUNCTYPE(ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxCreateBuffer", libsimx))
c_ReleaseBuffer             = ct.CFUNCTYPE(None, ct.c_void_p)(("simxReleaseBuffer", libsimx))
c_TransferFile              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32)(("simxTransferFile", libsimx))
c_EraseFile                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxEraseFile", libsimx))
c_GetAndClearStringSignal   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetAndClearStringSignal", libsimx))
c_ReadStringStream          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxReadStringStream", libsimx))
c_CreateDummy               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_float, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_int32), ct.c_int32)(("simxCreateDummy", libsimx))
c_Query                     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxQuery", libsimx))
c_GetObjectGroupData        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetObjectGroupData", libsimx))
c_GetObjectVelocity         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectVelocity", libsimx))
c_CallScriptFunction        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_int32),ct.c_int32,ct.POINTER(ct.c_float),ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_ubyte),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_ubyte)),ct.c_int32)(("simxCallScriptFunction", libsimx))

#API functions
</t>
<t tx="leo.20210713140956.176">def simxGetJointPosition(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    position = ct.c_float()
    return c_GetJointPosition(clientID, jointHandle, ct.byref(position), operationMode), position.value

</t>
<t tx="leo.20210713140956.177">def simxSetJointPosition(clientID, jointHandle, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointPosition(clientID, jointHandle, position, operationMode)

</t>
<t tx="leo.20210713140956.178">def simxGetJointMatrix(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    matrix = (ct.c_float*12)()
    ret = c_GetJointMatrix(clientID, jointHandle, matrix, operationMode)
    arr = []
    for i in range(12):
        arr.append(matrix[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.179">def simxSetSphericalJointMatrix(clientID, jointHandle, matrix, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    matrix = (ct.c_float*12)(*matrix)
    return c_SetSphericalJointMatrix(clientID, jointHandle, matrix, operationMode)

</t>
<t tx="leo.20210713140956.18">def close(self):
    if self.viewer: self.viewer.close()
    vrep_env.VrepEnv.close(self)

</t>
<t tx="leo.20210713140956.180">def simxSetJointTargetVelocity(clientID, jointHandle, targetVelocity, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointTargetVelocity(clientID, jointHandle, targetVelocity, operationMode)

</t>
<t tx="leo.20210713140956.181">def simxSetJointTargetPosition(clientID, jointHandle, targetPosition, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointTargetPosition(clientID, jointHandle, targetPosition, operationMode)

</t>
<t tx="leo.20210713140956.182">def simxJointGetForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140956.183">def simxGetJointForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140956.184">def simxGetJointMaxForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointMaxForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140956.185">def simxSetJointForce(clientID, jointHandle, force, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_SetJointMaxForce(clientID, jointHandle, force, operationMode)

</t>
<t tx="leo.20210713140956.186">def simxSetJointMaxForce(clientID, jointHandle, force, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_SetJointMaxForce(clientID, jointHandle, force, operationMode)

</t>
<t tx="leo.20210713140956.187">def simxReadForceSensor(clientID, forceSensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    state = ct.c_ubyte()
    forceVector  = (ct.c_float*3)()
    torqueVector = (ct.c_float*3)()
    ret = c_ReadForceSensor(clientID, forceSensorHandle, ct.byref(state), forceVector, torqueVector, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(forceVector[i])
    arr2 = []
    for i in range(3):
        arr2.append(torqueVector[i])
    #if sys.version_info[0] == 3:
    #    state=state.value
    #else:
    #    state=ord(state.value)
    return ret, state.value, arr1, arr2

</t>
<t tx="leo.20210713140956.188">def simxBreakForceSensor(clientID, forceSensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_BreakForceSensor(clientID, forceSensorHandle, operationMode)

</t>
<t tx="leo.20210713140956.189">def simxReadVisionSensor(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    detectionState = ct.c_ubyte()
    auxValues      = ct.POINTER(ct.c_float)()
    auxValuesCount = ct.POINTER(ct.c_int)()
    ret = c_ReadVisionSensor(clientID, sensorHandle, ct.byref(detectionState), ct.byref(auxValues), ct.byref(auxValuesCount), operationMode)

    auxValues2 = []
    if ret == 0:
        s = 0
        for i in range(auxValuesCount[0]):
            auxValues2.append(auxValues[s:s+auxValuesCount[i+1]])
            s += auxValuesCount[i+1]

        #free C buffers
        c_ReleaseBuffer(auxValues)
        c_ReleaseBuffer(auxValuesCount)

    return ret, bool(detectionState.value!=0), auxValues2

</t>
<t tx="leo.20210713140956.19">def main(args):
    env = CartPoleContinuousVrepEnv()
    for i_episode in range(8):
        observation = env.reset()
        total_reward = 0
        for t in range(200):
            action = env.action_space.sample()
            observation, reward, done, _ = env.step(action)
            total_reward += reward
            if done:
                break
        print("Episode finished after {} timesteps.\tTotal reward: {}".format(t+1,total_reward))
    env.close()
    return 0

</t>
<t tx="leo.20210713140956.190">def simxGetObjectHandle(clientID, objectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(objectName) is str):
        objectName=objectName.encode('utf-8')
    return c_GetObjectHandle(clientID, objectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.191">def simxGetVisionSensorImage(clientID, sensorHandle, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    resolution = (ct.c_int*2)()
    c_image  = ct.POINTER(ct.c_byte)()
    bytesPerPixel = 3
    if (options and 1) != 0:
        bytesPerPixel = 1
    ret = c_GetVisionSensorImage(clientID, sensorHandle, resolution, ct.byref(c_image), options, operationMode)

    reso = []
    image = []
    if (ret == 0):
        image = [None]*resolution[0]*resolution[1]*bytesPerPixel
        for i in range(resolution[0] * resolution[1] * bytesPerPixel):
            image[i] = c_image[i]
        for i in range(2):
            reso.append(resolution[i])
    return ret, reso, image

</t>
<t tx="leo.20210713140956.192">def simxSetVisionSensorImage(clientID, sensorHandle, image, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    size = len(image)
    image_bytes  = (ct.c_byte*size)(*image)
    return c_SetVisionSensorImage(clientID, sensorHandle, image_bytes, size, options, operationMode)

</t>
<t tx="leo.20210713140956.193">def simxGetVisionSensorDepthBuffer(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    c_buffer  = ct.POINTER(ct.c_float)()
    resolution = (ct.c_int*2)()
    ret = c_GetVisionSensorDepthBuffer(clientID, sensorHandle, resolution, ct.byref(c_buffer), operationMode)
    reso = []
    buffer = []
    if (ret == 0):
        buffer = [None]*resolution[0]*resolution[1]
        for i in range(resolution[0] * resolution[1]):
            buffer[i] = c_buffer[i]
        for i in range(2):
            reso.append(resolution[i])
    return ret, reso, buffer

</t>
<t tx="leo.20210713140956.194">def simxGetObjectChild(clientID, parentObjectHandle, childIndex, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    childObjectHandle = ct.c_int()
    return c_GetObjectChild(clientID, parentObjectHandle, childIndex, ct.byref(childObjectHandle), operationMode), childObjectHandle.value

</t>
<t tx="leo.20210713140956.195">def simxGetObjectParent(clientID, childObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parentObjectHandle = ct.c_int()
    return c_GetObjectParent(clientID, childObjectHandle, ct.byref(parentObjectHandle), operationMode), parentObjectHandle.value

</t>
<t tx="leo.20210713140956.196">def simxReadProximitySensor(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    detectionState = ct.c_ubyte()
    detectedObjectHandle = ct.c_int()
    detectedPoint  = (ct.c_float*3)()
    detectedSurfaceNormalVector = (ct.c_float*3)()
    ret = c_ReadProximitySensor(clientID, sensorHandle, ct.byref(detectionState), detectedPoint, ct.byref(detectedObjectHandle), detectedSurfaceNormalVector, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(detectedPoint[i])
    arr2 = []
    for i in range(3):
        arr2.append(detectedSurfaceNormalVector[i])
    return ret, bool(detectionState.value!=0), arr1, detectedObjectHandle.value, arr2

</t>
<t tx="leo.20210713140956.197">def simxLoadModel(clientID, modelPathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    baseHandle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(modelPathAndName) is str):
        modelPathAndName=modelPathAndName.encode('utf-8')
    return c_LoadModel(clientID, modelPathAndName, options, ct.byref(baseHandle), operationMode), baseHandle.value

</t>
<t tx="leo.20210713140956.198">def simxLoadUI(clientID, uiPathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    count = ct.c_int()
    uiHandles = ct.POINTER(ct.c_int)()
    if (sys.version_info[0] == 3) and (type(uiPathAndName) is str):
        uiPathAndName=uiPathAndName.encode('utf-8')
    ret = c_LoadUI(clientID, uiPathAndName, options, ct.byref(count), ct.byref(uiHandles), operationMode)

    handles = []
    if ret == 0:
        for i in range(count.value):
            handles.append(uiHandles[i])
        #free C buffers
        c_ReleaseBuffer(uiHandles)

    return ret, handles

</t>
<t tx="leo.20210713140956.199">def simxLoadScene(clientID, scenePathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(scenePathAndName) is str):
        scenePathAndName=scenePathAndName.encode('utf-8')
    return c_LoadScene(clientID, scenePathAndName, options, operationMode)

</t>
<t tx="leo.20210713140956.2"></t>
<t tx="leo.20210713140956.20">@others
if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))
@language python
@tabwidth -4

</t>
<t tx="leo.20210713140956.200">def simxStartSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_StartSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140956.201">def simxPauseSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_PauseSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140956.202">def simxStopSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_StopSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140956.203">def simxGetUIHandle(clientID, uiName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(uiName) is str):
        uiName=uiName.encode('utf-8')
    return c_GetUIHandle(clientID, uiName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.204">def simxGetUISlider(clientID, uiHandle, uiButtonID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    position = ct.c_int()
    return c_GetUISlider(clientID, uiHandle, uiButtonID, ct.byref(position), operationMode), position.value

</t>
<t tx="leo.20210713140956.205">def simxSetUISlider(clientID, uiHandle, uiButtonID, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetUISlider(clientID, uiHandle, uiButtonID, position, operationMode)

</t>
<t tx="leo.20210713140956.206">def simxGetUIEventButton(clientID, uiHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    uiEventButtonID = ct.c_int()
    auxValues = (ct.c_int*2)()
    ret = c_GetUIEventButton(clientID, uiHandle, ct.byref(uiEventButtonID), auxValues, operationMode)
    arr = []
    for i in range(2):
        arr.append(auxValues[i])
    return ret, uiEventButtonID.value, arr

</t>
<t tx="leo.20210713140956.207">def simxGetUIButtonProperty(clientID, uiHandle, uiButtonID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    prop = ct.c_int()
    return c_GetUIButtonProperty(clientID, uiHandle, uiButtonID, ct.byref(prop), operationMode), prop.value

</t>
<t tx="leo.20210713140956.208">def simxSetUIButtonProperty(clientID, uiHandle, uiButtonID, prop, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetUIButtonProperty(clientID, uiHandle, uiButtonID, prop, operationMode)

</t>
<t tx="leo.20210713140956.209">def simxAddStatusbarMessage(clientID, message, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(message) is str):
        message=message.encode('utf-8')
    return c_AddStatusbarMessage(clientID, message, operationMode)

</t>
<t tx="leo.20210713140956.21">"""
Adaptation from:
https://github.com/openai/gym/blob/master/gym/envs/classic_control/cartpole.py
Which is based in:
Classic cart-pole system implemented by Rich Sutton et al.
Copied from http://incompleteideas.net/sutton/book/code/pole.c
permalink: https://perma.cc/C9ZM-652R
"""

from vrep_env import vrep_env
from vrep_env import vrep

import os
#vrep_scenes_path = os.environ['VREP_SCENES_PATH']
vrep_scenes_path = "C:/tmp/vrep-env/examples/scenes"

import math
import gym
from gym import spaces
from gym.utils import seeding
import numpy as np

</t>
<t tx="leo.20210713140956.210">def simxAuxiliaryConsoleOpen(clientID, title, maxLines, mode, position, size, textColor, backgroundColor, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    consoleHandle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(title) is str):
        title=title.encode('utf-8')
    if position != None:
        c_position = (ct.c_int*2)(*position)
    else:
        c_position = None
    if size != None:
        c_size = (ct.c_int*2)(*size)
    else:
        c_size = None
    if textColor != None:
        c_textColor = (ct.c_float*3)(*textColor)
    else:
        c_textColor = None
    if backgroundColor != None:
        c_backgroundColor = (ct.c_float*3)(*backgroundColor)
    else:
        c_backgroundColor = None
    return c_AuxiliaryConsoleOpen(clientID, title, maxLines, mode, c_position, c_size, c_textColor, c_backgroundColor, ct.byref(consoleHandle), operationMode), consoleHandle.value

</t>
<t tx="leo.20210713140956.211">def simxAuxiliaryConsoleClose(clientID, consoleHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_AuxiliaryConsoleClose(clientID, consoleHandle, operationMode)

</t>
<t tx="leo.20210713140956.212">def simxAuxiliaryConsolePrint(clientID, consoleHandle, txt, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(txt) is str):
        txt=txt.encode('utf-8')
    return c_AuxiliaryConsolePrint(clientID, consoleHandle, txt, operationMode)

</t>
<t tx="leo.20210713140956.213">def simxAuxiliaryConsoleShow(clientID, consoleHandle, showState, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_AuxiliaryConsoleShow(clientID, consoleHandle, showState, operationMode)

</t>
<t tx="leo.20210713140956.214">def simxGetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    eulerAngles = (ct.c_float*3)()
    ret = c_GetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, eulerAngles, operationMode)
    arr = []
    for i in range(3):
        arr.append(eulerAngles[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.215">def simxGetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    quaternion = (ct.c_float*4)()
    ret = c_GetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quaternion, operationMode)
    arr = []
    for i in range(4):
        arr.append(quaternion[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.216">def simxGetObjectPosition(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    position = (ct.c_float*3)()
    ret = c_GetObjectPosition(clientID, objectHandle, relativeToObjectHandle, position, operationMode)
    arr = []
    for i in range(3):
        arr.append(position[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.217">def simxSetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, eulerAngles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    angles = (ct.c_float*3)(*eulerAngles)
    return c_SetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, angles, operationMode)

</t>
<t tx="leo.20210713140956.218">def simxSetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quaternion, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    quat = (ct.c_float*4)(*quaternion)
    return c_SetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quat, operationMode)

</t>
<t tx="leo.20210713140956.219">def simxSetObjectPosition(clientID, objectHandle, relativeToObjectHandle, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_position = (ct.c_float*3)(*position)
    return c_SetObjectPosition(clientID, objectHandle, relativeToObjectHandle, c_position, operationMode)

</t>
<t tx="leo.20210713140956.22">class CartPoleVrepEnv(vrep_env.VrepEnv):
    metadata = {
        'render.modes': ['human', 'rgb_array'],
        'video.frames_per_second' : 50
    }
    @others
</t>
<t tx="leo.20210713140956.220">def simxSetObjectParent(clientID, objectHandle, parentObject, keepInPlace, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectParent(clientID, objectHandle, parentObject, keepInPlace, operationMode)

</t>
<t tx="leo.20210713140956.221">def simxSetUIButtonLabel(clientID, uiHandle, uiButtonID, upStateLabel, downStateLabel, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        if type(upStateLabel) is str:
            upStateLabel=upStateLabel.encode('utf-8')
        if type(downStateLabel) is str:
            downStateLabel=downStateLabel.encode('utf-8')
    return c_SetUIButtonLabel(clientID, uiHandle, uiButtonID, upStateLabel, downStateLabel, operationMode)

</t>
<t tx="leo.20210713140956.222">def simxGetLastErrors(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    errors =[]
    errorCnt = ct.c_int()
    errorStrings = ct.POINTER(ct.c_char)()
    ret = c_GetLastErrors(clientID, ct.byref(errorCnt), ct.byref(errorStrings), operationMode)
    if ret == 0:
        s = 0
        for i in range(errorCnt.value):
            a = bytearray()
            while errorStrings[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(errorStrings[s],'big'))
                else:
                    a.append(errorStrings[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                errors.append(str(a,'utf-8'))
            else:
                errors.append(str(a))

    return ret, errors

</t>
<t tx="leo.20210713140956.223">def simxGetArrayParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    paramValues = (ct.c_float*3)()
    ret = c_GetArrayParameter(clientID, paramIdentifier, paramValues, operationMode)
    arr = []
    for i in range(3):
        arr.append(paramValues[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.224">def simxSetArrayParameter(clientID, paramIdentifier, paramValues, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_paramValues = (ct.c_float*3)(*paramValues)
    return c_SetArrayParameter(clientID, paramIdentifier, c_paramValues, operationMode)

</t>
<t tx="leo.20210713140956.225">def simxGetBooleanParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_ubyte()
    return c_GetBooleanParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), bool(paramValue.value!=0)

</t>
<t tx="leo.20210713140956.226">def simxSetBooleanParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetBooleanParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140956.227">def simxGetIntegerParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_int()
    return c_GetIntegerParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), paramValue.value

</t>
<t tx="leo.20210713140956.228">def simxSetIntegerParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetIntegerParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140956.229">def simxGetFloatingParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_float()
    return c_GetFloatingParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), paramValue.value

</t>
<t tx="leo.20210713140956.23">def __init__(
    self,
    server_addr='127.0.0.1',
    server_port=19997,
    scene_path=vrep_scenes_path+'/gym_cartpole.ttt',
):
    vrep_env.VrepEnv.__init__(
        self,
        server_addr,
        server_port,
        scene_path,
    )
    
    # getting object handles
    self.action   = self.get_object_handle('action')
    self.cart     = self.get_object_handle('cart')
    self.pole     = self.get_object_handle('pole')
    self.viewer   = self.get_object_handle('viewer')
    
    # adjusting parameters
    self.tau = 0.02  # seconds between state updates
    self.gravity = 9.8
    self.force_mag = 10.0
    
    self.set_float_parameter(vrep.sim_floatparam_simulation_time_step, self.tau)
    self.set_array_parameter(vrep.sim_arrayparam_gravity,[0,0,-self.gravity])
    self.obj_set_force(self.action,self.force_mag)
    
    # Angle at which to fail the episode
    self.theta_threshold_radians = 12 * 2 * math.pi / 360
    self.x_threshold = 2.4
    # Angle limit set to 2 * theta_threshold_radians so failing observation is still within bounds
    high = np.array([
        self.x_threshold * 2,             np.finfo(np.float32).max,
        self.theta_threshold_radians * 2, np.finfo(np.float32).max])
    
    self.action_space = spaces.Discrete(2)
    self.observation_space = spaces.Box(-high, high)
    
    self.seed()
    self.viewer = None
    self.state = None
    self.steps_beyond_done = None

</t>
<t tx="leo.20210713140956.230">def simxSetFloatingParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetFloatingParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140956.231">def simxGetStringParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    paramValue = ct.POINTER(ct.c_char)()
    ret = c_GetStringParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode)

    a = bytearray()
    if ret == 0:
        i = 0
        while paramValue[i] != b'\0':
            if sys.version_info[0] == 3:
                a.append(int.from_bytes(paramValue[i],'big'))
            else:
                a.append(paramValue[i])
            i=i+1
    if sys.version_info[0] == 3:
        a=str(a,'utf-8')
    else:
        a=str(a)
    return ret, a

</t>
<t tx="leo.20210713140956.232">def simxGetCollisionHandle(clientID, collisionObjectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(collisionObjectName) is str):
        collisionObjectName=collisionObjectName.encode('utf-8')
    return c_GetCollisionHandle(clientID, collisionObjectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.233">def simxGetCollectionHandle(clientID, collectionName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(collectionName) is str):
        collectionName=collectionName.encode('utf-8')
    return c_GetCollectionHandle(clientID, collectionName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.234">def simxGetDistanceHandle(clientID, distanceObjectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(distanceObjectName) is str):
        distanceObjectName=distanceObjectName.encode('utf-8')
    return c_GetDistanceHandle(clientID, distanceObjectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.235">def simxReadCollision(clientID, collisionObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    collisionState = ct.c_ubyte()
    return c_ReadCollision(clientID, collisionObjectHandle, ct.byref(collisionState), operationMode), bool(collisionState.value!=0)

</t>
<t tx="leo.20210713140956.236">def simxReadDistance(clientID, distanceObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    minimumDistance = ct.c_float()
    return c_ReadDistance(clientID, distanceObjectHandle, ct.byref(minimumDistance), operationMode), minimumDistance.value

</t>
<t tx="leo.20210713140956.237">def simxRemoveObject(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveObject(clientID, objectHandle, operationMode)

</t>
<t tx="leo.20210713140956.238">def simxRemoveModel(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveModel(clientID, objectHandle, operationMode)

</t>
<t tx="leo.20210713140956.239">def simxRemoveUI(clientID, uiHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveUI(clientID, uiHandle, operationMode)

</t>
<t tx="leo.20210713140956.24">def seed(self, seed=None):
    self.np_random, seed = seeding.np_random(seed)
    return [seed]

</t>
<t tx="leo.20210713140956.240">def simxCloseScene(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_CloseScene(clientID, operationMode)

</t>
<t tx="leo.20210713140956.241">def simxGetObjects(clientID, objectType, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    objectCount = ct.c_int()
    objectHandles = ct.POINTER(ct.c_int)()

    ret = c_GetObjects(clientID, objectType, ct.byref(objectCount), ct.byref(objectHandles), operationMode)
    handles = []
    if ret == 0:
        for i in range(objectCount.value):
            handles.append(objectHandles[i])

    return ret, handles


</t>
<t tx="leo.20210713140956.242">def simxDisplayDialog(clientID, titleText, mainText, dialogType, initialText, titleColors, dialogColors, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    if titleColors != None:
        c_titleColors  = (ct.c_float*6)(*titleColors)
    else:
        c_titleColors  = None
    if dialogColors != None:
        c_dialogColors  = (ct.c_float*6)(*dialogColors)
    else:
        c_dialogColors  = None

    c_dialogHandle = ct.c_int()
    c_uiHandle = ct.c_int()
    if sys.version_info[0] == 3:
        if type(titleText) is str:
            titleText=titleText.encode('utf-8')
        if type(mainText) is str:
            mainText=mainText.encode('utf-8')
        if type(initialText) is str:
            initialText=initialText.encode('utf-8')
    return c_DisplayDialog(clientID, titleText, mainText, dialogType, initialText, c_titleColors, c_dialogColors, ct.byref(c_dialogHandle), ct.byref(c_uiHandle), operationMode), c_dialogHandle.value, c_uiHandle.value

</t>
<t tx="leo.20210713140956.243">def simxEndDialog(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_EndDialog(clientID, dialogHandle, operationMode)

</t>
<t tx="leo.20210713140956.244">def simxGetDialogInput(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    inputText = ct.POINTER(ct.c_char)()
    ret = c_GetDialogInput(clientID, dialogHandle, ct.byref(inputText), operationMode)

    a = bytearray()
    if ret == 0:
        i = 0
        while inputText[i] != b'\0':
            if sys.version_info[0] == 3:
                a.append(int.from_bytes(inputText[i],'big'))
            else:
                a.append(inputText[i])
            i = i+1

    if sys.version_info[0] == 3:
        a=str(a,'utf-8')
    else:
        a=str(a)
    return ret, a


</t>
<t tx="leo.20210713140956.245">def simxGetDialogResult(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    result = ct.c_int()
    return c_GetDialogResult(clientID, dialogHandle, ct.byref(result), operationMode), result.value

</t>
<t tx="leo.20210713140956.246">def simxCopyPasteObjects(clientID, objectHandles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    c_objectHandles  = (ct.c_int*len(objectHandles))(*objectHandles)
    c_objectHandles = ct.cast(c_objectHandles,ct.POINTER(ct.c_int)) # IronPython needs this
    newObjectCount   = ct.c_int()
    newObjectHandles = ct.POINTER(ct.c_int)()
    ret = c_CopyPasteObjects(clientID, c_objectHandles, len(objectHandles), ct.byref(newObjectHandles), ct.byref(newObjectCount), operationMode)

    newobj = []
    if ret == 0:
        for i in range(newObjectCount.value):
            newobj.append(newObjectHandles[i])

    return ret, newobj


</t>
<t tx="leo.20210713140956.247">def simxGetObjectSelection(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    objectCount   = ct.c_int()
    objectHandles = ct.POINTER(ct.c_int)()
    ret = c_GetObjectSelection(clientID, ct.byref(objectHandles), ct.byref(objectCount), operationMode)

    newobj = []
    if ret == 0:
        for i in range(objectCount.value):
            newobj.append(objectHandles[i])

    return ret, newobj



</t>
<t tx="leo.20210713140956.248">def simxSetObjectSelection(clientID, objectHandles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_objectHandles  = (ct.c_int*len(objectHandles))(*objectHandles)
    return c_SetObjectSelection(clientID, c_objectHandles, len(objectHandles), operationMode)

</t>
<t tx="leo.20210713140956.249">def simxClearFloatSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearFloatSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140956.25">def _make_observation(self):
    # discard y and z values
    [  x   ,_,_ ]         = self.obj_get_position(self.cart)
    [x_dot ,_,_ ] , _     = self.obj_get_velocity(self.cart)
    
    [_, theta ,_]         = self.obj_get_orientation(self.pole)
    _ , [_, theta_dot ,_] = self.obj_get_velocity(self.pole)
    
    self.state = (x,x_dot,theta,theta_dot)

</t>
<t tx="leo.20210713140956.250">def simxClearIntegerSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearIntegerSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140956.251">def simxClearStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearStringSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140956.252">def simxGetFloatSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalValue = ct.c_float()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_GetFloatSignal(clientID, signalName, ct.byref(signalValue), operationMode), signalValue.value

</t>
<t tx="leo.20210713140956.253">def simxGetIntegerSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalValue = ct.c_int()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_GetIntegerSignal(clientID, signalName, ct.byref(signalValue), operationMode), signalValue.value

</t>
<t tx="leo.20210713140956.254">def simxGetStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_GetStringSignal(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.255">def simxGetAndClearStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_GetAndClearStringSignal(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.256">def simxReadStringStream(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_ReadStringStream(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.257">def simxSetFloatSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_SetFloatSignal(clientID, signalName, signalValue, operationMode)

</t>
<t tx="leo.20210713140956.258">def simxSetIntegerSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_SetIntegerSignal(clientID, signalName, signalValue, operationMode)

</t>
<t tx="leo.20210713140956.259">def simxSetStringSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_SetStringSignal(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140956.26">def _make_action(self, a):
    v = 1 if a==1 else -1
    # 2000 is an arbitrary high value
    # more info at: forum.coppeliarobotics.com/viewtopic.php?t=497
    self.obj_set_velocity(self.action,v*2000.0)

</t>
<t tx="leo.20210713140956.260">def simxAppendStringSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_AppendStringSignal(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140956.261">def simxWriteStringStream(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_WriteStringStream(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140956.262">def simxGetObjectFloatParameter(clientID, objectHandle, parameterID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parameterValue = ct.c_float()
    return c_GetObjectFloatParameter(clientID, objectHandle, parameterID, ct.byref(parameterValue), operationMode), parameterValue.value

</t>
<t tx="leo.20210713140956.263">def simxSetObjectFloatParameter(clientID, objectHandle, parameterID, parameterValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectFloatParameter(clientID, objectHandle, parameterID, parameterValue, operationMode)

</t>
<t tx="leo.20210713140956.264">def simxGetObjectIntParameter(clientID, objectHandle, parameterID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parameterValue = ct.c_int()
    return c_GetObjectIntParameter(clientID, objectHandle, parameterID, ct.byref(parameterValue), operationMode), parameterValue.value

</t>
<t tx="leo.20210713140956.265">def simxSetObjectIntParameter(clientID, objectHandle, parameterID, parameterValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectIntParameter(clientID, objectHandle, parameterID, parameterValue, operationMode)

</t>
<t tx="leo.20210713140956.266">def simxGetModelProperty(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    prop = ct.c_int()
    return c_GetModelProperty(clientID, objectHandle, ct.byref(prop), operationMode), prop.value

</t>
<t tx="leo.20210713140956.267">def simxSetModelProperty(clientID, objectHandle, prop, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetModelProperty(clientID, objectHandle, prop, operationMode)

</t>
<t tx="leo.20210713140956.268">def simxStart(connectionAddress, connectionPort, waitUntilConnected, doNotReconnectOnceDisconnected, timeOutInMs, commThreadCycleInMs):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(connectionAddress) is str):
        connectionAddress=connectionAddress.encode('utf-8')
    return c_Start(connectionAddress, connectionPort, waitUntilConnected, doNotReconnectOnceDisconnected, timeOutInMs, commThreadCycleInMs)

</t>
<t tx="leo.20210713140956.269">def simxFinish(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_Finish(clientID)

</t>
<t tx="leo.20210713140956.27">def step(self, action):
    assert self.action_space.contains(action), "%r (%s) invalid"%(action, type(action))
    
    # Actuate
    self._make_action(action)
    # Step
    self.step_simulation()
    # Observe
    self._make_observation()
    
    (x,x_dot,theta,theta_dot) = self.state
    
    done = x &lt; -self.x_threshold or theta &lt; -self.theta_threshold_radians \
        or x &gt;  self.x_threshold or theta &gt;  self.theta_threshold_radians
    done = bool(done)
    
    if not done:
        reward = 1.0
    elif self.steps_beyond_done is None:
        self.steps_beyond_done = 0
        reward = 1.0
    else:
        if self.steps_beyond_done == 0:
            logger.warning("You are calling 'step()' even though this environment has already returned done = True. You should always call 'reset()' once you receive 'done = True' -- any further steps are undefined behavior.")
        self.steps_beyond_done += 1
        reward = 0.0
    
    return np.array(self.state), reward, done, {}

</t>
<t tx="leo.20210713140956.270">def simxGetPingTime(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    pingTime = ct.c_int()
    return c_GetPingTime(clientID, ct.byref(pingTime)), pingTime.value

</t>
<t tx="leo.20210713140956.271">def simxGetLastCmdTime(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_GetLastCmdTime(clientID)

</t>
<t tx="leo.20210713140956.272">def simxSynchronousTrigger(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SynchronousTrigger(clientID)

</t>
<t tx="leo.20210713140956.273">def simxSynchronous(clientID, enable):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_Synchronous(clientID, enable)

</t>
<t tx="leo.20210713140956.274">def simxPauseCommunication(clientID, enable):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_PauseCommunication(clientID, enable)

</t>
<t tx="leo.20210713140956.275">def simxGetInMessageInfo(clientID, infoType):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    info = ct.c_int()
    return c_GetInMessageInfo(clientID, infoType, ct.byref(info)), info.value

</t>
<t tx="leo.20210713140956.276">def simxGetOutMessageInfo(clientID, infoType):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    info = ct.c_int()
    return c_GetOutMessageInfo(clientID, infoType, ct.byref(info)), info.value

</t>
<t tx="leo.20210713140956.277">def simxGetConnectionId(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_GetConnectionId(clientID)

</t>
<t tx="leo.20210713140956.278">def simxCreateBuffer(bufferSize):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_CreateBuffer(bufferSize)

</t>
<t tx="leo.20210713140956.279">def simxReleaseBuffer(buffer):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_ReleaseBuffer(buffer)

</t>
<t tx="leo.20210713140956.28">def reset(self):
    if self.sim_running:
        self.stop_simulation()
    self.start_simulation()
    self.steps_beyond_done = None
    
    v = self.np_random.uniform(low=-0.04, high=0.04, size=(1,))
    self.obj_set_velocity(self.action,v)
    self.step_simulation()
    
    self._make_observation()
    return np.array(self.state)

</t>
<t tx="leo.20210713140956.280">def simxTransferFile(clientID, filePathAndName, fileName_serverSide, timeOut, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(filePathAndName) is str):
        filePathAndName=filePathAndName.encode('utf-8')
    return c_TransferFile(clientID, filePathAndName, fileName_serverSide, timeOut, operationMode)

</t>
<t tx="leo.20210713140956.281">def simxEraseFile(clientID, fileName_serverSide, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(fileName_serverSide) is str):
        fileName_serverSide=fileName_serverSide.encode('utf-8')
    return c_EraseFile(clientID, fileName_serverSide, operationMode)

</t>
<t tx="leo.20210713140956.282">def simxCreateDummy(clientID, size, color, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if color != None:
        c_color = (ct.c_ubyte*12)(*color)
    else:
        c_color = None
    return c_CreateDummy(clientID, size, c_color, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.283">def simxQuery(clientID, signalName, signalValue, retSignalName, timeOutInMs):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    retSignalLength = ct.c_int();
    retSignalValue = ct.POINTER(ct.c_ubyte)()

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(retSignalName) is str:
            retSignalName=retSignalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this

    ret = c_Query(clientID, signalName, sigV, len(signalValue), retSignalName, ct.byref(retSignalValue), ct.byref(retSignalLength), timeOutInMs)

    a = bytearray()
    if ret == 0:
        for i in range(retSignalLength.value):
            a.append(retSignalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.284">def simxGetObjectGroupData(clientID, objectType, dataType, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handles =[]
    intData =[]
    floatData =[]
    stringData =[]
    handlesC = ct.c_int()
    handlesP = ct.POINTER(ct.c_int)()
    intDataC = ct.c_int()
    intDataP = ct.POINTER(ct.c_int)()
    floatDataC = ct.c_int()
    floatDataP = ct.POINTER(ct.c_float)()
    stringDataC = ct.c_int()
    stringDataP = ct.POINTER(ct.c_char)()
    ret = c_GetObjectGroupData(clientID, objectType, dataType, ct.byref(handlesC), ct.byref(handlesP), ct.byref(intDataC), ct.byref(intDataP), ct.byref(floatDataC), ct.byref(floatDataP), ct.byref(stringDataC), ct.byref(stringDataP), operationMode)

    if ret == 0:
        for i in range(handlesC.value):
            handles.append(handlesP[i])
        for i in range(intDataC.value):
            intData.append(intDataP[i])
        for i in range(floatDataC.value):
            floatData.append(floatDataP[i])
        s = 0
        for i in range(stringDataC.value):
            a = bytearray()
            while stringDataP[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(stringDataP[s],'big'))
                else:
                    a.append(stringDataP[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                a=str(a,'utf-8')
            else:
                a=str(a)
            stringData.append(a)

    return ret, handles, intData, floatData, stringData

</t>
<t tx="leo.20210713140956.285">def simxCallScriptFunction(clientID, scriptDescription, options, functionName, inputInts, inputFloats, inputStrings, inputBuffer, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    inputBufferV=inputBuffer
    if sys.version_info[0] == 3:
        if type(scriptDescription) is str:
            scriptDescription=scriptDescription.encode('utf-8')
        if type(functionName) is str:
            functionName=functionName.encode('utf-8')
        if type(inputBuffer) is bytearray:
            inputBufferV  = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
        if type(inputBuffer) is str:
            inputBuffer=inputBuffer.encode('utf-8')
            inputBufferV  = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
    else:
        if type(inputBuffer) is bytearray:
            inputBufferV = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
        if type(inputBuffer) is str:
            inputBuffer=bytearray(inputBuffer)
            inputBufferV = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
    inputBufferV=ct.cast(inputBufferV,ct.POINTER(ct.c_ubyte)) # IronPython needs this

    c_inInts  = (ct.c_int*len(inputInts))(*inputInts)
    c_inInts = ct.cast(c_inInts,ct.POINTER(ct.c_int)) # IronPython needs this
    c_inFloats  = (ct.c_float*len(inputFloats))(*inputFloats)
    c_inFloats = ct.cast(c_inFloats,ct.POINTER(ct.c_float)) # IronPython needs this

    concatStr=''.encode('utf-8')
    for i in range(len(inputStrings)):
        a=inputStrings[i]
        a=a+'\0'
        if type(a) is str:
            a=a.encode('utf-8')
        concatStr=concatStr+a
    c_inStrings  = (ct.c_char*len(concatStr))(*concatStr)

    intDataOut =[]
    floatDataOut =[]
    stringDataOut =[]
    bufferOut =bytearray()

    intDataC = ct.c_int()
    intDataP = ct.POINTER(ct.c_int)()
    floatDataC = ct.c_int()
    floatDataP = ct.POINTER(ct.c_float)()
    stringDataC = ct.c_int()
    stringDataP = ct.POINTER(ct.c_char)()
    bufferS = ct.c_int()
    bufferP = ct.POINTER(ct.c_ubyte)()

    ret = c_CallScriptFunction(clientID,scriptDescription,options,functionName,len(inputInts),c_inInts,len(inputFloats),c_inFloats,len(inputStrings),c_inStrings,len(inputBuffer),inputBufferV,ct.byref(intDataC),ct.byref(intDataP),ct.byref(floatDataC),ct.byref(floatDataP),ct.byref(stringDataC),ct.byref(stringDataP),ct.byref(bufferS),ct.byref(bufferP),operationMode)

    if ret == 0:
        for i in range(intDataC.value):
            intDataOut.append(intDataP[i])
        for i in range(floatDataC.value):
            floatDataOut.append(floatDataP[i])
        s = 0
        for i in range(stringDataC.value):
            a = bytearray()
            while stringDataP[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(stringDataP[s],'big'))
                else:
                    a.append(stringDataP[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                a=str(a,'utf-8')
            else:
                a=str(a)
            stringDataOut.append(a)
        for i in range(bufferS.value):
            bufferOut.append(bufferP[i])
    if sys.version_info[0] != 3:
        bufferOut=str(bufferOut)

    return ret, intDataOut, floatDataOut, stringDataOut, bufferOut

</t>
<t tx="leo.20210713140956.286">def simxGetObjectVelocity(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    linearVel  = (ct.c_float*3)()
    angularVel = (ct.c_float*3)()
    ret = c_GetObjectVelocity(clientID, objectHandle, linearVel, angularVel, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(linearVel[i])
    arr2 = []
    for i in range(3):
        arr2.append(angularVel[i])
    return ret, arr1, arr2

</t>
<t tx="leo.20210713140956.287">def simxPackInts(intList):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        s=bytes()
        for i in range(len(intList)):
            s=s+struct.pack('&lt;i',intList[i])
        s=bytearray(s)
    else:
        s=''
        for i in range(len(intList)):
            s+=struct.pack('&lt;i',intList[i])
    return s

</t>
<t tx="leo.20210713140956.288">def simxUnpackInts(intsPackedInString):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    b=[]
    for i in range(int(len(intsPackedInString)/4)):
        b.append(struct.unpack('&lt;i',intsPackedInString[4*i:4*(i+1)])[0])
    return b

</t>
<t tx="leo.20210713140956.289">def simxPackFloats(floatList):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        s=bytes()
        for i in range(len(floatList)):
            s=s+struct.pack('&lt;f',floatList[i])
        s=bytearray(s)
    else:
        s=''
        for i in range(len(floatList)):
            s+=struct.pack('&lt;f',floatList[i])
    return s

</t>
<t tx="leo.20210713140956.29">def render(self, mode='human'):
    screen_width = 600
    screen_height = 400
    
    world_width = self.x_threshold*2
    scale = screen_width/world_width
    carty = 100 # TOP OF CART
    polewidth = 10.0
    polelen = scale * 1.0
    cartwidth = 50.0
    cartheight = 30.0
    
    if self.viewer is None:
        from gym.envs.classic_control import rendering
        self.viewer = rendering.Viewer(screen_width, screen_height)
        l,r,t,b = -cartwidth/2, cartwidth/2, cartheight/2, -cartheight/2
        axleoffset =cartheight/4.0
        cart = rendering.FilledPolygon([(l,b), (l,t), (r,t), (r,b)])
        self.carttrans = rendering.Transform()
        cart.add_attr(self.carttrans)
        self.viewer.add_geom(cart)
        l,r,t,b = -polewidth/2,polewidth/2,polelen-polewidth/2,-polewidth/2
        pole = rendering.FilledPolygon([(l,b), (l,t), (r,t), (r,b)])
        pole.set_color(.8,.6,.4)
        self.poletrans = rendering.Transform(translation=(0, axleoffset))
        pole.add_attr(self.poletrans)
        pole.add_attr(self.carttrans)
        self.viewer.add_geom(pole)
        self.axle = rendering.make_circle(polewidth/2)
        self.axle.add_attr(self.poletrans)
        self.axle.add_attr(self.carttrans)
        self.axle.set_color(.5,.5,.8)
        self.viewer.add_geom(self.axle)
        self.track = rendering.Line((0,carty), (screen_width,carty))
        self.track.set_color(0,0,0)
        self.viewer.add_geom(self.track)
    
    if self.state is None: return None
    
    x = self.state
    cartx = x[0]*scale+screen_width/2.0 # MIDDLE OF CART
    self.carttrans.set_translation(cartx, carty)
    self.poletrans.set_rotation(-x[2])
    
    return self.viewer.render(return_rgb_array = mode=='rgb_array')

</t>
<t tx="leo.20210713140956.290">def simxUnpackFloats(floatsPackedInString):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    b=[]
    for i in range(int(len(floatsPackedInString)/4)):
        b.append(struct.unpack('&lt;f',floatsPackedInString[4*i:4*(i+1)])[0])
    return b
</t>
<t tx="leo.20210713140956.291">
@others
@language python
@tabwidth -4

</t>
<t tx="leo.20210713140956.292">from vrep_env import vrep

import gym
import time
import numpy as np

</t>
<t tx="leo.20210713140956.293">class VrepEnv(gym.Env):
    """Superclass for V-REP environments.
    """
    @others
</t>
<t tx="leo.20210713140956.294">def __init__(self,server_addr,server_port,scene_path=None):
    # Parameters
    self.server_addr = server_addr
    self.server_port = server_port
    self.scene_path  = scene_path
    
    self.opM_get = vrep.simx_opmode_blocking
    #self.opM_get = vrep.simx_opmode_oneshot
    self.opM_set = vrep.simx_opmode_oneshot
    
    # Status
    self.cID = -1
    self.connected = False
    self.scene_loaded = (scene_path == None)
    self.sim_running = False
    
    # Remote API function meaningful return codes
    self.str_simx_return = [
        'simx_return_ok',
        'simx_return_novalue_flag',
        'simx_return_timeout_flag',
        'simx_return_illegal_opmode_flag',
        'simx_return_remote_error_flag',
        'simx_return_split_progress_flag',
        'simx_return_local_error_flag',
        'simx_return_initialize_error_flag']
    
    self.connect(server_addr,server_port)
    if not self.scene_loaded:
        self.load_scene(scene_path)

# internal methods

# Remote API call wrapper
#def RAPI_rc(self, ret_tuple, tolerance=vrep.simx_return_ok):
</t>
<t tx="leo.20210713140956.295">def RAPI_rc(self, ret_tuple, tolerance=vrep.simx_return_novalue_flag):
    istuple = isinstance(ret_tuple, tuple)
    ret = ret_tuple[0] if istuple else ret_tuple
    ''' need to comment this for execution
    if (ret != vrep.simx_return_ok) and (ret != tolerance):
        raise RuntimeError('Remote API return code: ('+str(ret)+': '+self.str_simx_return[ret.bit_length()]+')')
    '''
    return ret_tuple[1:] if istuple else None

</t>
<t tx="leo.20210713140956.296">def connect(self, server_addr, server_port):
    if self.connected:
        raise RuntimeError('Client is already connected.')
    attempts = 0
    max_attempts = 64
    while True:
        self.cID = vrep.simxStart(
            connectionAddress              = server_addr,
            connectionPort                 = server_port,
            waitUntilConnected             = True,
            doNotReconnectOnceDisconnected = True,
            timeOutInMs                    = 1000,
            commThreadCycleInMs            = 0)
        attempts += 1
        if self.cID != -1:
            self.connected = True
            break
        elif attempts &lt; max_attempts:
            print('Unable to connect to V-REP at ',server_addr,':',server_port,'. Retrying...')
            time.sleep(4)
        else:
            raise RuntimeError('Unable to connect to V-REP.')
    
    # Setting up debug signal
    self.set_integer_signal('sig_debug',1337)
    
    # Getting useful parameter values
    self.is_headless = self.get_boolean_parameter(vrep.sim_boolparam_headless)
    
    # If not headless, remove GUI clutter
    if not self.is_headless:
        self.set_boolean_parameter(vrep.sim_boolparam_browser_visible  ,False)
        self.set_boolean_parameter(vrep.sim_boolparam_hierarchy_visible,False)
        #self.set_boolean_parameter(vrep.sim_boolparam_display_enabled  ,False)
        # Remove GUI controls
        #self.set_boolean_parameter(vrep.sim_boolparam_play_toolbarbutton_enabled  ,False)
        #self.set_boolean_parameter(vrep.sim_boolparam_pause_toolbarbutton_enabled ,False)
        #self.set_boolean_parameter(vrep.sim_boolparam_stop_toolbarbutton_enabled  ,False)
        self.set_boolean_parameter(vrep.sim_boolparam_console_visible  ,False)
    
    # Optionally override real-time mode
    self.set_boolean_parameter(vrep.sim_boolparam_realtime_simulation, False)

</t>
<t tx="leo.20210713140956.297">def disconnect(self):
    if not self.connected:
        raise RuntimeError('Client is not even connected.')
    # Clearing debug signal
    vrep.simxClearIntegerSignal(self.cID,'sig_debug', vrep.simx_opmode_blocking)
    vrep.simxFinish(self.cID)
    self.connected = False

</t>
<t tx="leo.20210713140956.298">def load_scene(self, scene_path):
    if self.scene_loaded:
        raise RuntimeError('Scene is already loaded.')
    self.RAPI_rc(vrep.simxLoadScene(self.cID,scene_path,0, vrep.simx_opmode_blocking))
    self.scene_loaded = True

</t>
<t tx="leo.20210713140956.299">def close_scene(self):
    if not self.scene_loaded:
        raise RuntimeError('Scene is not loaded.')
    self.RAPI_rc(vrep.simxCloseScene(self.cID, vrep.simx_opmode_blocking))
    self.scene_loaded = False

</t>
<t tx="leo.20210713140956.3">
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210713140956.30">def close(self):
    if self.viewer: self.viewer.close()
    vrep_env.VrepEnv.close(self)

</t>
<t tx="leo.20210713140956.300">def start_simulation(self):
    if self.sim_running:
        raise RuntimeError('Simulation is already running.')
    
    # Optionally override physics engine ( 0=Bullet, 1=ODE, 2=Vortex, 3=Newton )
    #self.set_integer_parameter(vrep.sim_intparam_dynamic_engine, 0) # 0=Bullet
    
    # Optionally override delta time
    #self.set_float_parameter(vrep.sim_floatparam_simulation_time_step, 25)
    
    self.RAPI_rc(vrep.simxSynchronous(self.cID,True))
    self.RAPI_rc(vrep.simxStartSimulation(self.cID, vrep.simx_opmode_blocking))
    
    # Enable Threaded Rendering for faster simulation
    if not self.is_headless:
        self.set_boolean_parameter(vrep.sim_boolparam_threaded_rendering_enabled,True)
    
    self.sim_running = True

</t>
<t tx="leo.20210713140956.301">def stop_simulation(self):
    if not self.sim_running:
        raise RuntimeError('Simulation is not running.')
    
    self.RAPI_rc(vrep.simxStopSimulation(self.cID, vrep.simx_opmode_blocking))
    
    # Checking if the server really stopped
    try:
        while True:
            self.RAPI_rc(vrep.simxGetIntegerSignal(self.cID,'sig_debug',vrep.simx_opmode_blocking))
            e = vrep.simxGetInMessageInfo(self.cID,vrep.simx_headeroffset_server_state)
            still_running = e[1] &amp; 1
            if not still_running:
                break
    except: pass
    self.sim_running = False

</t>
<t tx="leo.20210713140956.302">def step_simulation(self):
    self.RAPI_rc(vrep.simxSynchronousTrigger(self.cID))

# Below are all wrapped methods unrelated to connection/scene

# misc methods

</t>
<t tx="leo.20210713140956.303">def add_statusbar_message(self, message):
    self.RAPI_rc(vrep.simxAddStatusbarMessage(self.cID, message, vrep.simx_opmode_blocking))

# object methods

</t>
<t tx="leo.20210713140956.304">def get_object_handle(self, name):
    handle, = self.RAPI_rc(vrep.simxGetObjectHandle(self.cID, name, vrep.simx_opmode_blocking))
    return handle

# "getters"

</t>
<t tx="leo.20210713140956.305">def obj_get_position(self, handle, relative_to=None):
    position, = self.RAPI_rc(vrep.simxGetObjectPosition( self.cID,handle,
        -1 if relative_to is None else relative_to,
        self.opM_get))
    return position
</t>
<t tx="leo.20210713140956.306">def obj_get_orientation(self, handle, relative_to=None):
    eulerAngles, = self.RAPI_rc(vrep.simxGetObjectOrientation( self.cID,handle,
        -1 if relative_to is None else relative_to,
        self.opM_get))
    return eulerAngles
</t>
<t tx="leo.20210713140956.307">def obj_get_orientation_continuous(self, handle, relative_to=None):
    ea = self.obj_get_orientation(handle,relative_to)
    return [
        np.sin(ea[0]),np.cos(ea[0]),
        np.sin(ea[1]),np.cos(ea[1]),
        np.sin(ea[2]),np.cos(ea[2])]

# (linearVel, angularVel)
</t>
<t tx="leo.20210713140956.308">def obj_get_velocity(self, handle):
    return self.RAPI_rc(vrep.simxGetObjectVelocity( self.cID,handle,
        self.opM_get))
</t>
<t tx="leo.20210713140956.309">def obj_get_joint_angle(self, handle):
    angle, = self.RAPI_rc(vrep.simxGetJointPosition( self.cID,handle,
            self.opM_get))
    #return -np.rad2deg(angle[0])
    return angle
</t>
<t tx="leo.20210713140956.31">def main(args):
    env = CartPoleVrepEnv()
    for i_episode in range(8):
        observation = env.reset()
        total_reward = 0
        for t in range(200):
            action = env.action_space.sample()
            observation, reward, done, _ = env.step(action)
            total_reward += reward
            if done:
                break
        print("Episode finished after {} timesteps.\tTotal reward: {}".format(t+1,total_reward))
    env.close()
    return 0

</t>
<t tx="leo.20210713140956.310">def obj_get_joint_angle_continuous(self, handle):
    rad = self.obj_get_joint_angle(handle)
    return [np.sin(rad),np.cos(rad)]
</t>
<t tx="leo.20210713140956.311">def obj_get_joint_force(self, handle):
    force = self.RAPI_rc(vrep.simxGetJointForce( self.cID,handle,
            self.opM_get))
    return force
</t>
<t tx="leo.20210713140956.312">def obj_read_force_sensor(self, handle):
    state, forceVector, torqueVector = self.RAPI_rc(vrep.simxReadForceSensor( self.cID,handle,
        self.opM_get))
    if   state &amp; 1 != 1: # bit 0 not set
        return None # sensor data not (yet) available
    elif state &amp; 2 == 1: # bit 1 set
        return 0 # force sensor is broken
    else:
        return forceVector, torqueVector
</t>
<t tx="leo.20210713140956.313">def obj_get_vision_image(self, handle):
    resolution, image = self.RAPI_rc(vrep.simxGetVisionSensorImage( self.cID,handle,
        0, # assume RGB
        self.opM_get,))
    dim, im = resolution, image
    nim = np.array(im, dtype='uint8')
    nim = np.reshape(nim, (dim[1], dim[0], 3))
    nim = np.flip(nim, 0)  # horizontal flip
    #nim = np.flip(nim, 2)  # RGB -&gt; BGR
    return nim

# "setters"

</t>
<t tx="leo.20210713140956.314">def obj_set_position_target(self, handle, angle):
    return self.RAPI_rc(vrep.simxSetJointTargetPosition( self.cID,handle,
        -np.deg2rad(angle),
        self.opM_set))
</t>
<t tx="leo.20210713140956.315">def obj_set_velocity(self, handle, v):
    return self.RAPI_rc(vrep.simxSetJointTargetVelocity( self.cID,handle,
        v,
        self.opM_set))
</t>
<t tx="leo.20210713140956.316">def obj_set_force(self, handle, f):
    return self.RAPI_rc(vrep.simxSetJointForce( self.cID,handle,
        f,
        self.opM_set))
</t>
<t tx="leo.20210713140956.317">def obj_set_position(self, handle, pos, relative_to=None):
    return self.RAPI_rc(vrep.simxSetObjectPosition( self.cID,handle,
        -1 if relative_to is None else relative_to,
        pos,
        self.opM_set))
</t>
<t tx="leo.20210713140956.318">def obj_set_orientation(self, handle, eulerAngles, relative_to=None):
    return self.RAPI_rc(vrep.simxSetObjectOrientation( self.cID,handle,
        -1 if relative_to is None else relative_to,
        eulerAngles,
        self.opM_set))
# collisions

</t>
<t tx="leo.20210713140956.319">def get_collision_handle(self, name):
    handle, = self.RAPI_rc(vrep.simxGetCollisionHandle(self.cID, name, vrep.simx_opmode_blocking))
    return handle
</t>
<t tx="leo.20210713140956.32"># This file is a template for V-rep environments
#     all names in this file are just examples
# Search for '#modify' and replace accordingly

@others
if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))

@language python
@tabwidth -4

</t>
<t tx="leo.20210713140956.320">def read_collision(self, handle):
    collisionState, = self.RAPI_rc(vrep.simxReadCollision( self.cID,handle,
            self.opM_get))
    return collisionState

# signals

</t>
<t tx="leo.20210713140956.321">def set_integer_signal(self, sig_name, sig_val):
    return self.RAPI_rc(vrep.simxSetIntegerSignal( self.cID,
        sig_name, sig_val,
        self.opM_set))
</t>
<t tx="leo.20210713140956.322">def set_float_signal(self, sig_name, sig_val):
    return self.RAPI_rc(vrep.SetFloatSignal( self.cID,
        sig_name, sig_val,
        self.opM_set))
</t>
<t tx="leo.20210713140956.323">def set_string_signal(self, sig_name, sig_val):
    return self.RAPI_rc(vrep.SetStringSignal( self.cID,
        sig_name, sig_val,
        self.opM_set))

</t>
<t tx="leo.20210713140956.324">def get_integer_signal(self, sig_name):
    return self.RAPI_rc(vrep.simxGetIntegerSignal( self.cID,
        sig_name,
        self.opM_get))
</t>
<t tx="leo.20210713140956.325">def get_float_signal(self, sig_name):
    return self.RAPI_rc(vrep.simxGetFloatSignal( self.cID,
        sig_name,
        self.opM_get))
</t>
<t tx="leo.20210713140956.326">def get_string_signal(self, sig_name):
    return self.RAPI_rc(vrep.simxGetStringSignal( self.cID,
        sig_name,
        self.opM_get))

# parameters

</t>
<t tx="leo.20210713140956.327">def set_boolean_parameter(self, param_id, param_val):
    return self.RAPI_rc(vrep.simxSetBooleanParameter( self.cID,
        param_id, param_val,
        vrep.simx_opmode_blocking))
</t>
<t tx="leo.20210713140956.328">def set_integer_parameter(self, param_id, param_val):
    return self.RAPI_rc(vrep.simxSetIntegerParameter( self.cID,
        param_id, param_val,
        vrep.simx_opmode_blocking))
</t>
<t tx="leo.20210713140956.329">def set_float_parameter(self, param_id, param_val):
    return self.RAPI_rc(vrep.simxSetFloatingParameter( self.cID,
        param_id, param_val,
        vrep.simx_opmode_blocking))
</t>
<t tx="leo.20210713140956.33">from vrep_env import vrep_env
from vrep_env import vrep # vrep.sim_handle_parent

import os
#vrep_scenes_path = os.environ['VREP_SCENES_PATH']
vrep_scenes_path = "C:/tmp/vrep-env/examples/scenes"

import gym
from gym import spaces

import numpy as np

# #modify: the env class name
</t>
<t tx="leo.20210713140956.330">def set_array_parameter(self, param_id, param_val):
    return self.RAPI_rc(vrep.simxSetArrayParameter( self.cID,
        param_id, param_val,
        vrep.simx_opmode_blocking))

</t>
<t tx="leo.20210713140956.331">def get_boolean_parameter(self, param_id):
    return self.RAPI_rc(vrep.simxGetBooleanParameter( self.cID,
        param_id,
        vrep.simx_opmode_blocking))[0]
</t>
<t tx="leo.20210713140956.332">def get_integer_parameter(self, param_id):
    return self.RAPI_rc(vrep.simxGetIntegerParameter( self.cID,
        param_id,
        vrep.simx_opmode_blocking))[0]
</t>
<t tx="leo.20210713140956.333">def get_float_parameter(self, param_id):
    return self.RAPI_rc(vrep.simxGetFloatingParameter( self.cID,
        param_id,
        vrep.simx_opmode_blocking))[0]
</t>
<t tx="leo.20210713140956.334">def get_array_parameter(self, param_id):
    return self.RAPI_rc(vrep.simxGetArrayParameter( self.cID,
        param_id,
        vrep.simx_opmode_blocking))[0]

# scripts
# child scripts
</t>
<t tx="leo.20210713140956.335">def call_childscript_function(self,obj_name,func_name,in_tuple):
    return self.RAPI_rc(vrep.simxCallScriptFunction(self.cID,
        obj_name,vrep.sim_scripttype_childscript,func_name,
        in_tuple[0],in_tuple[1],in_tuple[2],in_tuple[3],
        vrep.simx_opmode_blocking))

# openai/gym

# Set this in SOME subclasses
#metadata = {'render.modes': []}
#reward_range = (-np.inf, np.inf)

# Override in SOME subclasses
#def _close(self): pass

# Set these in ALL subclasses
#action_space = None
#observation_space = None

# Override in ALL subclasses
#def _step(self, action): raise NotImplementedError
#def _reset(self): raise NotImplementedError
#def _render(self, mode='human', close=False): return
#def _seed(self, seed=None): return []

#def _close(self):
</t>
<t tx="leo.20210713140956.336">def close(self):
    if self.sim_running:
        self.stop_simulation()
    # Closing the scene is unnecessary
    #if self.scene_loaded:
    #	self.close_scene()
    if self.connected:
        self.disconnect()

</t>
<t tx="leo.20210713140956.337">

@language python
@tabwidth -4
</t>
<t tx="leo.20210713140956.34">class ExampleVrepEnv(vrep_env.VrepEnv):
    metadata = {
        'render.modes': [],
    }
    @others
</t>
<t tx="leo.20210713140956.340"></t>
<t tx="leo.20210713140956.341">
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210713140956.342">import platform
import struct
import sys
import os
import ctypes as ct
from .simConst import *

#load library
libsimx = None
try:
    file_extension = '.so'
    if platform.system() =='cli':
        file_extension = '.dll'
    elif platform.system() =='Windows':
        file_extension = '.dll'
    elif platform.system() == 'Darwin':
        file_extension = '.dylib'
    else:
        file_extension = '.so'
    libfullpath = os.path.join(os.path.dirname(__file__), 'remoteApi' + file_extension)
    libsimx = ct.CDLL(libfullpath)
except:
    print ('----------------------------------------------------')
    print ('The remoteApi library could not be loaded. Make sure')
    print ('it is located in the same folder as "sim.py", or')
    print ('appropriately adjust the file "sim.py"')
    print ('----------------------------------------------------')
    print ('')

#ctypes wrapper prototypes
c_GetJointPosition          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointPosition", libsimx))
c_SetJointPosition          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointPosition", libsimx))
c_GetJointMatrix            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointMatrix", libsimx))
c_SetSphericalJointMatrix   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetSphericalJointMatrix", libsimx))
c_SetJointTargetVelocity    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointTargetVelocity", libsimx))
c_SetJointTargetPosition    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointTargetPosition", libsimx))
c_GetJointForce             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointForce", libsimx))
c_GetJointMaxForce          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointMaxForce", libsimx))
c_SetJointForce             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointMaxForce", libsimx))
c_SetJointMaxForce          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointMaxForce", libsimx))
c_ReadForceSensor           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.c_int32)(("simxReadForceSensor", libsimx))
c_BreakForceSensor          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxBreakForceSensor", libsimx))
c_ReadVisionSensor          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.POINTER(ct.c_float)), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxReadVisionSensor", libsimx))
c_GetObjectHandle           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectHandle", libsimx))
c_GetVisionSensorImage      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_byte)), ct.c_ubyte, ct.c_int32)(("simxGetVisionSensorImage", libsimx))
c_SetVisionSensorImage      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_byte), ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetVisionSensorImage", libsimx))
c_GetVisionSensorDepthBuffer= ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)), ct.c_int32)(("simxGetVisionSensorDepthBuffer", libsimx))
c_GetObjectChild            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectChild", libsimx))
c_GetObjectParent           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectParent", libsimx))
c_ReadProximitySensor       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_float), ct.c_int32)(("simxReadProximitySensor", libsimx))
c_LoadModel                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.POINTER(ct.c_int32), ct.c_int32)(("simxLoadModel", libsimx))
c_LoadUI                    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxLoadUI", libsimx))
c_LoadScene                 =  ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.c_int32)(("simxLoadScene", libsimx))
c_StartSimulation           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxStartSimulation", libsimx))
c_PauseSimulation           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxPauseSimulation", libsimx))
c_StopSimulation            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxStopSimulation", libsimx))
c_GetUIHandle               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIHandle", libsimx))
c_GetUISlider               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUISlider", libsimx))
c_SetUISlider               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetUISlider", libsimx))
c_GetUIEventButton          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIEventButton", libsimx))
c_GetUIButtonProperty       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIButtonProperty", libsimx))
c_SetUIButtonProperty       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetUIButtonProperty", libsimx))
c_AddStatusbarMessage       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxAddStatusbarMessage", libsimx))
c_AuxiliaryConsoleOpen      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.c_int32)(("simxAuxiliaryConsoleOpen", libsimx))
c_AuxiliaryConsoleClose     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxAuxiliaryConsoleClose", libsimx))
c_AuxiliaryConsolePrint     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxAuxiliaryConsolePrint", libsimx))
c_AuxiliaryConsoleShow      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxAuxiliaryConsoleShow", libsimx))
c_GetObjectOrientation      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectOrientation", libsimx))
c_GetObjectQuaternion       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectQuaternion", libsimx))
c_GetObjectPosition         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectPosition", libsimx))
c_SetObjectOrientation      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectOrientation", libsimx))
c_SetObjectQuaternion       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectQuaternion", libsimx))
c_SetObjectPosition         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectPosition", libsimx))
c_SetObjectParent           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetObjectParent", libsimx))
c_SetUIButtonLabel          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32)(("simxSetUIButtonLabel", libsimx))
c_GetLastErrors             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetLastErrors", libsimx))
c_GetArrayParameter         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetArrayParameter", libsimx))
c_SetArrayParameter         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetArrayParameter", libsimx))
c_GetBooleanParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxGetBooleanParameter", libsimx))
c_SetBooleanParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetBooleanParameter", libsimx))
c_GetIntegerParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetIntegerParameter", libsimx))
c_SetIntegerParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetIntegerParameter", libsimx))
c_GetFloatingParameter      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetFloatingParameter", libsimx))
c_SetFloatingParameter      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetFloatingParameter", libsimx))
c_GetStringParameter        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetStringParameter", libsimx))
c_GetCollisionHandle        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetCollisionHandle", libsimx))
c_GetDistanceHandle         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetDistanceHandle", libsimx))
c_GetCollectionHandle       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetCollectionHandle", libsimx))
c_ReadCollision             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxReadCollision", libsimx))
c_ReadDistance              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxReadDistance", libsimx))
c_RemoveObject              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveObject", libsimx))
c_RemoveModel               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveModel", libsimx))
c_RemoveUI                  = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveUI", libsimx))
c_CloseScene                = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxCloseScene", libsimx))
c_GetObjects                = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxGetObjects", libsimx))
c_DisplayDialog             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.c_int32)(("simxDisplayDialog", libsimx))
c_EndDialog                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxEndDialog", libsimx))
c_GetDialogInput            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetDialogInput", libsimx))
c_GetDialogResult           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetDialogResult", libsimx))
c_CopyPasteObjects          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32, ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxCopyPasteObjects", libsimx))
c_GetObjectSelection        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectSelection", libsimx))
c_SetObjectSelection        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32, ct.c_int32)(("simxSetObjectSelection", libsimx))
c_ClearFloatSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearFloatSignal", libsimx))
c_ClearIntegerSignal        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearIntegerSignal", libsimx))
c_ClearStringSignal         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearStringSignal", libsimx))
c_GetFloatSignal            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_float), ct.c_int32)(("simxGetFloatSignal", libsimx))
c_GetIntegerSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetIntegerSignal", libsimx))
c_GetStringSignal           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetStringSignal", libsimx))
c_SetFloatSignal            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_float, ct.c_int32)(("simxSetFloatSignal", libsimx))
c_SetIntegerSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32)(("simxSetIntegerSignal", libsimx))
c_SetStringSignal           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxSetStringSignal", libsimx))
c_AppendStringSignal        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxAppendStringSignal", libsimx))
c_WriteStringStream         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxWriteStringStream", libsimx))
c_GetObjectFloatParameter   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectFloatParameter", libsimx))
c_SetObjectFloatParameter   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetObjectFloatParameter", libsimx))
c_GetObjectIntParameter     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectIntParameter", libsimx))
c_SetObjectIntParameter     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetObjectIntParameter", libsimx))
c_GetModelProperty          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetModelProperty", libsimx))
c_SetModelProperty          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetModelProperty", libsimx))
c_Start                     = ct.CFUNCTYPE(ct.c_int32,ct.POINTER(ct.c_char), ct.c_int32, ct.c_ubyte, ct.c_ubyte, ct.c_int32, ct.c_int32)(("simxStart", libsimx))
c_Finish                    = ct.CFUNCTYPE(None, ct.c_int32)(("simxFinish", libsimx))
c_GetPingTime               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetPingTime", libsimx))
c_GetLastCmdTime            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxGetLastCmdTime", libsimx))
c_SynchronousTrigger        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxSynchronousTrigger", libsimx))
c_Synchronous               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_ubyte)(("simxSynchronous", libsimx))
c_PauseCommunication        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_ubyte)(("simxPauseCommunication", libsimx))
c_GetInMessageInfo          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetInMessageInfo", libsimx))
c_GetOutMessageInfo         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetOutMessageInfo", libsimx))
c_GetConnectionId           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxGetConnectionId", libsimx))
c_CreateBuffer              = ct.CFUNCTYPE(ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxCreateBuffer", libsimx))
c_ReleaseBuffer             = ct.CFUNCTYPE(None, ct.c_void_p)(("simxReleaseBuffer", libsimx))
c_TransferFile              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32)(("simxTransferFile", libsimx))
c_EraseFile                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxEraseFile", libsimx))
c_GetAndClearStringSignal   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetAndClearStringSignal", libsimx))
c_ReadStringStream          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxReadStringStream", libsimx))
c_CreateDummy               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_float, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_int32), ct.c_int32)(("simxCreateDummy", libsimx))
c_Query                     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxQuery", libsimx))
c_GetObjectGroupData        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetObjectGroupData", libsimx))
c_GetObjectVelocity         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectVelocity", libsimx))
c_CallScriptFunction        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_int32),ct.c_int32,ct.POINTER(ct.c_float),ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_ubyte),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_ubyte)),ct.c_int32)(("simxCallScriptFunction", libsimx))

#API functions
</t>
<t tx="leo.20210713140956.343">def simxGetJointPosition(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    position = ct.c_float()
    return c_GetJointPosition(clientID, jointHandle, ct.byref(position), operationMode), position.value

</t>
<t tx="leo.20210713140956.344">def simxSetJointPosition(clientID, jointHandle, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointPosition(clientID, jointHandle, position, operationMode)

</t>
<t tx="leo.20210713140956.345">def simxGetJointMatrix(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    matrix = (ct.c_float*12)()
    ret = c_GetJointMatrix(clientID, jointHandle, matrix, operationMode)
    arr = []
    for i in range(12):
        arr.append(matrix[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.346">def simxSetSphericalJointMatrix(clientID, jointHandle, matrix, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    matrix = (ct.c_float*12)(*matrix)
    return c_SetSphericalJointMatrix(clientID, jointHandle, matrix, operationMode)

</t>
<t tx="leo.20210713140956.347">def simxSetJointTargetVelocity(clientID, jointHandle, targetVelocity, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointTargetVelocity(clientID, jointHandle, targetVelocity, operationMode)

</t>
<t tx="leo.20210713140956.348">def simxSetJointTargetPosition(clientID, jointHandle, targetPosition, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointTargetPosition(clientID, jointHandle, targetPosition, operationMode)

</t>
<t tx="leo.20210713140956.349">def simxJointGetForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140956.35">def __init__(
    self,
    server_addr='127.0.0.1',
    server_port=19997,
    # #modify: the filename of your v-rep scene
    scene_path=vrep_scenes_path+'/example.ttt'
):
    
    vrep_env.VrepEnv.__init__(self,server_addr,server_port,scene_path)
    # #modify: the name of the joints to be used in action space
    joint_names = [
        'example_joint_0',
        'example_left_joint_0','example_right_joint_0',
        'example_joint_1',
        'example_left_joint_1','example_right_joint_1',
    ]
    # #modify: the name of the shapes to be used in observation space
    shape_names = [
        'example_head',
        'example_left_arm','example_right_arm',
        'example_torso',
        'example_left_leg','example_right_leg',
    ]
    
    # Getting object handles
    
    # we will store V-rep object handles (oh = object handle)
    
    # Meta
    # #modify: if you want additional object handles
    self.camera = self.get_object_handle('camera')
    
    # Actuators
    self.oh_joint = list(map(self.get_object_handle, joint_names))
    # Shapes
    self.oh_shape = list(map(self.get_object_handle, shape_names))
    
    
    # #modify: if size of action space is different than number of joints
    # Example: One action per joint
    num_act = len(self.oh_joint)
    
    # #modify: if size of observation space is different than number of joints
    # Example: 3 dimensions of linear and angular (2) velocities + 6 additional dimension
    num_obs = (len(self.oh_shape)*3*2) + 3*2
    
    # #modify: action_space and observation_space to suit your needs
    self.joints_max_velocity = 3.0
    act = np.array( [self.joints_max_velocity] * num_act )
    obs = np.array(          [np.inf]          * num_obs )
    
    self.action_space      = spaces.Box(-act,act)
    self.observation_space = spaces.Box(-obs,obs)
    
    # #modify: optional message
    print('ExampleVrepEnv: initialized')

</t>
<t tx="leo.20210713140956.350">def simxGetJointForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140956.351">def simxGetJointMaxForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointMaxForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140956.352">def simxSetJointForce(clientID, jointHandle, force, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_SetJointMaxForce(clientID, jointHandle, force, operationMode)

</t>
<t tx="leo.20210713140956.353">def simxSetJointMaxForce(clientID, jointHandle, force, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_SetJointMaxForce(clientID, jointHandle, force, operationMode)

</t>
<t tx="leo.20210713140956.354">def simxReadForceSensor(clientID, forceSensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    state = ct.c_ubyte()
    forceVector  = (ct.c_float*3)()
    torqueVector = (ct.c_float*3)()
    ret = c_ReadForceSensor(clientID, forceSensorHandle, ct.byref(state), forceVector, torqueVector, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(forceVector[i])
    arr2 = []
    for i in range(3):
        arr2.append(torqueVector[i])
    #if sys.version_info[0] == 3:
    #    state=state.value
    #else:
    #    state=ord(state.value)
    return ret, state.value, arr1, arr2

</t>
<t tx="leo.20210713140956.355">def simxBreakForceSensor(clientID, forceSensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_BreakForceSensor(clientID, forceSensorHandle, operationMode)

</t>
<t tx="leo.20210713140956.356">def simxReadVisionSensor(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    detectionState = ct.c_ubyte()
    auxValues      = ct.POINTER(ct.c_float)()
    auxValuesCount = ct.POINTER(ct.c_int)()
    ret = c_ReadVisionSensor(clientID, sensorHandle, ct.byref(detectionState), ct.byref(auxValues), ct.byref(auxValuesCount), operationMode)

    auxValues2 = []
    if ret == 0:
        s = 0
        for i in range(auxValuesCount[0]):
            auxValues2.append(auxValues[s:s+auxValuesCount[i+1]])
            s += auxValuesCount[i+1]

        #free C buffers
        c_ReleaseBuffer(auxValues)
        c_ReleaseBuffer(auxValuesCount)

    return ret, bool(detectionState.value!=0), auxValues2

</t>
<t tx="leo.20210713140956.357">def simxGetObjectHandle(clientID, objectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(objectName) is str):
        objectName=objectName.encode('utf-8')
    return c_GetObjectHandle(clientID, objectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.358">def simxGetVisionSensorImage(clientID, sensorHandle, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    resolution = (ct.c_int*2)()
    c_image  = ct.POINTER(ct.c_byte)()
    bytesPerPixel = 3
    if (options and 1) != 0:
        bytesPerPixel = 1
    ret = c_GetVisionSensorImage(clientID, sensorHandle, resolution, ct.byref(c_image), options, operationMode)

    reso = []
    image = []
    if (ret == 0):
        image = [None]*resolution[0]*resolution[1]*bytesPerPixel
        for i in range(resolution[0] * resolution[1] * bytesPerPixel):
            image[i] = c_image[i]
        for i in range(2):
            reso.append(resolution[i])
    return ret, reso, image

</t>
<t tx="leo.20210713140956.359">def simxSetVisionSensorImage(clientID, sensorHandle, image, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    size = len(image)
    image_bytes  = (ct.c_byte*size)(*image)
    return c_SetVisionSensorImage(clientID, sensorHandle, image_bytes, size, options, operationMode)

</t>
<t tx="leo.20210713140956.36">def _make_observation(self):
    """Query V-rep to make observation.
       The observation is stored in self.observation
    """
    # start with empty list
    lst_o = [];
    
    # #modify: optionally include positions or velocities
    pos               = self.obj_get_position(self.oh_shape[0])
    lin_vel , ang_vel = self.obj_get_velocity(self.oh_shape[0])
    lst_o += pos
    lst_o += lin_vel
    
    # #modify
    # example: include position, linear and angular velocities of all shapes
    for i_oh in self.oh_shape:
        rel_pos = self.obj_get_position(i_oh, relative_to=vrep.sim_handle_parent)
        lst_o += rel_pos ;
        lin_vel , ang_vel = self.obj_get_velocity(i_oh)
        lst_o += ang_vel ;
        lst_o += lin_vel ;
    
    self.observation = np.array(lst_o).astype('float32');

</t>
<t tx="leo.20210713140956.360">def simxGetVisionSensorDepthBuffer(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    c_buffer  = ct.POINTER(ct.c_float)()
    resolution = (ct.c_int*2)()
    ret = c_GetVisionSensorDepthBuffer(clientID, sensorHandle, resolution, ct.byref(c_buffer), operationMode)
    reso = []
    buffer = []
    if (ret == 0):
        buffer = [None]*resolution[0]*resolution[1]
        for i in range(resolution[0] * resolution[1]):
            buffer[i] = c_buffer[i]
        for i in range(2):
            reso.append(resolution[i])
    return ret, reso, buffer

</t>
<t tx="leo.20210713140956.361">def simxGetObjectChild(clientID, parentObjectHandle, childIndex, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    childObjectHandle = ct.c_int()
    return c_GetObjectChild(clientID, parentObjectHandle, childIndex, ct.byref(childObjectHandle), operationMode), childObjectHandle.value

</t>
<t tx="leo.20210713140956.362">def simxGetObjectParent(clientID, childObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parentObjectHandle = ct.c_int()
    return c_GetObjectParent(clientID, childObjectHandle, ct.byref(parentObjectHandle), operationMode), parentObjectHandle.value

</t>
<t tx="leo.20210713140956.363">def simxReadProximitySensor(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    detectionState = ct.c_ubyte()
    detectedObjectHandle = ct.c_int()
    detectedPoint  = (ct.c_float*3)()
    detectedSurfaceNormalVector = (ct.c_float*3)()
    ret = c_ReadProximitySensor(clientID, sensorHandle, ct.byref(detectionState), detectedPoint, ct.byref(detectedObjectHandle), detectedSurfaceNormalVector, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(detectedPoint[i])
    arr2 = []
    for i in range(3):
        arr2.append(detectedSurfaceNormalVector[i])
    return ret, bool(detectionState.value!=0), arr1, detectedObjectHandle.value, arr2

</t>
<t tx="leo.20210713140956.364">def simxLoadModel(clientID, modelPathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    baseHandle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(modelPathAndName) is str):
        modelPathAndName=modelPathAndName.encode('utf-8')
    return c_LoadModel(clientID, modelPathAndName, options, ct.byref(baseHandle), operationMode), baseHandle.value

</t>
<t tx="leo.20210713140956.365">def simxLoadUI(clientID, uiPathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    count = ct.c_int()
    uiHandles = ct.POINTER(ct.c_int)()
    if (sys.version_info[0] == 3) and (type(uiPathAndName) is str):
        uiPathAndName=uiPathAndName.encode('utf-8')
    ret = c_LoadUI(clientID, uiPathAndName, options, ct.byref(count), ct.byref(uiHandles), operationMode)

    handles = []
    if ret == 0:
        for i in range(count.value):
            handles.append(uiHandles[i])
        #free C buffers
        c_ReleaseBuffer(uiHandles)

    return ret, handles

</t>
<t tx="leo.20210713140956.366">def simxLoadScene(clientID, scenePathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(scenePathAndName) is str):
        scenePathAndName=scenePathAndName.encode('utf-8')
    return c_LoadScene(clientID, scenePathAndName, options, operationMode)

</t>
<t tx="leo.20210713140956.367">def simxStartSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_StartSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140956.368">def simxPauseSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_PauseSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140956.369">def simxStopSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_StopSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140956.37">def _make_action(self, a):
    """Query V-rep to make action.
       no return value
    """
    # #modify
    # example: set a velocity for each joint
    for i_oh, i_a in zip(self.oh_joint, a):
        self.obj_set_velocity(i_oh, i_a)

</t>
<t tx="leo.20210713140956.370">def simxGetUIHandle(clientID, uiName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(uiName) is str):
        uiName=uiName.encode('utf-8')
    return c_GetUIHandle(clientID, uiName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.371">def simxGetUISlider(clientID, uiHandle, uiButtonID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    position = ct.c_int()
    return c_GetUISlider(clientID, uiHandle, uiButtonID, ct.byref(position), operationMode), position.value

</t>
<t tx="leo.20210713140956.372">def simxSetUISlider(clientID, uiHandle, uiButtonID, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetUISlider(clientID, uiHandle, uiButtonID, position, operationMode)

</t>
<t tx="leo.20210713140956.373">def simxGetUIEventButton(clientID, uiHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    uiEventButtonID = ct.c_int()
    auxValues = (ct.c_int*2)()
    ret = c_GetUIEventButton(clientID, uiHandle, ct.byref(uiEventButtonID), auxValues, operationMode)
    arr = []
    for i in range(2):
        arr.append(auxValues[i])
    return ret, uiEventButtonID.value, arr

</t>
<t tx="leo.20210713140956.374">def simxGetUIButtonProperty(clientID, uiHandle, uiButtonID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    prop = ct.c_int()
    return c_GetUIButtonProperty(clientID, uiHandle, uiButtonID, ct.byref(prop), operationMode), prop.value

</t>
<t tx="leo.20210713140956.375">def simxSetUIButtonProperty(clientID, uiHandle, uiButtonID, prop, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetUIButtonProperty(clientID, uiHandle, uiButtonID, prop, operationMode)

</t>
<t tx="leo.20210713140956.376">def simxAddStatusbarMessage(clientID, message, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(message) is str):
        message=message.encode('utf-8')
    return c_AddStatusbarMessage(clientID, message, operationMode)

</t>
<t tx="leo.20210713140956.377">def simxAuxiliaryConsoleOpen(clientID, title, maxLines, mode, position, size, textColor, backgroundColor, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    consoleHandle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(title) is str):
        title=title.encode('utf-8')
    if position != None:
        c_position = (ct.c_int*2)(*position)
    else:
        c_position = None
    if size != None:
        c_size = (ct.c_int*2)(*size)
    else:
        c_size = None
    if textColor != None:
        c_textColor = (ct.c_float*3)(*textColor)
    else:
        c_textColor = None
    if backgroundColor != None:
        c_backgroundColor = (ct.c_float*3)(*backgroundColor)
    else:
        c_backgroundColor = None
    return c_AuxiliaryConsoleOpen(clientID, title, maxLines, mode, c_position, c_size, c_textColor, c_backgroundColor, ct.byref(consoleHandle), operationMode), consoleHandle.value

</t>
<t tx="leo.20210713140956.378">def simxAuxiliaryConsoleClose(clientID, consoleHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_AuxiliaryConsoleClose(clientID, consoleHandle, operationMode)

</t>
<t tx="leo.20210713140956.379">def simxAuxiliaryConsolePrint(clientID, consoleHandle, txt, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(txt) is str):
        txt=txt.encode('utf-8')
    return c_AuxiliaryConsolePrint(clientID, consoleHandle, txt, operationMode)

</t>
<t tx="leo.20210713140956.38">def step(self, action):
    """Gym environment 'step'
    """
    # #modify Either clip the actions outside the space or assert the space contains them
    # actions = np.clip(actions,-self.joints_max_velocity, self.joints_max_velocity)
    assert self.action_space.contains(action), "Action {} ({}) is invalid".format(action, type(action))
    
    # Actuate
    self._make_action(action)
    # Step
    self.step_simulation()
    # Observe
    self._make_observation()
    
    # Reward
    # #modify the reward computation
    # example: possible variables used in reward
    head_pos_x = self.observation[0] # front/back
    head_pos_y = self.observation[1] # left/right
    head_pos_z = self.observation[2] # up/down
    nrm_action  = np.linalg.norm(actions)
    r_regul     = -(nrm_action**2)
    r_alive = 1.0
    # example: different weights in reward
    reward = (8.0)*(r_alive) +(4.0)*(head_pos_x) +(1.0)*(head_pos_z)
    
    # Early stop
    # #modify if the episode should end earlier
    tolerable_threshold = 0.20
    done = (head_pos_z &lt; tolerable_threshold)
    #done = False
    
    return self.observation, reward, done, {}

</t>
<t tx="leo.20210713140956.380">def simxAuxiliaryConsoleShow(clientID, consoleHandle, showState, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_AuxiliaryConsoleShow(clientID, consoleHandle, showState, operationMode)

</t>
<t tx="leo.20210713140956.381">def simxGetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    eulerAngles = (ct.c_float*3)()
    ret = c_GetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, eulerAngles, operationMode)
    arr = []
    for i in range(3):
        arr.append(eulerAngles[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.382">def simxGetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    quaternion = (ct.c_float*4)()
    ret = c_GetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quaternion, operationMode)
    arr = []
    for i in range(4):
        arr.append(quaternion[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.383">def simxGetObjectPosition(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    position = (ct.c_float*3)()
    ret = c_GetObjectPosition(clientID, objectHandle, relativeToObjectHandle, position, operationMode)
    arr = []
    for i in range(3):
        arr.append(position[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.384">def simxSetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, eulerAngles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    angles = (ct.c_float*3)(*eulerAngles)
    return c_SetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, angles, operationMode)

</t>
<t tx="leo.20210713140956.385">def simxSetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quaternion, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    quat = (ct.c_float*4)(*quaternion)
    return c_SetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quat, operationMode)

</t>
<t tx="leo.20210713140956.386">def simxSetObjectPosition(clientID, objectHandle, relativeToObjectHandle, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_position = (ct.c_float*3)(*position)
    return c_SetObjectPosition(clientID, objectHandle, relativeToObjectHandle, c_position, operationMode)

</t>
<t tx="leo.20210713140956.387">def simxSetObjectParent(clientID, objectHandle, parentObject, keepInPlace, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectParent(clientID, objectHandle, parentObject, keepInPlace, operationMode)

</t>
<t tx="leo.20210713140956.388">def simxSetUIButtonLabel(clientID, uiHandle, uiButtonID, upStateLabel, downStateLabel, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        if type(upStateLabel) is str:
            upStateLabel=upStateLabel.encode('utf-8')
        if type(downStateLabel) is str:
            downStateLabel=downStateLabel.encode('utf-8')
    return c_SetUIButtonLabel(clientID, uiHandle, uiButtonID, upStateLabel, downStateLabel, operationMode)

</t>
<t tx="leo.20210713140956.389">def simxGetLastErrors(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    errors =[]
    errorCnt = ct.c_int()
    errorStrings = ct.POINTER(ct.c_char)()
    ret = c_GetLastErrors(clientID, ct.byref(errorCnt), ct.byref(errorStrings), operationMode)
    if ret == 0:
        s = 0
        for i in range(errorCnt.value):
            a = bytearray()
            while errorStrings[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(errorStrings[s],'big'))
                else:
                    a.append(errorStrings[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                errors.append(str(a,'utf-8'))
            else:
                errors.append(str(a))

    return ret, errors

</t>
<t tx="leo.20210713140956.39">def reset(self):
    """Gym environment 'reset'
    """
    if self.sim_running:
        self.stop_simulation()
    self.start_simulation()
    self._make_observation()
    return self.observation

</t>
<t tx="leo.20210713140956.390">def simxGetArrayParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    paramValues = (ct.c_float*3)()
    ret = c_GetArrayParameter(clientID, paramIdentifier, paramValues, operationMode)
    arr = []
    for i in range(3):
        arr.append(paramValues[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.391">def simxSetArrayParameter(clientID, paramIdentifier, paramValues, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_paramValues = (ct.c_float*3)(*paramValues)
    return c_SetArrayParameter(clientID, paramIdentifier, c_paramValues, operationMode)

</t>
<t tx="leo.20210713140956.392">def simxGetBooleanParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_ubyte()
    return c_GetBooleanParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), bool(paramValue.value!=0)

</t>
<t tx="leo.20210713140956.393">def simxSetBooleanParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetBooleanParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140956.394">def simxGetIntegerParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_int()
    return c_GetIntegerParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), paramValue.value

</t>
<t tx="leo.20210713140956.395">def simxSetIntegerParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetIntegerParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140956.396">def simxGetFloatingParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_float()
    return c_GetFloatingParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), paramValue.value

</t>
<t tx="leo.20210713140956.397">def simxSetFloatingParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetFloatingParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140956.398">def simxGetStringParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    paramValue = ct.POINTER(ct.c_char)()
    ret = c_GetStringParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode)

    a = bytearray()
    if ret == 0:
        i = 0
        while paramValue[i] != b'\0':
            if sys.version_info[0] == 3:
                a.append(int.from_bytes(paramValue[i],'big'))
            else:
                a.append(paramValue[i])
            i=i+1
    if sys.version_info[0] == 3:
        a=str(a,'utf-8')
    else:
        a=str(a)
    return ret, a

</t>
<t tx="leo.20210713140956.399">def simxGetCollisionHandle(clientID, collisionObjectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(collisionObjectName) is str):
        collisionObjectName=collisionObjectName.encode('utf-8')
    return c_GetCollisionHandle(clientID, collisionObjectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.4">from setuptools import setup, find_packages
# 已經改為 remoteApi.dll

install_requires=[
    'gym',
    'numpy'
]

setup(name='vrep_env',
      version='0.0.2',
      description='V-REP integrated with OpenAI Gym',
      url='https://github.com/ycps/vrep-env',
      packages=[package for package in find_packages() if package.startswith('vrep_env')],
      install_requires=install_requires,
      package_data={'': ['remoteApi.dll']},
      include_package_data=True
)
</t>
<t tx="leo.20210713140956.40">def render(self, mode='human', close=False):
    """Gym environment 'render'
    """
    pass

</t>
<t tx="leo.20210713140956.400">def simxGetCollectionHandle(clientID, collectionName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(collectionName) is str):
        collectionName=collectionName.encode('utf-8')
    return c_GetCollectionHandle(clientID, collectionName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.401">def simxGetDistanceHandle(clientID, distanceObjectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(distanceObjectName) is str):
        distanceObjectName=distanceObjectName.encode('utf-8')
    return c_GetDistanceHandle(clientID, distanceObjectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.402">def simxReadCollision(clientID, collisionObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    collisionState = ct.c_ubyte()
    return c_ReadCollision(clientID, collisionObjectHandle, ct.byref(collisionState), operationMode), bool(collisionState.value!=0)

</t>
<t tx="leo.20210713140956.403">def simxReadDistance(clientID, distanceObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    minimumDistance = ct.c_float()
    return c_ReadDistance(clientID, distanceObjectHandle, ct.byref(minimumDistance), operationMode), minimumDistance.value

</t>
<t tx="leo.20210713140956.404">def simxRemoveObject(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveObject(clientID, objectHandle, operationMode)

</t>
<t tx="leo.20210713140956.405">def simxRemoveModel(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveModel(clientID, objectHandle, operationMode)

</t>
<t tx="leo.20210713140956.406">def simxRemoveUI(clientID, uiHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveUI(clientID, uiHandle, operationMode)

</t>
<t tx="leo.20210713140956.407">def simxCloseScene(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_CloseScene(clientID, operationMode)

</t>
<t tx="leo.20210713140956.408">def simxGetObjects(clientID, objectType, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    objectCount = ct.c_int()
    objectHandles = ct.POINTER(ct.c_int)()

    ret = c_GetObjects(clientID, objectType, ct.byref(objectCount), ct.byref(objectHandles), operationMode)
    handles = []
    if ret == 0:
        for i in range(objectCount.value):
            handles.append(objectHandles[i])

    return ret, handles


</t>
<t tx="leo.20210713140956.409">def simxDisplayDialog(clientID, titleText, mainText, dialogType, initialText, titleColors, dialogColors, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    if titleColors != None:
        c_titleColors  = (ct.c_float*6)(*titleColors)
    else:
        c_titleColors  = None
    if dialogColors != None:
        c_dialogColors  = (ct.c_float*6)(*dialogColors)
    else:
        c_dialogColors  = None

    c_dialogHandle = ct.c_int()
    c_uiHandle = ct.c_int()
    if sys.version_info[0] == 3:
        if type(titleText) is str:
            titleText=titleText.encode('utf-8')
        if type(mainText) is str:
            mainText=mainText.encode('utf-8')
        if type(initialText) is str:
            initialText=initialText.encode('utf-8')
    return c_DisplayDialog(clientID, titleText, mainText, dialogType, initialText, c_titleColors, c_dialogColors, ct.byref(c_dialogHandle), ct.byref(c_uiHandle), operationMode), c_dialogHandle.value, c_uiHandle.value

</t>
<t tx="leo.20210713140956.41">def seed(self, seed=None):
    """Gym environment 'seed'
    """
    return []

</t>
<t tx="leo.20210713140956.410">def simxEndDialog(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_EndDialog(clientID, dialogHandle, operationMode)

</t>
<t tx="leo.20210713140956.411">def simxGetDialogInput(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    inputText = ct.POINTER(ct.c_char)()
    ret = c_GetDialogInput(clientID, dialogHandle, ct.byref(inputText), operationMode)

    a = bytearray()
    if ret == 0:
        i = 0
        while inputText[i] != b'\0':
            if sys.version_info[0] == 3:
                a.append(int.from_bytes(inputText[i],'big'))
            else:
                a.append(inputText[i])
            i = i+1

    if sys.version_info[0] == 3:
        a=str(a,'utf-8')
    else:
        a=str(a)
    return ret, a


</t>
<t tx="leo.20210713140956.412">def simxGetDialogResult(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    result = ct.c_int()
    return c_GetDialogResult(clientID, dialogHandle, ct.byref(result), operationMode), result.value

</t>
<t tx="leo.20210713140956.413">def simxCopyPasteObjects(clientID, objectHandles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    c_objectHandles  = (ct.c_int*len(objectHandles))(*objectHandles)
    c_objectHandles = ct.cast(c_objectHandles,ct.POINTER(ct.c_int)) # IronPython needs this
    newObjectCount   = ct.c_int()
    newObjectHandles = ct.POINTER(ct.c_int)()
    ret = c_CopyPasteObjects(clientID, c_objectHandles, len(objectHandles), ct.byref(newObjectHandles), ct.byref(newObjectCount), operationMode)

    newobj = []
    if ret == 0:
        for i in range(newObjectCount.value):
            newobj.append(newObjectHandles[i])

    return ret, newobj


</t>
<t tx="leo.20210713140956.414">def simxGetObjectSelection(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    objectCount   = ct.c_int()
    objectHandles = ct.POINTER(ct.c_int)()
    ret = c_GetObjectSelection(clientID, ct.byref(objectHandles), ct.byref(objectCount), operationMode)

    newobj = []
    if ret == 0:
        for i in range(objectCount.value):
            newobj.append(objectHandles[i])

    return ret, newobj



</t>
<t tx="leo.20210713140956.415">def simxSetObjectSelection(clientID, objectHandles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_objectHandles  = (ct.c_int*len(objectHandles))(*objectHandles)
    return c_SetObjectSelection(clientID, c_objectHandles, len(objectHandles), operationMode)

</t>
<t tx="leo.20210713140956.416">def simxClearFloatSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearFloatSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140956.417">def simxClearIntegerSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearIntegerSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140956.418">def simxClearStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearStringSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140956.419">def simxGetFloatSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalValue = ct.c_float()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_GetFloatSignal(clientID, signalName, ct.byref(signalValue), operationMode), signalValue.value

</t>
<t tx="leo.20210713140956.42">def main(args):
    """main function used as test and example.
       Agent does random actions with 'action_space.sample()'
    """
    # #modify: the env class name
    env = ExampleVrepEnv()
    for i_episode in range(8):
        observation = env.reset()
        total_reward = 0
        for t in range(256):
            action = env.action_space.sample()
            observation, reward, done, _ = env.step(action)
            total_reward += reward
            if done:
                break
        print("Episode finished after {} timesteps.\tTotal reward: {}".format(t+1,total_reward))
    env.close()
    return 0

</t>
<t tx="leo.20210713140956.420">def simxGetIntegerSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalValue = ct.c_int()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_GetIntegerSignal(clientID, signalName, ct.byref(signalValue), operationMode), signalValue.value

</t>
<t tx="leo.20210713140956.421">def simxGetStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_GetStringSignal(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.422">def simxGetAndClearStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_GetAndClearStringSignal(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.423">def simxReadStringStream(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_ReadStringStream(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.424">def simxSetFloatSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_SetFloatSignal(clientID, signalName, signalValue, operationMode)

</t>
<t tx="leo.20210713140956.425">def simxSetIntegerSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_SetIntegerSignal(clientID, signalName, signalValue, operationMode)

</t>
<t tx="leo.20210713140956.426">def simxSetStringSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_SetStringSignal(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140956.427">def simxAppendStringSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_AppendStringSignal(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140956.428">def simxWriteStringStream(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_WriteStringStream(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140956.429">def simxGetObjectFloatParameter(clientID, objectHandle, parameterID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parameterValue = ct.c_float()
    return c_GetObjectFloatParameter(clientID, objectHandle, parameterID, ct.byref(parameterValue), operationMode), parameterValue.value

</t>
<t tx="leo.20210713140956.43">
@others
if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))

@language python
@tabwidth -4

</t>
<t tx="leo.20210713140956.430">def simxSetObjectFloatParameter(clientID, objectHandle, parameterID, parameterValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectFloatParameter(clientID, objectHandle, parameterID, parameterValue, operationMode)

</t>
<t tx="leo.20210713140956.431">def simxGetObjectIntParameter(clientID, objectHandle, parameterID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parameterValue = ct.c_int()
    return c_GetObjectIntParameter(clientID, objectHandle, parameterID, ct.byref(parameterValue), operationMode), parameterValue.value

</t>
<t tx="leo.20210713140956.432">def simxSetObjectIntParameter(clientID, objectHandle, parameterID, parameterValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectIntParameter(clientID, objectHandle, parameterID, parameterValue, operationMode)

</t>
<t tx="leo.20210713140956.433">def simxGetModelProperty(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    prop = ct.c_int()
    return c_GetModelProperty(clientID, objectHandle, ct.byref(prop), operationMode), prop.value

</t>
<t tx="leo.20210713140956.434">def simxSetModelProperty(clientID, objectHandle, prop, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetModelProperty(clientID, objectHandle, prop, operationMode)

</t>
<t tx="leo.20210713140956.435">def simxStart(connectionAddress, connectionPort, waitUntilConnected, doNotReconnectOnceDisconnected, timeOutInMs, commThreadCycleInMs):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(connectionAddress) is str):
        connectionAddress=connectionAddress.encode('utf-8')
    return c_Start(connectionAddress, connectionPort, waitUntilConnected, doNotReconnectOnceDisconnected, timeOutInMs, commThreadCycleInMs)

</t>
<t tx="leo.20210713140956.436">def simxFinish(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_Finish(clientID)

</t>
<t tx="leo.20210713140956.437">def simxGetPingTime(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    pingTime = ct.c_int()
    return c_GetPingTime(clientID, ct.byref(pingTime)), pingTime.value

</t>
<t tx="leo.20210713140956.438">def simxGetLastCmdTime(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_GetLastCmdTime(clientID)

</t>
<t tx="leo.20210713140956.439">def simxSynchronousTrigger(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SynchronousTrigger(clientID)

</t>
<t tx="leo.20210713140956.44">from vrep_env import vrep_env

import os
# vrep_scenes_path = os.environ['VREP_SCENES_PATH']
vrep_scenes_path = "C:/tmp/vrep-env/examples/scenes"

import gym
from gym import spaces
from gym.utils import seeding
import numpy as np


</t>
<t tx="leo.20210713140956.440">def simxSynchronous(clientID, enable):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_Synchronous(clientID, enable)

</t>
<t tx="leo.20210713140956.441">def simxPauseCommunication(clientID, enable):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_PauseCommunication(clientID, enable)

</t>
<t tx="leo.20210713140956.442">def simxGetInMessageInfo(clientID, infoType):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    info = ct.c_int()
    return c_GetInMessageInfo(clientID, infoType, ct.byref(info)), info.value

</t>
<t tx="leo.20210713140956.443">def simxGetOutMessageInfo(clientID, infoType):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    info = ct.c_int()
    return c_GetOutMessageInfo(clientID, infoType, ct.byref(info)), info.value

</t>
<t tx="leo.20210713140956.444">def simxGetConnectionId(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_GetConnectionId(clientID)

</t>
<t tx="leo.20210713140956.445">def simxCreateBuffer(bufferSize):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_CreateBuffer(bufferSize)

</t>
<t tx="leo.20210713140956.446">def simxReleaseBuffer(buffer):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_ReleaseBuffer(buffer)

</t>
<t tx="leo.20210713140956.447">def simxTransferFile(clientID, filePathAndName, fileName_serverSide, timeOut, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(filePathAndName) is str):
        filePathAndName=filePathAndName.encode('utf-8')
    return c_TransferFile(clientID, filePathAndName, fileName_serverSide, timeOut, operationMode)

</t>
<t tx="leo.20210713140956.448">def simxEraseFile(clientID, fileName_serverSide, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(fileName_serverSide) is str):
        fileName_serverSide=fileName_serverSide.encode('utf-8')
    return c_EraseFile(clientID, fileName_serverSide, operationMode)

</t>
<t tx="leo.20210713140956.449">def simxCreateDummy(clientID, size, color, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if color != None:
        c_color = (ct.c_ubyte*12)(*color)
    else:
        c_color = None
    return c_CreateDummy(clientID, size, c_color, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.45">class HopperVrepEnv(vrep_env.VrepEnv):
    metadata = {'render.modes': [],}
    @others
</t>
<t tx="leo.20210713140956.450">def simxQuery(clientID, signalName, signalValue, retSignalName, timeOutInMs):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    retSignalLength = ct.c_int();
    retSignalValue = ct.POINTER(ct.c_ubyte)()

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(retSignalName) is str:
            retSignalName=retSignalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this

    ret = c_Query(clientID, signalName, sigV, len(signalValue), retSignalName, ct.byref(retSignalValue), ct.byref(retSignalLength), timeOutInMs)

    a = bytearray()
    if ret == 0:
        for i in range(retSignalLength.value):
            a.append(retSignalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140956.451">def simxGetObjectGroupData(clientID, objectType, dataType, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handles =[]
    intData =[]
    floatData =[]
    stringData =[]
    handlesC = ct.c_int()
    handlesP = ct.POINTER(ct.c_int)()
    intDataC = ct.c_int()
    intDataP = ct.POINTER(ct.c_int)()
    floatDataC = ct.c_int()
    floatDataP = ct.POINTER(ct.c_float)()
    stringDataC = ct.c_int()
    stringDataP = ct.POINTER(ct.c_char)()
    ret = c_GetObjectGroupData(clientID, objectType, dataType, ct.byref(handlesC), ct.byref(handlesP), ct.byref(intDataC), ct.byref(intDataP), ct.byref(floatDataC), ct.byref(floatDataP), ct.byref(stringDataC), ct.byref(stringDataP), operationMode)

    if ret == 0:
        for i in range(handlesC.value):
            handles.append(handlesP[i])
        for i in range(intDataC.value):
            intData.append(intDataP[i])
        for i in range(floatDataC.value):
            floatData.append(floatDataP[i])
        s = 0
        for i in range(stringDataC.value):
            a = bytearray()
            while stringDataP[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(stringDataP[s],'big'))
                else:
                    a.append(stringDataP[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                a=str(a,'utf-8')
            else:
                a=str(a)
            stringData.append(a)

    return ret, handles, intData, floatData, stringData

</t>
<t tx="leo.20210713140956.452">def simxCallScriptFunction(clientID, scriptDescription, options, functionName, inputInts, inputFloats, inputStrings, inputBuffer, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    inputBufferV=inputBuffer
    if sys.version_info[0] == 3:
        if type(scriptDescription) is str:
            scriptDescription=scriptDescription.encode('utf-8')
        if type(functionName) is str:
            functionName=functionName.encode('utf-8')
        if type(inputBuffer) is bytearray:
            inputBufferV  = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
        if type(inputBuffer) is str:
            inputBuffer=inputBuffer.encode('utf-8')
            inputBufferV  = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
    else:
        if type(inputBuffer) is bytearray:
            inputBufferV = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
        if type(inputBuffer) is str:
            inputBuffer=bytearray(inputBuffer)
            inputBufferV = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
    inputBufferV=ct.cast(inputBufferV,ct.POINTER(ct.c_ubyte)) # IronPython needs this

    c_inInts  = (ct.c_int*len(inputInts))(*inputInts)
    c_inInts = ct.cast(c_inInts,ct.POINTER(ct.c_int)) # IronPython needs this
    c_inFloats  = (ct.c_float*len(inputFloats))(*inputFloats)
    c_inFloats = ct.cast(c_inFloats,ct.POINTER(ct.c_float)) # IronPython needs this

    concatStr=''.encode('utf-8')
    for i in range(len(inputStrings)):
        a=inputStrings[i]
        a=a+'\0'
        if type(a) is str:
            a=a.encode('utf-8')
        concatStr=concatStr+a
    c_inStrings  = (ct.c_char*len(concatStr))(*concatStr)

    intDataOut =[]
    floatDataOut =[]
    stringDataOut =[]
    bufferOut =bytearray()

    intDataC = ct.c_int()
    intDataP = ct.POINTER(ct.c_int)()
    floatDataC = ct.c_int()
    floatDataP = ct.POINTER(ct.c_float)()
    stringDataC = ct.c_int()
    stringDataP = ct.POINTER(ct.c_char)()
    bufferS = ct.c_int()
    bufferP = ct.POINTER(ct.c_ubyte)()

    ret = c_CallScriptFunction(clientID,scriptDescription,options,functionName,len(inputInts),c_inInts,len(inputFloats),c_inFloats,len(inputStrings),c_inStrings,len(inputBuffer),inputBufferV,ct.byref(intDataC),ct.byref(intDataP),ct.byref(floatDataC),ct.byref(floatDataP),ct.byref(stringDataC),ct.byref(stringDataP),ct.byref(bufferS),ct.byref(bufferP),operationMode)

    if ret == 0:
        for i in range(intDataC.value):
            intDataOut.append(intDataP[i])
        for i in range(floatDataC.value):
            floatDataOut.append(floatDataP[i])
        s = 0
        for i in range(stringDataC.value):
            a = bytearray()
            while stringDataP[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(stringDataP[s],'big'))
                else:
                    a.append(stringDataP[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                a=str(a,'utf-8')
            else:
                a=str(a)
            stringDataOut.append(a)
        for i in range(bufferS.value):
            bufferOut.append(bufferP[i])
    if sys.version_info[0] != 3:
        bufferOut=str(bufferOut)

    return ret, intDataOut, floatDataOut, stringDataOut, bufferOut

</t>
<t tx="leo.20210713140956.453">def simxGetObjectVelocity(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    linearVel  = (ct.c_float*3)()
    angularVel = (ct.c_float*3)()
    ret = c_GetObjectVelocity(clientID, objectHandle, linearVel, angularVel, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(linearVel[i])
    arr2 = []
    for i in range(3):
        arr2.append(angularVel[i])
    return ret, arr1, arr2

</t>
<t tx="leo.20210713140956.454">def simxPackInts(intList):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        s=bytes()
        for i in range(len(intList)):
            s=s+struct.pack('&lt;i',intList[i])
        s=bytearray(s)
    else:
        s=''
        for i in range(len(intList)):
            s+=struct.pack('&lt;i',intList[i])
    return s

</t>
<t tx="leo.20210713140956.455">def simxUnpackInts(intsPackedInString):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    b=[]
    for i in range(int(len(intsPackedInString)/4)):
        b.append(struct.unpack('&lt;i',intsPackedInString[4*i:4*(i+1)])[0])
    return b

</t>
<t tx="leo.20210713140956.456">def simxPackFloats(floatList):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        s=bytes()
        for i in range(len(floatList)):
            s=s+struct.pack('&lt;f',floatList[i])
        s=bytearray(s)
    else:
        s=''
        for i in range(len(floatList)):
            s+=struct.pack('&lt;f',floatList[i])
    return s

</t>
<t tx="leo.20210713140956.457">def simxUnpackFloats(floatsPackedInString):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    b=[]
    for i in range(int(len(floatsPackedInString)/4)):
        b.append(struct.unpack('&lt;f',floatsPackedInString[4*i:4*(i+1)])[0])
    return b
</t>
<t tx="leo.20210713140956.458">
#constants
#Scene object types. Values are serialized
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210713140956.459">sim_object_shape_type           =0
sim_object_joint_type           =1
sim_object_graph_type           =2
sim_object_camera_type          =3
sim_object_dummy_type           =4
sim_object_proximitysensor_type =5
sim_object_reserved1            =6
sim_object_reserved2            =7
sim_object_path_type            =8
sim_object_visionsensor_type    =9
sim_object_volume_type          =10
sim_object_mill_type            =11
sim_object_forcesensor_type     =12
sim_object_light_type           =13
sim_object_mirror_type          =14

#General object types. Values are serialized
sim_appobj_object_type          =109
sim_appobj_collision_type       =110
sim_appobj_distance_type        =111
sim_appobj_simulation_type      =112
sim_appobj_ik_type              =113
sim_appobj_constraintsolver_type=114
sim_appobj_collection_type      =115
sim_appobj_ui_type              =116
sim_appobj_script_type          =117
sim_appobj_pathplanning_type    =118
sim_appobj_RESERVED_type        =119
sim_appobj_texture_type         =120

# Ik calculation methods. Values are serialized
sim_ik_pseudo_inverse_method        =0
sim_ik_damped_least_squares_method  =1
sim_ik_jacobian_transpose_method    =2

# Ik constraints. Values are serialized
sim_ik_x_constraint         =1
sim_ik_y_constraint         =2
sim_ik_z_constraint         =4
sim_ik_alpha_beta_constraint=8
sim_ik_gamma_constraint     =16
sim_ik_avoidance_constraint =64

# Ik calculation results 
sim_ikresult_not_performed  =0
sim_ikresult_success        =1
sim_ikresult_fail           =2

# Scene object sub-types. Values are serialized 
# Light sub-types 
sim_light_omnidirectional_subtype   =1
sim_light_spot_subtype              =2
sim_light_directional_subtype       =3
# Joint sub-types 
sim_joint_revolute_subtype          =10
sim_joint_prismatic_subtype         =11
sim_joint_spherical_subtype         =12
# Shape sub-types 
sim_shape_simpleshape_subtype       =20
sim_shape_multishape_subtype        =21
# Proximity sensor sub-types 
sim_proximitysensor_pyramid_subtype =30
sim_proximitysensor_cylinder_subtype=31
sim_proximitysensor_disc_subtype    =32
sim_proximitysensor_cone_subtype    =33
sim_proximitysensor_ray_subtype     =34
# Mill sub-types 
sim_mill_pyramid_subtype            =40
sim_mill_cylinder_subtype           =41
sim_mill_disc_subtype               =42
sim_mill_cone_subtype               =42
# No sub-type 
sim_object_no_subtype               =200


#Scene object main properties (serialized)
sim_objectspecialproperty_collidable                    =0x0001
sim_objectspecialproperty_measurable                    =0x0002
#reserved                        =0x0004 
#reserved                        =0x0008 
sim_objectspecialproperty_detectable_ultrasonic            =0x0010
sim_objectspecialproperty_detectable_infrared            =0x0020
sim_objectspecialproperty_detectable_laser                =0x0040
sim_objectspecialproperty_detectable_inductive            =0x0080
sim_objectspecialproperty_detectable_capacitive            =0x0100
sim_objectspecialproperty_renderable                    =0x0200
sim_objectspecialproperty_detectable_all =sim_objectspecialproperty_detectable_ultrasonic|sim_objectspecialproperty_detectable_infrared|sim_objectspecialproperty_detectable_laser|sim_objectspecialproperty_detectable_inductive|sim_objectspecialproperty_detectable_capacitive
sim_objectspecialproperty_cuttable                        =0x0400
sim_objectspecialproperty_pathplanning_ignored            =0x0800

# Model properties (serialized)
sim_modelproperty_not_collidable                =0x0001
sim_modelproperty_not_measurable                =0x0002
sim_modelproperty_not_renderable                =0x0004
sim_modelproperty_not_detectable                =0x0008
sim_modelproperty_not_cuttable                    =0x0010
sim_modelproperty_not_dynamic                    =0x0020
sim_modelproperty_not_respondable                =0x0040 # cannot be selected if sim_modelproperty_not_dynamic is not selected 
sim_modelproperty_not_reset                        =0x0080 # Model is not reset at simulation end. This flag is cleared at simulation end 
sim_modelproperty_not_visible                    =0x0100 # Whole model is invisible independent of local visibility settings 
sim_modelproperty_not_model                        =0xf000 # object is not a model 


# Check the documentation instead of comments below!! 
# Following messages are dispatched to the Lua-message container 
sim_message_ui_button_state_change  =0    # a UI button slider etc. changed (due to a user's action). aux[0]=UI handle aux[1]=button handle aux[2]=button attributes aux[3]=slider position (if slider) 
sim_message_reserved9               =1    # Do not use 
sim_message_object_selection_changed=2
sim_message_reserved10                =3    # do not use 
sim_message_model_loaded            =4
sim_message_reserved11                =5    # do not use 
sim_message_keypress                =6    # a key was pressed while the focus was on a page (aux[0]=key aux[1]=ctrl and shift key state) 
sim_message_bannerclicked            =7    # a banner was clicked (aux[0]=banner ID) 


# Following messages are dispatched only to the C-API (not available from Lua) 
sim_message_for_c_api_only_start        =0x100      # Do not use 
sim_message_reserved1                   =0x101      # Do not use 
sim_message_reserved2                    =0x102      # Do not use 
sim_message_reserved3                    =0x103      # Do not use 
sim_message_eventcallback_scenesave        =0x104        # about to save a scene 
sim_message_eventcallback_modelsave        =0x105      # about to save a model (current selection will be saved) 
sim_message_eventcallback_moduleopen    =0x106        # called when simOpenModule in Lua is called 
sim_message_eventcallback_modulehandle    =0x107        # called when simHandleModule in Lua is called with argument false 
sim_message_eventcallback_moduleclose    =0x108        # called when simCloseModule in Lua is called 
sim_message_reserved4                    =0x109      # Do not use 
sim_message_reserved5                    =0x10a        # Do not use 
sim_message_reserved6                    =0x10b        # Do not use 
sim_message_reserved7                    =0x10c        # Do not use 
sim_message_eventcallback_instancepass    =0x10d        # Called once every main application loop pass. auxiliaryData[0] contains event flags of events that happened since last time 
sim_message_eventcallback_broadcast     =0x10e
sim_message_eventcallback_imagefilter_enumreset =0x10f
sim_message_eventcallback_imagefilter_enumerate      =0x110
sim_message_eventcallback_imagefilter_adjustparams   =0x111
sim_message_eventcallback_imagefilter_reserved       =0x112
sim_message_eventcallback_imagefilter_process        =0x113
sim_message_eventcallback_reserved1                  =0x114   # do not use 
sim_message_eventcallback_reserved2                  =0x115   # do not use 
sim_message_eventcallback_reserved3                  =0x116   # do not use 
sim_message_eventcallback_reserved4                  =0x117   # do not use 
sim_message_eventcallback_abouttoundo                 =0x118   # the undo button was hit and a previous state is about to be restored 
sim_message_eventcallback_undoperformed                 =0x119   # the undo button was hit and a previous state restored 
sim_message_eventcallback_abouttoredo                 =0x11a   # the redo button was hit and a future state is about to be restored  
sim_message_eventcallback_redoperformed                 =0x11b   # the redo button was hit and a future state restored  
sim_message_eventcallback_scripticondblclick         =0x11c   # scipt icon was double clicked.  (aux[0]=object handle associated with script set replyData[0] to 1 if script should not be opened)  
sim_message_eventcallback_simulationabouttostart     =0x11d
sim_message_eventcallback_simulationended            =0x11e
sim_message_eventcallback_reserved5                     =0x11f   # do not use 
sim_message_eventcallback_keypress                     =0x120   # a key was pressed while the focus was on a page (aux[0]=key aux[1]=ctrl and shift key state) 
sim_message_eventcallback_modulehandleinsensingpart  =0x121   # called when simHandleModule in Lua is called with argument true 
sim_message_eventcallback_renderingpass              =0x122   # called just before the scene is rendered 
sim_message_eventcallback_bannerclicked              =0x123   # called when a banner was clicked (aux[0]=banner ID) 
sim_message_eventcallback_menuitemselected           =0x124   # auxiliaryData[0] indicates the handle of the item auxiliaryData[1] indicates the state of the item 
sim_message_eventcallback_refreshdialogs             =0x125   # aux[0]=refresh degree (0=light 1=medium 2=full) 
sim_message_eventcallback_sceneloaded                =0x126
sim_message_eventcallback_modelloaded                =0x127
sim_message_eventcallback_instanceswitch             =0x128
sim_message_eventcallback_guipass                    =0x129
sim_message_eventcallback_mainscriptabouttobecalled  =0x12a
sim_message_eventcallback_rmlposition                =0x12b   #the command simRMLPosition was called. The appropriate plugin should handle the call
sim_message_eventcallback_rmlvelocity                =0x12c   # the command simRMLVelocity was called. The appropriate plugin should handle the call
sim_message_simulation_start_resume_request          =0x1000
sim_message_simulation_pause_request                 =0x1001
sim_message_simulation_stop_request                  =0x1002

# Scene object properties. Combine with the | operator 
sim_objectproperty_reserved1                =0x0000
sim_objectproperty_reserved2                =0x0001
sim_objectproperty_reserved3                =0x0002
sim_objectproperty_reserved4                =0x0003
sim_objectproperty_reserved5                =0x0004 # formely sim_objectproperty_visible 
sim_objectproperty_reserved6                =0x0008 # formely sim_objectproperty_wireframe 
sim_objectproperty_collapsed                =0x0010
sim_objectproperty_selectable                =0x0020
sim_objectproperty_reserved7                =0x0040
sim_objectproperty_selectmodelbaseinstead    =0x0080
sim_objectproperty_dontshowasinsidemodel    =0x0100
# reserved                                    =0x0200 
sim_objectproperty_canupdatedna                =0x0400
sim_objectproperty_selectinvisible            =0x0800
sim_objectproperty_depthinvisible            =0x1000


# type of arguments (input and output) for custom lua commands 
sim_lua_arg_nil     =0
sim_lua_arg_bool    =1    
sim_lua_arg_int     =2
sim_lua_arg_float   =3
sim_lua_arg_string  =4
sim_lua_arg_invalid =5
sim_lua_arg_table   =8

# custom user interface properties. Values are serialized. 
sim_ui_property_visible                        =0x0001
sim_ui_property_visibleduringsimulationonly    =0x0002
sim_ui_property_moveable                    =0x0004
sim_ui_property_relativetoleftborder        =0x0008
sim_ui_property_relativetotopborder            =0x0010
sim_ui_property_fixedwidthfont                =0x0020
sim_ui_property_systemblock                    =0x0040
sim_ui_property_settocenter                    =0x0080
sim_ui_property_rolledup                    =0x0100
sim_ui_property_selectassociatedobject        =0x0200
sim_ui_property_visiblewhenobjectselected    =0x0400


# button properties. Values are serialized. 
sim_buttonproperty_button                =0x0000
sim_buttonproperty_label                =0x0001
sim_buttonproperty_slider                =0x0002
sim_buttonproperty_editbox                =0x0003
sim_buttonproperty_staydown                =0x0008
sim_buttonproperty_enabled                =0x0010
sim_buttonproperty_borderless            =0x0020
sim_buttonproperty_horizontallycentered    =0x0040
sim_buttonproperty_ignoremouse            =0x0080
sim_buttonproperty_isdown                =0x0100
sim_buttonproperty_transparent            =0x0200
sim_buttonproperty_nobackgroundcolor    =0x0400
sim_buttonproperty_rollupaction            =0x0800
sim_buttonproperty_closeaction            =0x1000
sim_buttonproperty_verticallycentered    =0x2000
sim_buttonproperty_downupevent            =0x4000


# Simulation status 
sim_simulation_stopped                        =0x00                                # Simulation is stopped 
sim_simulation_paused                        =0x08                                # Simulation is paused 
sim_simulation_advancing                    =0x10                                # Simulation is advancing 
sim_simulation_advancing_firstafterstop        =sim_simulation_advancing|0x00        # First simulation pass (1x) 
sim_simulation_advancing_running            =sim_simulation_advancing|0x01        # Normal simulation pass (&gt;=1x) 
# reserved                                    =sim_simulation_advancing|0x02 
sim_simulation_advancing_lastbeforepause    =sim_simulation_advancing|0x03        # Last simulation pass before pause (1x) 
sim_simulation_advancing_firstafterpause    =sim_simulation_advancing|0x04        # First simulation pass after pause (1x) 
sim_simulation_advancing_abouttostop        =sim_simulation_advancing|0x05        # "Trying to stop" simulation pass (&gt;=1x) 
sim_simulation_advancing_lastbeforestop        =sim_simulation_advancing|0x06        # Last simulation pass (1x) 


# Script execution result (first return value) 
sim_script_no_error                    =0
sim_script_main_script_nonexistent    =1
sim_script_main_script_not_called    =2
sim_script_reentrance_error            =4
sim_script_lua_error                =8
sim_script_call_error                =16


 # Script types (serialized!) 
sim_scripttype_mainscript   =0
sim_scripttype_childscript  =1
sim_scripttype_jointctrlcallback  =4
sim_scripttype_contactcallback  =5
sim_scripttype_customizationscript  =6
sim_scripttype_generalcallback  =7

# API call error messages 
sim_api_errormessage_ignore    =0    # does not memorize nor output errors 
sim_api_errormessage_report    =1    # memorizes errors (default for C-API calls) 
sim_api_errormessage_output    =2  # memorizes and outputs errors (default for Lua-API calls) 


# special argument of some functions 
sim_handle_all                        =-2
sim_handle_all_except_explicit        =-3
sim_handle_self                        =-4
sim_handle_main_script                =-5
sim_handle_tree                        =-6
sim_handle_chain                    =-7
sim_handle_single                    =-8
sim_handle_default                    =-9
sim_handle_all_except_self            =-10
sim_handle_parent                    =-11


# special handle flags
sim_handleflag_assembly                =0x400000
sim_handleflag_model                =0x800000


# distance calculation methods (serialized) 
sim_distcalcmethod_dl               =0
sim_distcalcmethod_dac              =1
sim_distcalcmethod_max_dl_dac       =2
sim_distcalcmethod_dl_and_dac       =3
sim_distcalcmethod_sqrt_dl2_and_dac2=4
sim_distcalcmethod_dl_if_nonzero    =5
sim_distcalcmethod_dac_if_nonzero   =6


 # Generic dialog styles 
sim_dlgstyle_message        =0
sim_dlgstyle_input          =1
sim_dlgstyle_ok             =2
sim_dlgstyle_ok_cancel      =3
sim_dlgstyle_yes_no         =4
sim_dlgstyle_dont_center    =32# can be combined with one of above values. Only with this flag can the position of the related UI be set just after dialog creation  

 # Generic dialog return values 
sim_dlgret_still_open   =0
sim_dlgret_ok           =1
sim_dlgret_cancel       =2
sim_dlgret_yes          =3
sim_dlgret_no           =4


# Path properties 
sim_pathproperty_show_line                            =0x0001
sim_pathproperty_show_orientation                    =0x0002
sim_pathproperty_closed_path                        =0x0004
sim_pathproperty_automatic_orientation                =0x0008
sim_pathproperty_invert_velocity                    =0x0010
sim_pathproperty_infinite_acceleration                =0x0020
sim_pathproperty_flat_path                            =0x0040
sim_pathproperty_show_position                        =0x0080
sim_pathproperty_auto_velocity_profile_translation    =0x0100
sim_pathproperty_auto_velocity_profile_rotation        =0x0200
sim_pathproperty_endpoints_at_zero                    =0x0400
sim_pathproperty_keep_x_up                            =0x0800


 # drawing objects 
# following are mutually exclusive 
sim_drawing_points          =0            # 3 values per point (point size in pixels) 
sim_drawing_lines            =1            # 6 values per line (line size in pixels) 
sim_drawing_triangles        =2            # 9 values per triangle 
sim_drawing_trianglepoints    =3            # 6 values per point (3 for triangle position 3 for triangle normal vector) (triangle size in meters) 
sim_drawing_quadpoints        =4            # 6 values per point (3 for quad position 3 for quad normal vector) (quad size in meters) 
sim_drawing_discpoints        =5            # 6 values per point (3 for disc position 3 for disc normal vector) (disc size in meters) 
sim_drawing_cubepoints        =6          # 6 values per point (3 for cube position 3 for cube normal vector) (cube size in meters) 
sim_drawing_spherepoints    =7          # 3 values per point (sphere size in meters) 

# following can be or-combined 
sim_drawing_itemcolors                =0x00020 # +3 values per item (each item has its own ambient color (rgb values)).
                                             # Mutually exclusive with sim_drawing_vertexcolors 
sim_drawing_vertexcolors            =0x00040 # +3 values per vertex (each vertex has its own ambient color (rgb values). Only for sim_drawing_lines (+6) and for sim_drawing_triangles(+9)). Mutually exclusive with sim_drawing_itemcolors 
sim_drawing_itemsizes                =0x00080 # +1 value per item (each item has its own size). Not for sim_drawing_triangles 
sim_drawing_backfaceculling            =0x00100 # back faces are not displayed for all items 
sim_drawing_wireframe                =0x00200 # all items displayed in wireframe 
sim_drawing_painttag                =0x00400 # all items are tagged as paint (for additinal processing at a later stage) 
sim_drawing_followparentvisibility    =0x00800 # if the object is associated with a scene object then it follows that visibility otherwise it is always visible 
sim_drawing_cyclic                    =0x01000 # if the max item count was reached then the first items are overwritten. 
sim_drawing_50percenttransparency    =0x02000 # the drawing object will be 50% transparent 
sim_drawing_25percenttransparency    =0x04000 # the drawing object will be 25% transparent 
sim_drawing_12percenttransparency    =0x08000 # the drawing object will be 12.5% transparent 
sim_drawing_emissioncolor            =0x10000 # When used in combination with sim_drawing_itemcolors or sim_drawing_vertexcolors then the specified colors will be for the emissive component 
sim_drawing_facingcamera            =0x20000 # Only for trianglepoints quadpoints discpoints and cubepoints. If specified the normal verctor is calculated to face the camera (each item data requires 3 values less) 
sim_drawing_overlay                    =0x40000 # When specified objects are always drawn on top of "regular objects" 
sim_drawing_itemtransparency        =0x80000  # +1 value per item (each item has its own transparency value (0-1)). Not compatible with sim_drawing_vertexcolors 

# banner values 
# following can be or-combined 
sim_banner_left                        =0x00001 # Banners display on the left of the specified point 
sim_banner_right                    =0x00002 # Banners display on the right of the specified point 
sim_banner_nobackground                =0x00004 # Banners have no background rectangle 
sim_banner_overlay                    =0x00008 # When specified banners are always drawn on top of "regular objects" 
sim_banner_followparentvisibility    =0x00010 # if the object is associated with a scene object then it follows that visibility otherwise it is always visible 
sim_banner_clickselectsparent        =0x00020 # if the object is associated with a scene object then clicking the banner will select the scene object 
sim_banner_clicktriggersevent        =0x00040 # if the banner is clicked an event is triggered (sim_message_eventcallback_bannerclicked and sim_message_bannerclicked are generated) 
sim_banner_facingcamera                =0x00080 # If specified the banner will always face the camera by rotating around the banner's vertical axis (y-axis) 
sim_banner_fullyfacingcamera        =0x00100 # If specified the banner will always fully face the camera (the banner's orientation is same as the camera looking at it) 
sim_banner_backfaceculling            =0x00200 # If specified the banner will only be visible from one side 
sim_banner_keepsamesize                =0x00400 # If specified the banner will always appear in the same size. In that case size represents the character height in pixels 
sim_banner_bitmapfont                =0x00800 # If specified a fixed-size bitmap font is used. The text will also always fully face the camera and be right 
                                             # to the specified position. Bitmap fonts are not clickable 


# particle objects following are mutually exclusive 
sim_particle_points1        =0  # 6 values per point (pt1 and pt2. Pt1 is start position pt2-pt1 is the initial velocity vector). i
                                #Point is 1 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_points2        =1    # 6 values per point. Point is 2 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_points4        =2    # 6 values per point. Point is 4 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_roughspheres    =3    # 6 values per sphere. Only appearance is rough. Internally a perfect sphere 
sim_particle_spheres        =4    # 6 values per sphere. Internally a perfect sphere 




# following can be or-combined 
sim_particle_respondable1to4        =0x0020 # the particles are respondable against shapes (against all objects that have at least one bit 1-4 activated in the global respondable mask) 
sim_particle_respondable5to8        =0x0040 # the particles are respondable against shapes (against all objects that have at least one bit 5-8 activated in the global respondable mask) 
sim_particle_particlerespondable    =0x0080 # the particles are respondable against each other 
sim_particle_ignoresgravity            =0x0100 # the particles ignore the effect of gravity. Not compatible with sim_particle_water 
sim_particle_invisible                =0x0200 # the particles are invisible 
sim_particle_itemsizes                =0x0400 # +1 value per particle (each particle can have a different size) 
sim_particle_itemdensities            =0x0800 # +1 value per particle (each particle can have a different density) 
sim_particle_itemcolors                =0x1000 # +3 values per particle (each particle can have a different color) 
sim_particle_cyclic                    =0x2000 # if the max item count was reached then the first items are overwritten. 
sim_particle_emissioncolor            =0x4000 # When used in combination with sim_particle_itemcolors then the specified colors will be for the emissive component 
sim_particle_water                    =0x8000 # the particles are water particles (no weight in the water (i.e. when z&lt;0)). Not compatible with sim_particle_ignoresgravity 
sim_particle_painttag                =0x10000 # The particles can be seen by vision sensors (sim_particle_invisible must not be set) 




# custom user interface menu attributes 
sim_ui_menu_title        =1
sim_ui_menu_minimize    =2
sim_ui_menu_close        =4
sim_ui_menu_systemblock =8



# Boolean parameters 
sim_boolparam_hierarchy_visible                 =0
sim_boolparam_console_visible                   =1
sim_boolparam_collision_handling_enabled        =2
sim_boolparam_distance_handling_enabled         =3
sim_boolparam_ik_handling_enabled               =4
sim_boolparam_gcs_handling_enabled              =5
sim_boolparam_dynamics_handling_enabled         =6
sim_boolparam_joint_motion_handling_enabled     =7
sim_boolparam_path_motion_handling_enabled      =8
sim_boolparam_proximity_sensor_handling_enabled =9
sim_boolparam_vision_sensor_handling_enabled    =10
sim_boolparam_mill_handling_enabled             =11
sim_boolparam_browser_visible                   =12
sim_boolparam_scene_and_model_load_messages     =13
sim_reserved0                                   =14
sim_boolparam_shape_textures_are_visible        =15
sim_boolparam_display_enabled                   =16
sim_boolparam_infotext_visible                  =17
sim_boolparam_statustext_open                   =18
sim_boolparam_fog_enabled                       =19
sim_boolparam_rml2_available                    =20
sim_boolparam_rml4_available                    =21
sim_boolparam_mirrors_enabled                    =22
sim_boolparam_aux_clip_planes_enabled            =23
sim_boolparam_full_model_copy_from_api            =24
sim_boolparam_realtime_simulation                =25
sim_boolparam_force_show_wireless_emission        =27
sim_boolparam_force_show_wireless_reception        =28
sim_boolparam_video_recording_triggered            =29
sim_boolparam_threaded_rendering_enabled        =32
sim_boolparam_fullscreen                        =33
sim_boolparam_headless                            =34
sim_boolparam_hierarchy_toolbarbutton_enabled    =35
sim_boolparam_browser_toolbarbutton_enabled        =36
sim_boolparam_objectshift_toolbarbutton_enabled    =37
sim_boolparam_objectrotate_toolbarbutton_enabled=38
sim_boolparam_force_calcstruct_all_visible        =39
sim_boolparam_force_calcstruct_all                =40
sim_boolparam_exit_request                        =41
sim_boolparam_play_toolbarbutton_enabled        =42
sim_boolparam_pause_toolbarbutton_enabled        =43
sim_boolparam_stop_toolbarbutton_enabled        =44
sim_boolparam_waiting_for_trigger                =45


# Integer parameters 
sim_intparam_error_report_mode      =0  # Check sim_api_errormessage_... constants above for valid values 
sim_intparam_program_version        =1  # e.g Version 2.1.4 --&gt; 20104. Can only be read 
sim_intparam_instance_count         =2  # do not use anymore (always returns 1 since CoppeliaSim 2.5.11) 
sim_intparam_custom_cmd_start_id    =3  # can only be read 
sim_intparam_compilation_version    =4  # 0=evaluation version 1=full version 2=player version. Can only be read 
sim_intparam_current_page           =5
sim_intparam_flymode_camera_handle  =6  # can only be read 
sim_intparam_dynamic_step_divider   =7  # can only be read 
sim_intparam_dynamic_engine         =8  # 0=Bullet 1=ODE. 2=Vortex.
sim_intparam_server_port_start      =9  # can only be read 
sim_intparam_server_port_range      =10 # can only be read 
sim_intparam_visible_layers         =11
sim_intparam_infotext_style         =12
sim_intparam_settings               =13
sim_intparam_edit_mode_type         =14 # can only be read 
sim_intparam_server_port_next       =15 # is initialized at sim_intparam_server_port_start 
sim_intparam_qt_version             =16 # version of the used Qt framework 
sim_intparam_event_flags_read       =17 # can only be read 
sim_intparam_event_flags_read_clear =18 # can only be read 
sim_intparam_platform               =19 # can only be read 
sim_intparam_scene_unique_id        =20 # can only be read 
sim_intparam_work_thread_count      =21
sim_intparam_mouse_x                =22
sim_intparam_mouse_y                =23
sim_intparam_core_count             =24
sim_intparam_work_thread_calc_time_ms =25
sim_intparam_idle_fps               =26
sim_intparam_prox_sensor_select_down =27
sim_intparam_prox_sensor_select_up  =28
sim_intparam_stop_request_counter   =29
sim_intparam_program_revision       =30
sim_intparam_mouse_buttons          =31
sim_intparam_dynamic_warning_disabled_mask =32
sim_intparam_simulation_warning_disabled_mask =33
sim_intparam_scene_index            =34
sim_intparam_motionplanning_seed    =35
sim_intparam_speedmodifier          =36

# Float parameters 
sim_floatparam_rand=0 # random value (0.0-1.0) 
sim_floatparam_simulation_time_step =1
sim_floatparam_stereo_distance        =2

# String parameters 
sim_stringparam_application_path=0 # path of CoppeliaSim's executable 
sim_stringparam_video_filename=1
sim_stringparam_app_arg1            =2
sim_stringparam_app_arg2            =3
sim_stringparam_app_arg3            =4
sim_stringparam_app_arg4            =5
sim_stringparam_app_arg5            =6
sim_stringparam_app_arg6            =7
sim_stringparam_app_arg7            =8
sim_stringparam_app_arg8            =9
sim_stringparam_app_arg9            =10
sim_stringparam_scene_path_and_name    =13

# Array parameters 
sim_arrayparam_gravity          =0
sim_arrayparam_fog              =1
sim_arrayparam_fog_color        =2
sim_arrayparam_background_color1=3
sim_arrayparam_background_color2=4
sim_arrayparam_ambient_light    =5
sim_arrayparam_random_euler        =6

sim_objintparam_visibility_layer= 10
sim_objfloatparam_abs_x_velocity= 11
sim_objfloatparam_abs_y_velocity= 12
sim_objfloatparam_abs_z_velocity= 13
sim_objfloatparam_abs_rot_velocity= 14
sim_objfloatparam_objbbox_min_x= 15
sim_objfloatparam_objbbox_min_y= 16
sim_objfloatparam_objbbox_min_z= 17
sim_objfloatparam_objbbox_max_x= 18
sim_objfloatparam_objbbox_max_y= 19
sim_objfloatparam_objbbox_max_z= 20
sim_objfloatparam_modelbbox_min_x= 21
sim_objfloatparam_modelbbox_min_y= 22
sim_objfloatparam_modelbbox_min_z= 23
sim_objfloatparam_modelbbox_max_x= 24
sim_objfloatparam_modelbbox_max_y= 25
sim_objfloatparam_modelbbox_max_z= 26
sim_objintparam_collection_self_collision_indicator= 27
sim_objfloatparam_transparency_offset= 28
sim_objintparam_child_role= 29
sim_objintparam_parent_role= 30
sim_objintparam_manipulation_permissions= 31
sim_objintparam_illumination_handle= 32

sim_visionfloatparam_near_clipping= 1000
sim_visionfloatparam_far_clipping= 1001
sim_visionintparam_resolution_x= 1002
sim_visionintparam_resolution_y= 1003
sim_visionfloatparam_perspective_angle= 1004
sim_visionfloatparam_ortho_size= 1005
sim_visionintparam_disabled_light_components= 1006
sim_visionintparam_rendering_attributes= 1007
sim_visionintparam_entity_to_render= 1008
sim_visionintparam_windowed_size_x= 1009
sim_visionintparam_windowed_size_y= 1010
sim_visionintparam_windowed_pos_x= 1011
sim_visionintparam_windowed_pos_y= 1012
sim_visionintparam_pov_focal_blur= 1013
sim_visionfloatparam_pov_blur_distance= 1014
sim_visionfloatparam_pov_aperture= 1015
sim_visionintparam_pov_blur_sampled= 1016
sim_visionintparam_render_mode= 1017

sim_jointintparam_motor_enabled= 2000
sim_jointintparam_ctrl_enabled= 2001
sim_jointfloatparam_pid_p= 2002
sim_jointfloatparam_pid_i= 2003
sim_jointfloatparam_pid_d= 2004
sim_jointfloatparam_intrinsic_x= 2005
sim_jointfloatparam_intrinsic_y= 2006
sim_jointfloatparam_intrinsic_z= 2007
sim_jointfloatparam_intrinsic_qx= 2008
sim_jointfloatparam_intrinsic_qy= 2009
sim_jointfloatparam_intrinsic_qz= 2010
sim_jointfloatparam_intrinsic_qw= 2011
sim_jointfloatparam_velocity= 2012
sim_jointfloatparam_spherical_qx= 2013
sim_jointfloatparam_spherical_qy= 2014
sim_jointfloatparam_spherical_qz= 2015
sim_jointfloatparam_spherical_qw= 2016
sim_jointfloatparam_upper_limit= 2017
sim_jointfloatparam_kc_k= 2018
sim_jointfloatparam_kc_c= 2019
sim_jointfloatparam_ik_weight= 2021
sim_jointfloatparam_error_x= 2022
sim_jointfloatparam_error_y= 2023
sim_jointfloatparam_error_z= 2024
sim_jointfloatparam_error_a= 2025
sim_jointfloatparam_error_b= 2026
sim_jointfloatparam_error_g= 2027
sim_jointfloatparam_error_pos= 2028
sim_jointfloatparam_error_angle= 2029
sim_jointintparam_velocity_lock= 2030
sim_jointintparam_vortex_dep_handle= 2031
sim_jointfloatparam_vortex_dep_multiplication= 2032
sim_jointfloatparam_vortex_dep_offset= 2033

sim_shapefloatparam_init_velocity_x= 3000
sim_shapefloatparam_init_velocity_y= 3001
sim_shapefloatparam_init_velocity_z= 3002
sim_shapeintparam_static= 3003
sim_shapeintparam_respondable= 3004
sim_shapefloatparam_mass= 3005
sim_shapefloatparam_texture_x= 3006
sim_shapefloatparam_texture_y= 3007
sim_shapefloatparam_texture_z= 3008
sim_shapefloatparam_texture_a= 3009
sim_shapefloatparam_texture_b= 3010
sim_shapefloatparam_texture_g= 3011
sim_shapefloatparam_texture_scaling_x= 3012
sim_shapefloatparam_texture_scaling_y= 3013
sim_shapeintparam_culling= 3014
sim_shapeintparam_wireframe= 3015
sim_shapeintparam_compound= 3016
sim_shapeintparam_convex= 3017
sim_shapeintparam_convex_check= 3018
sim_shapeintparam_respondable_mask= 3019
sim_shapefloatparam_init_velocity_a= 3020
sim_shapefloatparam_init_velocity_b= 3021
sim_shapefloatparam_init_velocity_g= 3022
sim_shapestringparam_color_name= 3023
sim_shapeintparam_edge_visibility= 3024
sim_shapefloatparam_shading_angle= 3025
sim_shapefloatparam_edge_angle= 3026
sim_shapeintparam_edge_borders_hidden= 3027

sim_proxintparam_ray_invisibility= 4000

sim_forcefloatparam_error_x= 5000
sim_forcefloatparam_error_y= 5001
sim_forcefloatparam_error_z= 5002
sim_forcefloatparam_error_a= 5003
sim_forcefloatparam_error_b= 5004
sim_forcefloatparam_error_g= 5005
sim_forcefloatparam_error_pos= 5006
sim_forcefloatparam_error_angle= 5007

sim_lightintparam_pov_casts_shadows= 8000

sim_cameraintparam_disabled_light_components= 9000
sim_camerafloatparam_perspective_angle= 9001
sim_camerafloatparam_ortho_size= 9002
sim_cameraintparam_rendering_attributes= 9003
sim_cameraintparam_pov_focal_blur= 9004
sim_camerafloatparam_pov_blur_distance= 9005
sim_camerafloatparam_pov_aperture= 9006
sim_cameraintparam_pov_blur_samples= 9007

sim_dummyintparam_link_type= 10000

sim_mirrorfloatparam_width= 12000
sim_mirrorfloatparam_height= 12001
sim_mirrorfloatparam_reflectance= 12002
sim_mirrorintparam_enable= 12003

sim_pplanfloatparam_x_min= 20000
sim_pplanfloatparam_x_range= 20001
sim_pplanfloatparam_y_min= 20002
sim_pplanfloatparam_y_range= 20003
sim_pplanfloatparam_z_min= 20004
sim_pplanfloatparam_z_range= 20005
sim_pplanfloatparam_delta_min= 20006
sim_pplanfloatparam_delta_range= 20007

sim_mplanintparam_nodes_computed= 25000
sim_mplanintparam_prepare_nodes= 25001
sim_mplanintparam_clear_nodes= 25002

# User interface elements 
sim_gui_menubar                        =0x0001
sim_gui_popups                        =0x0002
sim_gui_toolbar1                    =0x0004
sim_gui_toolbar2                    =0x0008
sim_gui_hierarchy                    =0x0010
sim_gui_infobar                        =0x0020
sim_gui_statusbar                    =0x0040
sim_gui_scripteditor                =0x0080
sim_gui_scriptsimulationparameters    =0x0100
sim_gui_dialogs                        =0x0200
sim_gui_browser                        =0x0400
sim_gui_all                            =0xffff


# Joint modes 
sim_jointmode_passive       =0
sim_jointmode_motion        =1
sim_jointmode_ik            =2
sim_jointmode_ikdependent   =3
sim_jointmode_dependent     =4
sim_jointmode_force         =5


# Navigation and selection modes with the mouse. Lower byte values are mutually exclusive upper byte bits can be combined 
sim_navigation_passive                    =0x0000
sim_navigation_camerashift                =0x0001
sim_navigation_camerarotate                =0x0002
sim_navigation_camerazoom                =0x0003
sim_navigation_cameratilt                =0x0004
sim_navigation_cameraangle                =0x0005
sim_navigation_camerafly                =0x0006
sim_navigation_objectshift                =0x0007
sim_navigation_objectrotate                =0x0008
sim_navigation_reserved2                =0x0009
sim_navigation_reserved3                =0x000A
sim_navigation_jointpathtest            =0x000B
sim_navigation_ikmanip                    =0x000C
sim_navigation_objectmultipleselection    =0x000D
# Bit-combine following values and add them to one of above's values for a valid navigation mode 
sim_navigation_reserved4                =0x0100
sim_navigation_clickselection            =0x0200
sim_navigation_ctrlselection            =0x0400
sim_navigation_shiftselection            =0x0800
sim_navigation_camerazoomwheel            =0x1000
sim_navigation_camerarotaterightbutton    =0x2000



#Remote API constants
SIMX_VERSION                    =0 
# Remote API message header structure 
SIMX_HEADER_SIZE                =18
simx_headeroffset_crc           =0    # 1 simxUShort. Generated by the client or server. The CRC for the message 
simx_headeroffset_version       =2    # 1 byte. Generated by the client or server. The version of the remote API software 
simx_headeroffset_message_id    =3    # 1 simxInt. Generated by the client (and used in a reply by the server) 
simx_headeroffset_client_time   =7    # 1 simxInt. Client time stamp generated by the client (and sent back by the server) 
simx_headeroffset_server_time   =11    # 1 simxInt. Generated by the server when a reply is generated. The server timestamp 
simx_headeroffset_scene_id      =15    # 1 simxUShort. Generated by the server. A unique ID identifying the scene currently displayed 
simx_headeroffset_server_state  =17    # 1 byte. Generated by the server. Bit coded 0 set --&gt; simulation not stopped 1 set --&gt; simulation paused 2 set --&gt; real-time switch on 3-5 edit mode type (0=no edit mode 1=triangle 2=vertex 3=edge 4=path 5=UI)  

# Remote API command header 
SIMX_SUBHEADER_SIZE                 =26
simx_cmdheaderoffset_mem_size       =0    # 1 simxInt. Generated by the client or server. The buffer size of the command. 
simx_cmdheaderoffset_full_mem_size  =4    # 1 simxInt. Generated by the client or server. The full buffer size of the command (applies to split chunks). 
simx_cmdheaderoffset_pdata_offset0  =8    # 1 simxUShort. Generated by the client or server. The amount of data that is part of the command identification. 
simx_cmdheaderoffset_pdata_offset1  =10    # 1 simxInt. Generated by the client or server. The amount of shift of the pure data buffer (applies to split chunks). 
simx_cmdheaderoffset_cmd=14    # 1 simxInt. Generated by the client (and used in a reply by the server). The command combined with the operation mode of the command. 
simx_cmdheaderoffset_delay_or_split =18    # 1 simxUShort. Generated by the client or server. The amount of delay in ms of a continuous command or the max. pure data size to send at once (applies to split commands). 
simx_cmdheaderoffset_sim_time       =20    # 1 simxInt. Generated by the server. The simulation time (in ms) when the command was executed (or 0 if simulation is not running) 
simx_cmdheaderoffset_status         =24    # 1 byte. Generated by the server. (1 bit 0 is set --&gt; error in function execution on server side). The client writes bit 1 if command cannot be overwritten
simx_cmdheaderoffset_reserved       =25    # 1 byte. Not yet used 





# Regular operation modes 
simx_opmode_oneshot                =0x000000 # sends command as one chunk. Reply will also come as one chunk. Doesn't wait for the reply. 
simx_opmode_blocking            =0x010000 # sends command as one chunk. Reply will also come as one chunk. Waits for the reply (_REPLY_WAIT_TIMEOUT_IN_MS is the timeout). 
simx_opmode_oneshot_wait        =0x010000 # sends command as one chunk. Reply will also come as one chunk. Waits for the reply (_REPLY_WAIT_TIMEOUT_IN_MS is the timeout). 
simx_opmode_continuous            =0x020000  
simx_opmode_streaming            =0x020000 # sends command as one chunk. Command will be stored on the server and always executed 
                                                      #(every x ms (as far as possible) where x can be 0-65535. just add x to opmode_continuous). 
                                                      # A reply will be sent continuously each time as one chunk. Doesn't wait for the reply. 

# Operation modes for heavy data 
simx_opmode_oneshot_split        =0x030000   # sends command as several chunks (max chunk size is x bytes where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to opmode_oneshot_split). Reply will also come as several chunks. Doesn't wait for the reply.      
simx_opmode_continuous_split    =0x040000
simx_opmode_streaming_split    =0x040000    # sends command as several chunks (max chunk size is x bytes where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to opmode_continuous_split). Command will be stored on the server and always executed. A reply will be sent continuously each time as several chunks. Doesn't wait for the reply. 

# Special operation modes 
simx_opmode_discontinue            =0x050000    # removes and cancels all commands stored on the client or server side (also continuous commands) 
simx_opmode_buffer                =0x060000    # doesn't send anything but checks if a reply for the given command is available in the input buffer (i.e. previously received from the server) 
simx_opmode_remove                =0x070000    # doesn't send anything and doesn't return any specific value. It just erases a similar command reply in the inbox (to free some memory) 


# Command return codes 
simx_return_ok                    =0x000000
simx_return_novalue_flag        =0x000001        # input buffer doesn't contain the specified command 
simx_return_timeout_flag        =0x000002        # command reply not received in time for opmode_oneshot_wait operation mode 
simx_return_illegal_opmode_flag    =0x000004        # command doesn't support the specified operation mode 
simx_return_remote_error_flag    =0x000008        # command caused an error on the server side 
simx_return_split_progress_flag    =0x000010        # previous similar command not yet fully processed (applies to opmode_oneshot_split operation modes) 
simx_return_local_error_flag    =0x000020        # command caused an error on the client side 
simx_return_initialize_error_flag    =0x000040        # simxStart was not yet called 

# Following for backward compatibility (same as above) 
simx_error_noerror                =0x000000
simx_error_novalue_flag            =0x000001        # input buffer doesn't contain the specified command 
simx_error_timeout_flag            =0x000002        # command reply not received in time for opmode_oneshot_wait operation mode 
simx_error_illegal_opmode_flag    =0x000004        # command doesn't support the specified operation mode 
simx_error_remote_error_flag    =0x000008        # command caused an error on the server side 
simx_error_split_progress_flag    =0x000010        # previous similar command not yet fully processed (applies to opmode_oneshot_split operation modes) 
simx_error_local_error_flag        =0x000020        # command caused an error on the client side 
simx_error_initialize_error_flag        =0x000040        # simxStart was not yet called 


</t>
<t tx="leo.20210713140956.46">def __init__(
    self,
    server_addr='127.0.0.1',
    server_port=19997,
    scene_path=vrep_scenes_path+'/hopper.ttt',
):
    vrep_env.VrepEnv.__init__(
        self,
        server_addr,
        server_port,
        scene_path,
    )
    
    # Settings
    self.random_start = False
    
    # All joints
    joint_names = ['thigh_joint','leg_joint','foot_joint']
    # All shapes
    shape_names = ['torso','thigh','leg','foot']
    
    # Getting object handles
    
    # Meta
    self.camera = self.get_object_handle('camera')
    # Actuators
    self.oh_joint = list(map(self.get_object_handle, joint_names))
    # Shapes
    self.oh_shape = list(map(self.get_object_handle, shape_names))
    
    # One action per joint
    dim_act = len(self.oh_joint)
    # Multiple dimensions per shape
    dim_obs = (len(self.oh_shape)*3*2)+1
    
    high_act =        np.ones([dim_act])
    high_obs = np.inf*np.ones([dim_obs])
    
    self.action_space      = gym.spaces.Box(-high_act, high_act)
    self.observation_space = gym.spaces.Box(-high_obs, high_obs)
    
    # Parameters
    self.joints_max_velocity = 8.0
    #self.power = 0.75
    self.power = 3.75
    
    self.seed()
    
    print('HopperVrepEnv: initialized')

</t>
<t tx="leo.20210713140956.47">def _make_observation(self):
    """Get observation from v-rep and stores in self.observation
    """
    lst_o = []
    
    # Include z position in observation
    torso_pos = self.obj_get_position(self.oh_shape[0])
    lst_o += [torso_pos[2]]
    
    # Include shapes relative velocities in observation
    for i_oh in self.oh_shape:
        lin_vel , ang_vel = self.obj_get_velocity(i_oh)
        lst_o += ang_vel
        lst_o += lin_vel
    
    self.observation = np.array(lst_o).astype('float32')

</t>
<t tx="leo.20210713140956.48">def _make_action(self, a):
    """Send action to v-rep
    """
    for i_oh, i_a in zip(self.oh_joint, a):
        #self.obj_set_velocity(i_oh, i_a)
        self.obj_set_velocity(i_oh, self.power*float(np.clip(i_a,-1,+1)))

</t>
<t tx="leo.20210713140956.49">def step(self, action):
    # Clip xor Assert
    #actions = np.clip(actions,-self.joints_max_velocity, self.joints_max_velocity)
    assert self.action_space.contains(action), "%r (%s) invalid"%(action, type(action))
    
    # Actuate
    self._make_action(action)
    #self._make_action(action*self.joints_max_velocity)
    # Step
    self.step_simulation()
    # Observe
    self._make_observation()
    
    # Reward
    torso_pos_z  = self.observation[0] # up/down
    torso_lvel_x = self.observation[4]
    r_alive = 1.0
    
    reward = (16.0)*(r_alive) +(8.0)*(torso_lvel_x)
    
    # Early stop
    stand_threshold = 0.10
    done = (torso_pos_z &lt; stand_threshold)
    #done = False
    
    return self.observation, reward, done, {}

</t>
<t tx="leo.20210713140956.50">def reset(self):
    if self.sim_running:
        self.stop_simulation()
    self.start_simulation()
    
    # First action is random: emulate random initialization
    if self.random_start:
        factor = self.np_random.uniform(low=0, high=0.02, size=(1,))[0]
        action = self.action_space.sample()*factor
        self._make_action(action)
        self.step_simulation()
    
    self._make_observation()
    return self.observation

</t>
<t tx="leo.20210713140956.51">def render(self, mode='human', close=False):
    pass

</t>
<t tx="leo.20210713140956.52">def seed(self, seed=None):
    self.np_random, seed = seeding.np_random(seed)
    return [seed]

</t>
<t tx="leo.20210713140956.53">def main(args):
    env = HopperVrepEnv()
    for i_episode in range(4):
        observation = env.reset()
        print(observation)
        total_reward = 0
        for t in range(256):
            action = env.action_space.sample()
            observation, reward, done, _ = env.step(action)
            total_reward += reward
            if done:
                break
        print("Episode finished after {} timesteps.\tTotal reward: {}".format(t+1,total_reward))
    env.close()
    return 0

</t>
<t tx="leo.20210713140956.54"></t>
<t tx="leo.20210713140956.55">
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210713140956.56">import platform
import struct
import sys
import os
import ctypes as ct
from .simConst import *

#load library
libsimx = None
try:
    file_extension = '.so'
    if platform.system() =='cli':
        file_extension = '.dll'
    elif platform.system() =='Windows':
        file_extension = '.dll'
    elif platform.system() == 'Darwin':
        file_extension = '.dylib'
    else:
        file_extension = '.so'
    libfullpath = os.path.join(os.path.dirname(__file__), 'remoteApi' + file_extension)
    libsimx = ct.CDLL(libfullpath)
except:
    print ('----------------------------------------------------')
    print ('The remoteApi library could not be loaded. Make sure')
    print ('it is located in the same folder as "sim.py", or')
    print ('appropriately adjust the file "sim.py"')
    print ('----------------------------------------------------')
    print ('')

#ctypes wrapper prototypes
c_GetJointPosition          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointPosition", libsimx))
c_SetJointPosition          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointPosition", libsimx))
c_GetJointMatrix            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointMatrix", libsimx))
c_SetSphericalJointMatrix   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetSphericalJointMatrix", libsimx))
c_SetJointTargetVelocity    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointTargetVelocity", libsimx))
c_SetJointTargetPosition    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointTargetPosition", libsimx))
c_GetJointForce             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointForce", libsimx))
c_GetJointMaxForce          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointMaxForce", libsimx))
c_SetJointForce             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointMaxForce", libsimx))
c_SetJointMaxForce          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointMaxForce", libsimx))
c_ReadForceSensor           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.c_int32)(("simxReadForceSensor", libsimx))
c_BreakForceSensor          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxBreakForceSensor", libsimx))
c_ReadVisionSensor          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.POINTER(ct.c_float)), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxReadVisionSensor", libsimx))
c_GetObjectHandle           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectHandle", libsimx))
c_GetVisionSensorImage      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_byte)), ct.c_ubyte, ct.c_int32)(("simxGetVisionSensorImage", libsimx))
c_SetVisionSensorImage      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_byte), ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetVisionSensorImage", libsimx))
c_GetVisionSensorDepthBuffer= ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)), ct.c_int32)(("simxGetVisionSensorDepthBuffer", libsimx))
c_GetObjectChild            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectChild", libsimx))
c_GetObjectParent           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectParent", libsimx))
c_ReadProximitySensor       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_float), ct.c_int32)(("simxReadProximitySensor", libsimx))
c_LoadModel                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.POINTER(ct.c_int32), ct.c_int32)(("simxLoadModel", libsimx))
c_LoadUI                    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxLoadUI", libsimx))
c_LoadScene                 =  ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.c_int32)(("simxLoadScene", libsimx))
c_StartSimulation           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxStartSimulation", libsimx))
c_PauseSimulation           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxPauseSimulation", libsimx))
c_StopSimulation            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxStopSimulation", libsimx))
c_GetUIHandle               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIHandle", libsimx))
c_GetUISlider               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUISlider", libsimx))
c_SetUISlider               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetUISlider", libsimx))
c_GetUIEventButton          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIEventButton", libsimx))
c_GetUIButtonProperty       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIButtonProperty", libsimx))
c_SetUIButtonProperty       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetUIButtonProperty", libsimx))
c_AddStatusbarMessage       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxAddStatusbarMessage", libsimx))
c_AuxiliaryConsoleOpen      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.c_int32)(("simxAuxiliaryConsoleOpen", libsimx))
c_AuxiliaryConsoleClose     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxAuxiliaryConsoleClose", libsimx))
c_AuxiliaryConsolePrint     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxAuxiliaryConsolePrint", libsimx))
c_AuxiliaryConsoleShow      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxAuxiliaryConsoleShow", libsimx))
c_GetObjectOrientation      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectOrientation", libsimx))
c_GetObjectQuaternion       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectQuaternion", libsimx))
c_GetObjectPosition         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectPosition", libsimx))
c_SetObjectOrientation      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectOrientation", libsimx))
c_SetObjectQuaternion       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectQuaternion", libsimx))
c_SetObjectPosition         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectPosition", libsimx))
c_SetObjectParent           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetObjectParent", libsimx))
c_SetUIButtonLabel          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32)(("simxSetUIButtonLabel", libsimx))
c_GetLastErrors             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetLastErrors", libsimx))
c_GetArrayParameter         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetArrayParameter", libsimx))
c_SetArrayParameter         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetArrayParameter", libsimx))
c_GetBooleanParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxGetBooleanParameter", libsimx))
c_SetBooleanParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetBooleanParameter", libsimx))
c_GetIntegerParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetIntegerParameter", libsimx))
c_SetIntegerParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetIntegerParameter", libsimx))
c_GetFloatingParameter      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetFloatingParameter", libsimx))
c_SetFloatingParameter      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetFloatingParameter", libsimx))
c_GetStringParameter        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetStringParameter", libsimx))
c_GetCollisionHandle        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetCollisionHandle", libsimx))
c_GetDistanceHandle         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetDistanceHandle", libsimx))
c_GetCollectionHandle       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetCollectionHandle", libsimx))
c_ReadCollision             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxReadCollision", libsimx))
c_ReadDistance              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxReadDistance", libsimx))
c_RemoveObject              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveObject", libsimx))
c_RemoveModel               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveModel", libsimx))
c_RemoveUI                  = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveUI", libsimx))
c_CloseScene                = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxCloseScene", libsimx))
c_GetObjects                = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxGetObjects", libsimx))
c_DisplayDialog             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.c_int32)(("simxDisplayDialog", libsimx))
c_EndDialog                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxEndDialog", libsimx))
c_GetDialogInput            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetDialogInput", libsimx))
c_GetDialogResult           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetDialogResult", libsimx))
c_CopyPasteObjects          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32, ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxCopyPasteObjects", libsimx))
c_GetObjectSelection        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectSelection", libsimx))
c_SetObjectSelection        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32, ct.c_int32)(("simxSetObjectSelection", libsimx))
c_ClearFloatSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearFloatSignal", libsimx))
c_ClearIntegerSignal        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearIntegerSignal", libsimx))
c_ClearStringSignal         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearStringSignal", libsimx))
c_GetFloatSignal            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_float), ct.c_int32)(("simxGetFloatSignal", libsimx))
c_GetIntegerSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetIntegerSignal", libsimx))
c_GetStringSignal           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetStringSignal", libsimx))
c_SetFloatSignal            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_float, ct.c_int32)(("simxSetFloatSignal", libsimx))
c_SetIntegerSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32)(("simxSetIntegerSignal", libsimx))
c_SetStringSignal           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxSetStringSignal", libsimx))
c_AppendStringSignal        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxAppendStringSignal", libsimx))
c_WriteStringStream         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxWriteStringStream", libsimx))
c_GetObjectFloatParameter   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectFloatParameter", libsimx))
c_SetObjectFloatParameter   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetObjectFloatParameter", libsimx))
c_GetObjectIntParameter     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectIntParameter", libsimx))
c_SetObjectIntParameter     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetObjectIntParameter", libsimx))
c_GetModelProperty          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetModelProperty", libsimx))
c_SetModelProperty          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetModelProperty", libsimx))
c_Start                     = ct.CFUNCTYPE(ct.c_int32,ct.POINTER(ct.c_char), ct.c_int32, ct.c_ubyte, ct.c_ubyte, ct.c_int32, ct.c_int32)(("simxStart", libsimx))
c_Finish                    = ct.CFUNCTYPE(None, ct.c_int32)(("simxFinish", libsimx))
c_GetPingTime               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetPingTime", libsimx))
c_GetLastCmdTime            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxGetLastCmdTime", libsimx))
c_SynchronousTrigger        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxSynchronousTrigger", libsimx))
c_Synchronous               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_ubyte)(("simxSynchronous", libsimx))
c_PauseCommunication        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_ubyte)(("simxPauseCommunication", libsimx))
c_GetInMessageInfo          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetInMessageInfo", libsimx))
c_GetOutMessageInfo         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetOutMessageInfo", libsimx))
c_GetConnectionId           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxGetConnectionId", libsimx))
c_CreateBuffer              = ct.CFUNCTYPE(ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxCreateBuffer", libsimx))
c_ReleaseBuffer             = ct.CFUNCTYPE(None, ct.c_void_p)(("simxReleaseBuffer", libsimx))
c_TransferFile              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32)(("simxTransferFile", libsimx))
c_EraseFile                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxEraseFile", libsimx))
c_GetAndClearStringSignal   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetAndClearStringSignal", libsimx))
c_ReadStringStream          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxReadStringStream", libsimx))
c_CreateDummy               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_float, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_int32), ct.c_int32)(("simxCreateDummy", libsimx))
c_Query                     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxQuery", libsimx))
c_GetObjectGroupData        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetObjectGroupData", libsimx))
c_GetObjectVelocity         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectVelocity", libsimx))
c_CallScriptFunction        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_int32),ct.c_int32,ct.POINTER(ct.c_float),ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_ubyte),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_ubyte)),ct.c_int32)(("simxCallScriptFunction", libsimx))

#API functions
</t>
<t tx="leo.20210713140956.57">def simxGetJointPosition(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    position = ct.c_float()
    return c_GetJointPosition(clientID, jointHandle, ct.byref(position), operationMode), position.value

</t>
<t tx="leo.20210713140956.58">def simxSetJointPosition(clientID, jointHandle, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointPosition(clientID, jointHandle, position, operationMode)

</t>
<t tx="leo.20210713140956.59">def simxGetJointMatrix(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    matrix = (ct.c_float*12)()
    ret = c_GetJointMatrix(clientID, jointHandle, matrix, operationMode)
    arr = []
    for i in range(12):
        arr.append(matrix[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.6"></t>
<t tx="leo.20210713140956.60">def simxSetSphericalJointMatrix(clientID, jointHandle, matrix, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    matrix = (ct.c_float*12)(*matrix)
    return c_SetSphericalJointMatrix(clientID, jointHandle, matrix, operationMode)

</t>
<t tx="leo.20210713140956.61">def simxSetJointTargetVelocity(clientID, jointHandle, targetVelocity, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointTargetVelocity(clientID, jointHandle, targetVelocity, operationMode)

</t>
<t tx="leo.20210713140956.62">def simxSetJointTargetPosition(clientID, jointHandle, targetPosition, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointTargetPosition(clientID, jointHandle, targetPosition, operationMode)

</t>
<t tx="leo.20210713140956.63">def simxJointGetForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140956.64">def simxGetJointForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140956.65">def simxGetJointMaxForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointMaxForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140956.66">def simxSetJointForce(clientID, jointHandle, force, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_SetJointMaxForce(clientID, jointHandle, force, operationMode)

</t>
<t tx="leo.20210713140956.67">def simxSetJointMaxForce(clientID, jointHandle, force, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_SetJointMaxForce(clientID, jointHandle, force, operationMode)

</t>
<t tx="leo.20210713140956.68">def simxReadForceSensor(clientID, forceSensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    state = ct.c_ubyte()
    forceVector  = (ct.c_float*3)()
    torqueVector = (ct.c_float*3)()
    ret = c_ReadForceSensor(clientID, forceSensorHandle, ct.byref(state), forceVector, torqueVector, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(forceVector[i])
    arr2 = []
    for i in range(3):
        arr2.append(torqueVector[i])
    #if sys.version_info[0] == 3:
    #    state=state.value
    #else:
    #    state=ord(state.value)
    return ret, state.value, arr1, arr2

</t>
<t tx="leo.20210713140956.69">def simxBreakForceSensor(clientID, forceSensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_BreakForceSensor(clientID, forceSensorHandle, operationMode)

</t>
<t tx="leo.20210713140956.7"></t>
<t tx="leo.20210713140956.70">def simxReadVisionSensor(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    detectionState = ct.c_ubyte()
    auxValues      = ct.POINTER(ct.c_float)()
    auxValuesCount = ct.POINTER(ct.c_int)()
    ret = c_ReadVisionSensor(clientID, sensorHandle, ct.byref(detectionState), ct.byref(auxValues), ct.byref(auxValuesCount), operationMode)

    auxValues2 = []
    if ret == 0:
        s = 0
        for i in range(auxValuesCount[0]):
            auxValues2.append(auxValues[s:s+auxValuesCount[i+1]])
            s += auxValuesCount[i+1]

        #free C buffers
        c_ReleaseBuffer(auxValues)
        c_ReleaseBuffer(auxValuesCount)

    return ret, bool(detectionState.value!=0), auxValues2

</t>
<t tx="leo.20210713140956.71">def simxGetObjectHandle(clientID, objectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(objectName) is str):
        objectName=objectName.encode('utf-8')
    return c_GetObjectHandle(clientID, objectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.72">def simxGetVisionSensorImage(clientID, sensorHandle, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    resolution = (ct.c_int*2)()
    c_image  = ct.POINTER(ct.c_byte)()
    bytesPerPixel = 3
    if (options and 1) != 0:
        bytesPerPixel = 1
    ret = c_GetVisionSensorImage(clientID, sensorHandle, resolution, ct.byref(c_image), options, operationMode)

    reso = []
    image = []
    if (ret == 0):
        image = [None]*resolution[0]*resolution[1]*bytesPerPixel
        for i in range(resolution[0] * resolution[1] * bytesPerPixel):
            image[i] = c_image[i]
        for i in range(2):
            reso.append(resolution[i])
    return ret, reso, image

</t>
<t tx="leo.20210713140956.73">def simxSetVisionSensorImage(clientID, sensorHandle, image, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    size = len(image)
    image_bytes  = (ct.c_byte*size)(*image)
    return c_SetVisionSensorImage(clientID, sensorHandle, image_bytes, size, options, operationMode)

</t>
<t tx="leo.20210713140956.74">def simxGetVisionSensorDepthBuffer(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    c_buffer  = ct.POINTER(ct.c_float)()
    resolution = (ct.c_int*2)()
    ret = c_GetVisionSensorDepthBuffer(clientID, sensorHandle, resolution, ct.byref(c_buffer), operationMode)
    reso = []
    buffer = []
    if (ret == 0):
        buffer = [None]*resolution[0]*resolution[1]
        for i in range(resolution[0] * resolution[1]):
            buffer[i] = c_buffer[i]
        for i in range(2):
            reso.append(resolution[i])
    return ret, reso, buffer

</t>
<t tx="leo.20210713140956.75">def simxGetObjectChild(clientID, parentObjectHandle, childIndex, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    childObjectHandle = ct.c_int()
    return c_GetObjectChild(clientID, parentObjectHandle, childIndex, ct.byref(childObjectHandle), operationMode), childObjectHandle.value

</t>
<t tx="leo.20210713140956.76">def simxGetObjectParent(clientID, childObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parentObjectHandle = ct.c_int()
    return c_GetObjectParent(clientID, childObjectHandle, ct.byref(parentObjectHandle), operationMode), parentObjectHandle.value

</t>
<t tx="leo.20210713140956.77">def simxReadProximitySensor(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    detectionState = ct.c_ubyte()
    detectedObjectHandle = ct.c_int()
    detectedPoint  = (ct.c_float*3)()
    detectedSurfaceNormalVector = (ct.c_float*3)()
    ret = c_ReadProximitySensor(clientID, sensorHandle, ct.byref(detectionState), detectedPoint, ct.byref(detectedObjectHandle), detectedSurfaceNormalVector, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(detectedPoint[i])
    arr2 = []
    for i in range(3):
        arr2.append(detectedSurfaceNormalVector[i])
    return ret, bool(detectionState.value!=0), arr1, detectedObjectHandle.value, arr2

</t>
<t tx="leo.20210713140956.78">def simxLoadModel(clientID, modelPathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    baseHandle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(modelPathAndName) is str):
        modelPathAndName=modelPathAndName.encode('utf-8')
    return c_LoadModel(clientID, modelPathAndName, options, ct.byref(baseHandle), operationMode), baseHandle.value

</t>
<t tx="leo.20210713140956.79">def simxLoadUI(clientID, uiPathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    count = ct.c_int()
    uiHandles = ct.POINTER(ct.c_int)()
    if (sys.version_info[0] == 3) and (type(uiPathAndName) is str):
        uiPathAndName=uiPathAndName.encode('utf-8')
    ret = c_LoadUI(clientID, uiPathAndName, options, ct.byref(count), ct.byref(uiHandles), operationMode)

    handles = []
    if ret == 0:
        for i in range(count.value):
            handles.append(uiHandles[i])
        #free C buffers
        c_ReleaseBuffer(uiHandles)

    return ret, handles

</t>
<t tx="leo.20210713140956.8">@others
if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))
@language python
@tabwidth -4

</t>
<t tx="leo.20210713140956.80">def simxLoadScene(clientID, scenePathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(scenePathAndName) is str):
        scenePathAndName=scenePathAndName.encode('utf-8')
    return c_LoadScene(clientID, scenePathAndName, options, operationMode)

</t>
<t tx="leo.20210713140956.81">def simxStartSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_StartSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140956.82">def simxPauseSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_PauseSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140956.83">def simxStopSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_StopSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140956.84">def simxGetUIHandle(clientID, uiName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(uiName) is str):
        uiName=uiName.encode('utf-8')
    return c_GetUIHandle(clientID, uiName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140956.85">def simxGetUISlider(clientID, uiHandle, uiButtonID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    position = ct.c_int()
    return c_GetUISlider(clientID, uiHandle, uiButtonID, ct.byref(position), operationMode), position.value

</t>
<t tx="leo.20210713140956.86">def simxSetUISlider(clientID, uiHandle, uiButtonID, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetUISlider(clientID, uiHandle, uiButtonID, position, operationMode)

</t>
<t tx="leo.20210713140956.87">def simxGetUIEventButton(clientID, uiHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    uiEventButtonID = ct.c_int()
    auxValues = (ct.c_int*2)()
    ret = c_GetUIEventButton(clientID, uiHandle, ct.byref(uiEventButtonID), auxValues, operationMode)
    arr = []
    for i in range(2):
        arr.append(auxValues[i])
    return ret, uiEventButtonID.value, arr

</t>
<t tx="leo.20210713140956.88">def simxGetUIButtonProperty(clientID, uiHandle, uiButtonID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    prop = ct.c_int()
    return c_GetUIButtonProperty(clientID, uiHandle, uiButtonID, ct.byref(prop), operationMode), prop.value

</t>
<t tx="leo.20210713140956.89">def simxSetUIButtonProperty(clientID, uiHandle, uiButtonID, prop, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetUIButtonProperty(clientID, uiHandle, uiButtonID, prop, operationMode)

</t>
<t tx="leo.20210713140956.9">"""
Adaptation from:
https://github.com/openai/gym/blob/master/gym/envs/classic_control/cartpole.py
Which is based in:
Classic cart-pole system implemented by Rich Sutton et al.
Copied from http://incompleteideas.net/sutton/book/code/pole.c
permalink: https://perma.cc/C9ZM-652R
"""

from vrep_env import vrep_env
from vrep_env import vrep

import os
#vrep_scenes_path = os.environ['VREP_SCENES_PATH']
vrep_scenes_path = "C:/tmp/vrep-env/examples/scenes"

import math
import gym
from gym import spaces
from gym.utils import seeding
import numpy as np

</t>
<t tx="leo.20210713140956.90">def simxAddStatusbarMessage(clientID, message, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(message) is str):
        message=message.encode('utf-8')
    return c_AddStatusbarMessage(clientID, message, operationMode)

</t>
<t tx="leo.20210713140956.91">def simxAuxiliaryConsoleOpen(clientID, title, maxLines, mode, position, size, textColor, backgroundColor, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    consoleHandle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(title) is str):
        title=title.encode('utf-8')
    if position != None:
        c_position = (ct.c_int*2)(*position)
    else:
        c_position = None
    if size != None:
        c_size = (ct.c_int*2)(*size)
    else:
        c_size = None
    if textColor != None:
        c_textColor = (ct.c_float*3)(*textColor)
    else:
        c_textColor = None
    if backgroundColor != None:
        c_backgroundColor = (ct.c_float*3)(*backgroundColor)
    else:
        c_backgroundColor = None
    return c_AuxiliaryConsoleOpen(clientID, title, maxLines, mode, c_position, c_size, c_textColor, c_backgroundColor, ct.byref(consoleHandle), operationMode), consoleHandle.value

</t>
<t tx="leo.20210713140956.92">def simxAuxiliaryConsoleClose(clientID, consoleHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_AuxiliaryConsoleClose(clientID, consoleHandle, operationMode)

</t>
<t tx="leo.20210713140956.93">def simxAuxiliaryConsolePrint(clientID, consoleHandle, txt, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(txt) is str):
        txt=txt.encode('utf-8')
    return c_AuxiliaryConsolePrint(clientID, consoleHandle, txt, operationMode)

</t>
<t tx="leo.20210713140956.94">def simxAuxiliaryConsoleShow(clientID, consoleHandle, showState, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_AuxiliaryConsoleShow(clientID, consoleHandle, showState, operationMode)

</t>
<t tx="leo.20210713140956.95">def simxGetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    eulerAngles = (ct.c_float*3)()
    ret = c_GetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, eulerAngles, operationMode)
    arr = []
    for i in range(3):
        arr.append(eulerAngles[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.96">def simxGetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    quaternion = (ct.c_float*4)()
    ret = c_GetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quaternion, operationMode)
    arr = []
    for i in range(4):
        arr.append(quaternion[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.97">def simxGetObjectPosition(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    position = (ct.c_float*3)()
    ret = c_GetObjectPosition(clientID, objectHandle, relativeToObjectHandle, position, operationMode)
    arr = []
    for i in range(3):
        arr.append(position[i])
    return ret, arr

</t>
<t tx="leo.20210713140956.98">def simxSetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, eulerAngles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    angles = (ct.c_float*3)(*eulerAngles)
    return c_SetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, angles, operationMode)

</t>
<t tx="leo.20210713140956.99">def simxSetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quaternion, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    quat = (ct.c_float*4)(*quaternion)
    return c_SetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quat, operationMode)

</t>
<t tx="leo.20210713140957.1">
# for windows 64 bit coppeliasim 4.1.0 rev4
# put simConst content into sim.py
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20210713140957.10">def simxGetJointForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140957.100">def simxSynchronous(clientID, enable):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_Synchronous(clientID, enable)

</t>
<t tx="leo.20210713140957.101">def simxPauseCommunication(clientID, enable):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_PauseCommunication(clientID, enable)

</t>
<t tx="leo.20210713140957.102">def simxGetInMessageInfo(clientID, infoType):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    info = ct.c_int()
    return c_GetInMessageInfo(clientID, infoType, ct.byref(info)), info.value

</t>
<t tx="leo.20210713140957.103">def simxGetOutMessageInfo(clientID, infoType):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    info = ct.c_int()
    return c_GetOutMessageInfo(clientID, infoType, ct.byref(info)), info.value

</t>
<t tx="leo.20210713140957.104">def simxGetConnectionId(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_GetConnectionId(clientID)

</t>
<t tx="leo.20210713140957.105">def simxCreateBuffer(bufferSize):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_CreateBuffer(bufferSize)

</t>
<t tx="leo.20210713140957.106">def simxReleaseBuffer(buffer):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_ReleaseBuffer(buffer)

</t>
<t tx="leo.20210713140957.107">def simxTransferFile(clientID, filePathAndName, fileName_serverSide, timeOut, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(filePathAndName) is str):
        filePathAndName=filePathAndName.encode('utf-8')
    return c_TransferFile(clientID, filePathAndName, fileName_serverSide, timeOut, operationMode)

</t>
<t tx="leo.20210713140957.108">def simxEraseFile(clientID, fileName_serverSide, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(fileName_serverSide) is str):
        fileName_serverSide=fileName_serverSide.encode('utf-8')
    return c_EraseFile(clientID, fileName_serverSide, operationMode)

</t>
<t tx="leo.20210713140957.109">def simxCreateDummy(clientID, size, color, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if color != None:
        c_color = (ct.c_ubyte*12)(*color)
    else:
        c_color = None
    return c_CreateDummy(clientID, size, c_color, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140957.11">def simxGetJointMaxForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointMaxForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140957.110">def simxQuery(clientID, signalName, signalValue, retSignalName, timeOutInMs):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    retSignalLength = ct.c_int();
    retSignalValue = ct.POINTER(ct.c_ubyte)()

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(retSignalName) is str:
            retSignalName=retSignalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this

    ret = c_Query(clientID, signalName, sigV, len(signalValue), retSignalName, ct.byref(retSignalValue), ct.byref(retSignalLength), timeOutInMs)

    a = bytearray()
    if ret == 0:
        for i in range(retSignalLength.value):
            a.append(retSignalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140957.111">def simxGetObjectGroupData(clientID, objectType, dataType, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handles =[]
    intData =[]
    floatData =[]
    stringData =[]
    handlesC = ct.c_int()
    handlesP = ct.POINTER(ct.c_int)()
    intDataC = ct.c_int()
    intDataP = ct.POINTER(ct.c_int)()
    floatDataC = ct.c_int()
    floatDataP = ct.POINTER(ct.c_float)()
    stringDataC = ct.c_int()
    stringDataP = ct.POINTER(ct.c_char)()
    ret = c_GetObjectGroupData(clientID, objectType, dataType, ct.byref(handlesC), ct.byref(handlesP), ct.byref(intDataC), ct.byref(intDataP), ct.byref(floatDataC), ct.byref(floatDataP), ct.byref(stringDataC), ct.byref(stringDataP), operationMode)

    if ret == 0:
        for i in range(handlesC.value):
            handles.append(handlesP[i])
        for i in range(intDataC.value):
            intData.append(intDataP[i])
        for i in range(floatDataC.value):
            floatData.append(floatDataP[i])
        s = 0
        for i in range(stringDataC.value):
            a = bytearray()
            while stringDataP[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(stringDataP[s],'big'))
                else:
                    a.append(stringDataP[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                a=str(a,'utf-8')
            else:
                a=str(a)
            stringData.append(a)

    return ret, handles, intData, floatData, stringData

</t>
<t tx="leo.20210713140957.112">def simxCallScriptFunction(clientID, scriptDescription, options, functionName, inputInts, inputFloats, inputStrings, inputBuffer, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    inputBufferV=inputBuffer
    if sys.version_info[0] == 3:
        if type(scriptDescription) is str:
            scriptDescription=scriptDescription.encode('utf-8')
        if type(functionName) is str:
            functionName=functionName.encode('utf-8')
        if type(inputBuffer) is bytearray:
            inputBufferV  = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
        if type(inputBuffer) is str:
            inputBuffer=inputBuffer.encode('utf-8')
            inputBufferV  = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
    else:
        if type(inputBuffer) is bytearray:
            inputBufferV = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
        if type(inputBuffer) is str:
            inputBuffer=bytearray(inputBuffer)
            inputBufferV = (ct.c_ubyte*len(inputBuffer))(*inputBuffer)
    inputBufferV=ct.cast(inputBufferV,ct.POINTER(ct.c_ubyte)) # IronPython needs this

    c_inInts  = (ct.c_int*len(inputInts))(*inputInts)
    c_inInts = ct.cast(c_inInts,ct.POINTER(ct.c_int)) # IronPython needs this
    c_inFloats  = (ct.c_float*len(inputFloats))(*inputFloats)
    c_inFloats = ct.cast(c_inFloats,ct.POINTER(ct.c_float)) # IronPython needs this

    concatStr=''.encode('utf-8')
    for i in range(len(inputStrings)):
        a=inputStrings[i]
        a=a+'\0'
        if type(a) is str:
            a=a.encode('utf-8')
        concatStr=concatStr+a
    c_inStrings  = (ct.c_char*len(concatStr))(*concatStr)

    intDataOut =[]
    floatDataOut =[]
    stringDataOut =[]
    bufferOut =bytearray()

    intDataC = ct.c_int()
    intDataP = ct.POINTER(ct.c_int)()
    floatDataC = ct.c_int()
    floatDataP = ct.POINTER(ct.c_float)()
    stringDataC = ct.c_int()
    stringDataP = ct.POINTER(ct.c_char)()
    bufferS = ct.c_int()
    bufferP = ct.POINTER(ct.c_ubyte)()

    ret = c_CallScriptFunction(clientID,scriptDescription,options,functionName,len(inputInts),c_inInts,len(inputFloats),c_inFloats,len(inputStrings),c_inStrings,len(inputBuffer),inputBufferV,ct.byref(intDataC),ct.byref(intDataP),ct.byref(floatDataC),ct.byref(floatDataP),ct.byref(stringDataC),ct.byref(stringDataP),ct.byref(bufferS),ct.byref(bufferP),operationMode)

    if ret == 0:
        for i in range(intDataC.value):
            intDataOut.append(intDataP[i])
        for i in range(floatDataC.value):
            floatDataOut.append(floatDataP[i])
        s = 0
        for i in range(stringDataC.value):
            a = bytearray()
            while stringDataP[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(stringDataP[s],'big'))
                else:
                    a.append(stringDataP[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                a=str(a,'utf-8')
            else:
                a=str(a)
            stringDataOut.append(a)
        for i in range(bufferS.value):
            bufferOut.append(bufferP[i])
    if sys.version_info[0] != 3:
        bufferOut=str(bufferOut)

    return ret, intDataOut, floatDataOut, stringDataOut, bufferOut

</t>
<t tx="leo.20210713140957.113">def simxGetObjectVelocity(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    linearVel  = (ct.c_float*3)()
    angularVel = (ct.c_float*3)()
    ret = c_GetObjectVelocity(clientID, objectHandle, linearVel, angularVel, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(linearVel[i])
    arr2 = []
    for i in range(3):
        arr2.append(angularVel[i])
    return ret, arr1, arr2

</t>
<t tx="leo.20210713140957.114">def simxPackInts(intList):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        s=bytes()
        for i in range(len(intList)):
            s=s+struct.pack('&lt;i',intList[i])
        s=bytearray(s)
    else:
        s=''
        for i in range(len(intList)):
            s+=struct.pack('&lt;i',intList[i])
    return s

</t>
<t tx="leo.20210713140957.115">def simxUnpackInts(intsPackedInString):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    b=[]
    for i in range(int(len(intsPackedInString)/4)):
        b.append(struct.unpack('&lt;i',intsPackedInString[4*i:4*(i+1)])[0])
    return b

</t>
<t tx="leo.20210713140957.116">def simxPackFloats(floatList):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        s=bytes()
        for i in range(len(floatList)):
            s=s+struct.pack('&lt;f',floatList[i])
        s=bytearray(s)
    else:
        s=''
        for i in range(len(floatList)):
            s+=struct.pack('&lt;f',floatList[i])
    return s

</t>
<t tx="leo.20210713140957.117">def simxUnpackFloats(floatsPackedInString):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    b=[]
    for i in range(int(len(floatsPackedInString)/4)):
        b.append(struct.unpack('&lt;f',floatsPackedInString[4*i:4*(i+1)])[0])
    return b
</t>
<t tx="leo.20210713140957.118">
@others
@language python
@tabwidth -4

</t>
<t tx="leo.20210713140957.119">from vrep_env import vrep

import gym
import time
import numpy as np

</t>
<t tx="leo.20210713140957.12">def simxSetJointForce(clientID, jointHandle, force, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_SetJointMaxForce(clientID, jointHandle, force, operationMode)

</t>
<t tx="leo.20210713140957.120">class VrepEnv(gym.Env):
    """Superclass for V-REP environments.
    """
    @others
</t>
<t tx="leo.20210713140957.121">def __init__(self,server_addr,server_port,scene_path=None):
    # Parameters
    self.server_addr = server_addr
    self.server_port = server_port
    self.scene_path  = scene_path
    
    self.opM_get = vrep.simx_opmode_blocking
    #self.opM_get = vrep.simx_opmode_oneshot
    self.opM_set = vrep.simx_opmode_oneshot
    
    # Status
    self.cID = -1
    self.connected = False
    self.scene_loaded = (scene_path == None)
    self.sim_running = False
    
    # Remote API function meaningful return codes
    self.str_simx_return = [
        'simx_return_ok',
        'simx_return_novalue_flag',
        'simx_return_timeout_flag',
        'simx_return_illegal_opmode_flag',
        'simx_return_remote_error_flag',
        'simx_return_split_progress_flag',
        'simx_return_local_error_flag',
        'simx_return_initialize_error_flag']
    
    self.connect(server_addr,server_port)
    if not self.scene_loaded:
        self.load_scene(scene_path)

# internal methods

# Remote API call wrapper
#def RAPI_rc(self, ret_tuple, tolerance=vrep.simx_return_ok):
</t>
<t tx="leo.20210713140957.122">def RAPI_rc(self, ret_tuple, tolerance=vrep.simx_return_novalue_flag):
    istuple = isinstance(ret_tuple, tuple)
    ret = ret_tuple[0] if istuple else ret_tuple
    ''' need to comment this for execution
    if (ret != vrep.simx_return_ok) and (ret != tolerance):
        raise RuntimeError('Remote API return code: ('+str(ret)+': '+self.str_simx_return[ret.bit_length()]+')')
    '''
    return ret_tuple[1:] if istuple else None

</t>
<t tx="leo.20210713140957.123">def connect(self, server_addr, server_port):
    if self.connected:
        raise RuntimeError('Client is already connected.')
    attempts = 0
    max_attempts = 64
    while True:
        self.cID = vrep.simxStart(
            connectionAddress              = server_addr,
            connectionPort                 = server_port,
            waitUntilConnected             = True,
            doNotReconnectOnceDisconnected = True,
            timeOutInMs                    = 1000,
            commThreadCycleInMs            = 0)
        attempts += 1
        if self.cID != -1:
            self.connected = True
            break
        elif attempts &lt; max_attempts:
            print('Unable to connect to V-REP at ',server_addr,':',server_port,'. Retrying...')
            time.sleep(4)
        else:
            raise RuntimeError('Unable to connect to V-REP.')
    
    # Setting up debug signal
    self.set_integer_signal('sig_debug',1337)
    
    # Getting useful parameter values
    self.is_headless = self.get_boolean_parameter(vrep.sim_boolparam_headless)
    
    # If not headless, remove GUI clutter
    if not self.is_headless:
        self.set_boolean_parameter(vrep.sim_boolparam_browser_visible  ,False)
        self.set_boolean_parameter(vrep.sim_boolparam_hierarchy_visible,False)
        #self.set_boolean_parameter(vrep.sim_boolparam_display_enabled  ,False)
        # Remove GUI controls
        #self.set_boolean_parameter(vrep.sim_boolparam_play_toolbarbutton_enabled  ,False)
        #self.set_boolean_parameter(vrep.sim_boolparam_pause_toolbarbutton_enabled ,False)
        #self.set_boolean_parameter(vrep.sim_boolparam_stop_toolbarbutton_enabled  ,False)
        self.set_boolean_parameter(vrep.sim_boolparam_console_visible  ,False)
    
    # Optionally override real-time mode
    self.set_boolean_parameter(vrep.sim_boolparam_realtime_simulation, False)

</t>
<t tx="leo.20210713140957.124">def disconnect(self):
    if not self.connected:
        raise RuntimeError('Client is not even connected.')
    # Clearing debug signal
    vrep.simxClearIntegerSignal(self.cID,'sig_debug', vrep.simx_opmode_blocking)
    vrep.simxFinish(self.cID)
    self.connected = False

</t>
<t tx="leo.20210713140957.125">def load_scene(self, scene_path):
    if self.scene_loaded:
        raise RuntimeError('Scene is already loaded.')
    self.RAPI_rc(vrep.simxLoadScene(self.cID,scene_path,0, vrep.simx_opmode_blocking))
    self.scene_loaded = True

</t>
<t tx="leo.20210713140957.126">def close_scene(self):
    if not self.scene_loaded:
        raise RuntimeError('Scene is not loaded.')
    self.RAPI_rc(vrep.simxCloseScene(self.cID, vrep.simx_opmode_blocking))
    self.scene_loaded = False

</t>
<t tx="leo.20210713140957.127">def start_simulation(self):
    if self.sim_running:
        raise RuntimeError('Simulation is already running.')
    
    # Optionally override physics engine ( 0=Bullet, 1=ODE, 2=Vortex, 3=Newton )
    #self.set_integer_parameter(vrep.sim_intparam_dynamic_engine, 0) # 0=Bullet
    
    # Optionally override delta time
    #self.set_float_parameter(vrep.sim_floatparam_simulation_time_step, 25)
    
    self.RAPI_rc(vrep.simxSynchronous(self.cID,True))
    self.RAPI_rc(vrep.simxStartSimulation(self.cID, vrep.simx_opmode_blocking))
    
    # Enable Threaded Rendering for faster simulation
    if not self.is_headless:
        self.set_boolean_parameter(vrep.sim_boolparam_threaded_rendering_enabled,True)
    
    self.sim_running = True

</t>
<t tx="leo.20210713140957.128">def stop_simulation(self):
    if not self.sim_running:
        raise RuntimeError('Simulation is not running.')
    
    self.RAPI_rc(vrep.simxStopSimulation(self.cID, vrep.simx_opmode_blocking))
    
    # Checking if the server really stopped
    try:
        while True:
            self.RAPI_rc(vrep.simxGetIntegerSignal(self.cID,'sig_debug',vrep.simx_opmode_blocking))
            e = vrep.simxGetInMessageInfo(self.cID,vrep.simx_headeroffset_server_state)
            still_running = e[1] &amp; 1
            if not still_running:
                break
    except: pass
    self.sim_running = False

</t>
<t tx="leo.20210713140957.129">def step_simulation(self):
    self.RAPI_rc(vrep.simxSynchronousTrigger(self.cID))

# Below are all wrapped methods unrelated to connection/scene

# misc methods

</t>
<t tx="leo.20210713140957.13">def simxSetJointMaxForce(clientID, jointHandle, force, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_SetJointMaxForce(clientID, jointHandle, force, operationMode)

</t>
<t tx="leo.20210713140957.130">def add_statusbar_message(self, message):
    self.RAPI_rc(vrep.simxAddStatusbarMessage(self.cID, message, vrep.simx_opmode_blocking))

# object methods

</t>
<t tx="leo.20210713140957.131">def get_object_handle(self, name):
    handle, = self.RAPI_rc(vrep.simxGetObjectHandle(self.cID, name, vrep.simx_opmode_blocking))
    return handle

# "getters"

</t>
<t tx="leo.20210713140957.132">def obj_get_position(self, handle, relative_to=None):
    position, = self.RAPI_rc(vrep.simxGetObjectPosition( self.cID,handle,
        -1 if relative_to is None else relative_to,
        self.opM_get))
    return position
</t>
<t tx="leo.20210713140957.133">def obj_get_orientation(self, handle, relative_to=None):
    eulerAngles, = self.RAPI_rc(vrep.simxGetObjectOrientation( self.cID,handle,
        -1 if relative_to is None else relative_to,
        self.opM_get))
    return eulerAngles
</t>
<t tx="leo.20210713140957.134">def obj_get_orientation_continuous(self, handle, relative_to=None):
    ea = self.obj_get_orientation(handle,relative_to)
    return [
        np.sin(ea[0]),np.cos(ea[0]),
        np.sin(ea[1]),np.cos(ea[1]),
        np.sin(ea[2]),np.cos(ea[2])]

# (linearVel, angularVel)
</t>
<t tx="leo.20210713140957.135">def obj_get_velocity(self, handle):
    return self.RAPI_rc(vrep.simxGetObjectVelocity( self.cID,handle,
        self.opM_get))
</t>
<t tx="leo.20210713140957.136">def obj_get_joint_angle(self, handle):
    angle, = self.RAPI_rc(vrep.simxGetJointPosition( self.cID,handle,
            self.opM_get))
    #return -np.rad2deg(angle[0])
    return angle
</t>
<t tx="leo.20210713140957.137">def obj_get_joint_angle_continuous(self, handle):
    rad = self.obj_get_joint_angle(handle)
    return [np.sin(rad),np.cos(rad)]
</t>
<t tx="leo.20210713140957.138">def obj_get_joint_force(self, handle):
    force = self.RAPI_rc(vrep.simxGetJointForce( self.cID,handle,
            self.opM_get))
    return force
</t>
<t tx="leo.20210713140957.139">def obj_read_force_sensor(self, handle):
    state, forceVector, torqueVector = self.RAPI_rc(vrep.simxReadForceSensor( self.cID,handle,
        self.opM_get))
    if   state &amp; 1 != 1: # bit 0 not set
        return None # sensor data not (yet) available
    elif state &amp; 2 == 1: # bit 1 set
        return 0 # force sensor is broken
    else:
        return forceVector, torqueVector
</t>
<t tx="leo.20210713140957.14">def simxReadForceSensor(clientID, forceSensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    state = ct.c_ubyte()
    forceVector  = (ct.c_float*3)()
    torqueVector = (ct.c_float*3)()
    ret = c_ReadForceSensor(clientID, forceSensorHandle, ct.byref(state), forceVector, torqueVector, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(forceVector[i])
    arr2 = []
    for i in range(3):
        arr2.append(torqueVector[i])
    #if sys.version_info[0] == 3:
    #    state=state.value
    #else:
    #    state=ord(state.value)
    return ret, state.value, arr1, arr2

</t>
<t tx="leo.20210713140957.140">def obj_get_vision_image(self, handle):
    resolution, image = self.RAPI_rc(vrep.simxGetVisionSensorImage( self.cID,handle,
        0, # assume RGB
        self.opM_get,))
    dim, im = resolution, image
    nim = np.array(im, dtype='uint8')
    nim = np.reshape(nim, (dim[1], dim[0], 3))
    nim = np.flip(nim, 0)  # horizontal flip
    #nim = np.flip(nim, 2)  # RGB -&gt; BGR
    return nim

# "setters"

</t>
<t tx="leo.20210713140957.141">def obj_set_position_target(self, handle, angle):
    return self.RAPI_rc(vrep.simxSetJointTargetPosition( self.cID,handle,
        -np.deg2rad(angle),
        self.opM_set))
</t>
<t tx="leo.20210713140957.142">def obj_set_velocity(self, handle, v):
    return self.RAPI_rc(vrep.simxSetJointTargetVelocity( self.cID,handle,
        v,
        self.opM_set))
</t>
<t tx="leo.20210713140957.143">def obj_set_force(self, handle, f):
    return self.RAPI_rc(vrep.simxSetJointForce( self.cID,handle,
        f,
        self.opM_set))
</t>
<t tx="leo.20210713140957.144">def obj_set_position(self, handle, pos, relative_to=None):
    return self.RAPI_rc(vrep.simxSetObjectPosition( self.cID,handle,
        -1 if relative_to is None else relative_to,
        pos,
        self.opM_set))
</t>
<t tx="leo.20210713140957.145">def obj_set_orientation(self, handle, eulerAngles, relative_to=None):
    return self.RAPI_rc(vrep.simxSetObjectOrientation( self.cID,handle,
        -1 if relative_to is None else relative_to,
        eulerAngles,
        self.opM_set))
# collisions

</t>
<t tx="leo.20210713140957.146">def get_collision_handle(self, name):
    handle, = self.RAPI_rc(vrep.simxGetCollisionHandle(self.cID, name, vrep.simx_opmode_blocking))
    return handle
</t>
<t tx="leo.20210713140957.147">def read_collision(self, handle):
    collisionState, = self.RAPI_rc(vrep.simxReadCollision( self.cID,handle,
            self.opM_get))
    return collisionState

# signals

</t>
<t tx="leo.20210713140957.148">def set_integer_signal(self, sig_name, sig_val):
    return self.RAPI_rc(vrep.simxSetIntegerSignal( self.cID,
        sig_name, sig_val,
        self.opM_set))
</t>
<t tx="leo.20210713140957.149">def set_float_signal(self, sig_name, sig_val):
    return self.RAPI_rc(vrep.SetFloatSignal( self.cID,
        sig_name, sig_val,
        self.opM_set))
</t>
<t tx="leo.20210713140957.15">def simxBreakForceSensor(clientID, forceSensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    return c_BreakForceSensor(clientID, forceSensorHandle, operationMode)

</t>
<t tx="leo.20210713140957.150">def set_string_signal(self, sig_name, sig_val):
    return self.RAPI_rc(vrep.SetStringSignal( self.cID,
        sig_name, sig_val,
        self.opM_set))

</t>
<t tx="leo.20210713140957.151">def get_integer_signal(self, sig_name):
    return self.RAPI_rc(vrep.simxGetIntegerSignal( self.cID,
        sig_name,
        self.opM_get))
</t>
<t tx="leo.20210713140957.152">def get_float_signal(self, sig_name):
    return self.RAPI_rc(vrep.simxGetFloatSignal( self.cID,
        sig_name,
        self.opM_get))
</t>
<t tx="leo.20210713140957.153">def get_string_signal(self, sig_name):
    return self.RAPI_rc(vrep.simxGetStringSignal( self.cID,
        sig_name,
        self.opM_get))

# parameters

</t>
<t tx="leo.20210713140957.154">def set_boolean_parameter(self, param_id, param_val):
    return self.RAPI_rc(vrep.simxSetBooleanParameter( self.cID,
        param_id, param_val,
        vrep.simx_opmode_blocking))
</t>
<t tx="leo.20210713140957.155">def set_integer_parameter(self, param_id, param_val):
    return self.RAPI_rc(vrep.simxSetIntegerParameter( self.cID,
        param_id, param_val,
        vrep.simx_opmode_blocking))
</t>
<t tx="leo.20210713140957.156">def set_float_parameter(self, param_id, param_val):
    return self.RAPI_rc(vrep.simxSetFloatingParameter( self.cID,
        param_id, param_val,
        vrep.simx_opmode_blocking))
</t>
<t tx="leo.20210713140957.157">def set_array_parameter(self, param_id, param_val):
    return self.RAPI_rc(vrep.simxSetArrayParameter( self.cID,
        param_id, param_val,
        vrep.simx_opmode_blocking))

</t>
<t tx="leo.20210713140957.158">def get_boolean_parameter(self, param_id):
    return self.RAPI_rc(vrep.simxGetBooleanParameter( self.cID,
        param_id,
        vrep.simx_opmode_blocking))[0]
</t>
<t tx="leo.20210713140957.159">def get_integer_parameter(self, param_id):
    return self.RAPI_rc(vrep.simxGetIntegerParameter( self.cID,
        param_id,
        vrep.simx_opmode_blocking))[0]
</t>
<t tx="leo.20210713140957.16">def simxReadVisionSensor(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    detectionState = ct.c_ubyte()
    auxValues      = ct.POINTER(ct.c_float)()
    auxValuesCount = ct.POINTER(ct.c_int)()
    ret = c_ReadVisionSensor(clientID, sensorHandle, ct.byref(detectionState), ct.byref(auxValues), ct.byref(auxValuesCount), operationMode)

    auxValues2 = []
    if ret == 0:
        s = 0
        for i in range(auxValuesCount[0]):
            auxValues2.append(auxValues[s:s+auxValuesCount[i+1]])
            s += auxValuesCount[i+1]

        #free C buffers
        c_ReleaseBuffer(auxValues)
        c_ReleaseBuffer(auxValuesCount)

    return ret, bool(detectionState.value!=0), auxValues2

</t>
<t tx="leo.20210713140957.160">def get_float_parameter(self, param_id):
    return self.RAPI_rc(vrep.simxGetFloatingParameter( self.cID,
        param_id,
        vrep.simx_opmode_blocking))[0]
</t>
<t tx="leo.20210713140957.161">def get_array_parameter(self, param_id):
    return self.RAPI_rc(vrep.simxGetArrayParameter( self.cID,
        param_id,
        vrep.simx_opmode_blocking))[0]

# scripts
# child scripts
</t>
<t tx="leo.20210713140957.162">def call_childscript_function(self,obj_name,func_name,in_tuple):
    return self.RAPI_rc(vrep.simxCallScriptFunction(self.cID,
        obj_name,vrep.sim_scripttype_childscript,func_name,
        in_tuple[0],in_tuple[1],in_tuple[2],in_tuple[3],
        vrep.simx_opmode_blocking))

# openai/gym

# Set this in SOME subclasses
#metadata = {'render.modes': []}
#reward_range = (-np.inf, np.inf)

# Override in SOME subclasses
#def _close(self): pass

# Set these in ALL subclasses
#action_space = None
#observation_space = None

# Override in ALL subclasses
#def _step(self, action): raise NotImplementedError
#def _reset(self): raise NotImplementedError
#def _render(self, mode='human', close=False): return
#def _seed(self, seed=None): return []

#def _close(self):
</t>
<t tx="leo.20210713140957.163">def close(self):
    if self.sim_running:
        self.stop_simulation()
    # Closing the scene is unnecessary
    #if self.scene_loaded:
    #	self.close_scene()
    if self.connected:
        self.disconnect()

</t>
<t tx="leo.20210713140957.164">

@language python
@tabwidth -4
</t>
<t tx="leo.20210713140957.17">def simxGetObjectHandle(clientID, objectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(objectName) is str):
        objectName=objectName.encode('utf-8')
    return c_GetObjectHandle(clientID, objectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140957.18">def simxGetVisionSensorImage(clientID, sensorHandle, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    resolution = (ct.c_int*2)()
    c_image  = ct.POINTER(ct.c_byte)()
    bytesPerPixel = 3
    if (options and 1) != 0:
        bytesPerPixel = 1
    ret = c_GetVisionSensorImage(clientID, sensorHandle, resolution, ct.byref(c_image), options, operationMode)

    reso = []
    image = []
    if (ret == 0):
        image = [None]*resolution[0]*resolution[1]*bytesPerPixel
        for i in range(resolution[0] * resolution[1] * bytesPerPixel):
            image[i] = c_image[i]
        for i in range(2):
            reso.append(resolution[i])
    return ret, reso, image

</t>
<t tx="leo.20210713140957.19">def simxSetVisionSensorImage(clientID, sensorHandle, image, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    size = len(image)
    image_bytes  = (ct.c_byte*size)(*image)
    return c_SetVisionSensorImage(clientID, sensorHandle, image_bytes, size, options, operationMode)

</t>
<t tx="leo.20210713140957.2">import platform
import struct
import sys
import os
import ctypes as ct
# directly bring simConst.py into sim.py
#from simConst import *

#constants
#Scene object types. Values are serialized
sim_object_shape_type           =0
sim_object_joint_type           =1
sim_object_graph_type           =2
sim_object_camera_type          =3
sim_object_dummy_type           =4
sim_object_proximitysensor_type =5
sim_object_reserved1            =6
sim_object_reserved2            =7
sim_object_path_type            =8
sim_object_visionsensor_type    =9
sim_object_volume_type          =10
sim_object_mill_type            =11
sim_object_forcesensor_type     =12
sim_object_light_type           =13
sim_object_mirror_type          =14

#General object types. Values are serialized
sim_appobj_object_type          =109
sim_appobj_collision_type       =110
sim_appobj_distance_type        =111
sim_appobj_simulation_type      =112
sim_appobj_ik_type              =113
sim_appobj_constraintsolver_type=114
sim_appobj_collection_type      =115
sim_appobj_ui_type              =116
sim_appobj_script_type          =117
sim_appobj_pathplanning_type    =118
sim_appobj_RESERVED_type        =119
sim_appobj_texture_type         =120

# Ik calculation methods. Values are serialized
sim_ik_pseudo_inverse_method        =0
sim_ik_damped_least_squares_method  =1
sim_ik_jacobian_transpose_method    =2

# Ik constraints. Values are serialized
sim_ik_x_constraint         =1
sim_ik_y_constraint         =2
sim_ik_z_constraint         =4
sim_ik_alpha_beta_constraint=8
sim_ik_gamma_constraint     =16
sim_ik_avoidance_constraint =64

# Ik calculation results 
sim_ikresult_not_performed  =0
sim_ikresult_success        =1
sim_ikresult_fail           =2

# Scene object sub-types. Values are serialized 
# Light sub-types 
sim_light_omnidirectional_subtype   =1
sim_light_spot_subtype              =2
sim_light_directional_subtype       =3
# Joint sub-types 
sim_joint_revolute_subtype          =10
sim_joint_prismatic_subtype         =11
sim_joint_spherical_subtype         =12
# Shape sub-types 
sim_shape_simpleshape_subtype       =20
sim_shape_multishape_subtype        =21
# Proximity sensor sub-types 
sim_proximitysensor_pyramid_subtype =30
sim_proximitysensor_cylinder_subtype=31
sim_proximitysensor_disc_subtype    =32
sim_proximitysensor_cone_subtype    =33
sim_proximitysensor_ray_subtype     =34
# Mill sub-types 
sim_mill_pyramid_subtype            =40
sim_mill_cylinder_subtype           =41
sim_mill_disc_subtype               =42
sim_mill_cone_subtype               =42
# No sub-type 
sim_object_no_subtype               =200


#Scene object main properties (serialized)
sim_objectspecialproperty_collidable                    =0x0001
sim_objectspecialproperty_measurable                    =0x0002
#reserved                        =0x0004 
#reserved                        =0x0008 
sim_objectspecialproperty_detectable_ultrasonic            =0x0010
sim_objectspecialproperty_detectable_infrared            =0x0020
sim_objectspecialproperty_detectable_laser                =0x0040
sim_objectspecialproperty_detectable_inductive            =0x0080
sim_objectspecialproperty_detectable_capacitive            =0x0100
sim_objectspecialproperty_renderable                    =0x0200
sim_objectspecialproperty_detectable_all =sim_objectspecialproperty_detectable_ultrasonic|sim_objectspecialproperty_detectable_infrared|sim_objectspecialproperty_detectable_laser|sim_objectspecialproperty_detectable_inductive|sim_objectspecialproperty_detectable_capacitive
sim_objectspecialproperty_cuttable                        =0x0400
sim_objectspecialproperty_pathplanning_ignored            =0x0800

# Model properties (serialized)
sim_modelproperty_not_collidable                =0x0001
sim_modelproperty_not_measurable                =0x0002
sim_modelproperty_not_renderable                =0x0004
sim_modelproperty_not_detectable                =0x0008
sim_modelproperty_not_cuttable                    =0x0010
sim_modelproperty_not_dynamic                    =0x0020
sim_modelproperty_not_respondable                =0x0040 # cannot be selected if sim_modelproperty_not_dynamic is not selected 
sim_modelproperty_not_reset                        =0x0080 # Model is not reset at simulation end. This flag is cleared at simulation end 
sim_modelproperty_not_visible                    =0x0100 # Whole model is invisible independent of local visibility settings 
sim_modelproperty_not_model                        =0xf000 # object is not a model 


# Check the documentation instead of comments below!! 
# Following messages are dispatched to the Lua-message container 
sim_message_ui_button_state_change  =0    # a UI button slider etc. changed (due to a user's action). aux[0]=UI handle aux[1]=button handle aux[2]=button attributes aux[3]=slider position (if slider) 
sim_message_reserved9               =1    # Do not use 
sim_message_object_selection_changed=2
sim_message_reserved10                =3    # do not use 
sim_message_model_loaded            =4
sim_message_reserved11                =5    # do not use 
sim_message_keypress                =6    # a key was pressed while the focus was on a page (aux[0]=key aux[1]=ctrl and shift key state) 
sim_message_bannerclicked            =7    # a banner was clicked (aux[0]=banner ID) 


# Following messages are dispatched only to the C-API (not available from Lua) 
sim_message_for_c_api_only_start        =0x100      # Do not use 
sim_message_reserved1                   =0x101      # Do not use 
sim_message_reserved2                    =0x102      # Do not use 
sim_message_reserved3                    =0x103      # Do not use 
sim_message_eventcallback_scenesave        =0x104        # about to save a scene 
sim_message_eventcallback_modelsave        =0x105      # about to save a model (current selection will be saved) 
sim_message_eventcallback_moduleopen    =0x106        # called when simOpenModule in Lua is called 
sim_message_eventcallback_modulehandle    =0x107        # called when simHandleModule in Lua is called with argument false 
sim_message_eventcallback_moduleclose    =0x108        # called when simCloseModule in Lua is called 
sim_message_reserved4                    =0x109      # Do not use 
sim_message_reserved5                    =0x10a        # Do not use 
sim_message_reserved6                    =0x10b        # Do not use 
sim_message_reserved7                    =0x10c        # Do not use 
sim_message_eventcallback_instancepass    =0x10d        # Called once every main application loop pass. auxiliaryData[0] contains event flags of events that happened since last time 
sim_message_eventcallback_broadcast     =0x10e
sim_message_eventcallback_imagefilter_enumreset =0x10f
sim_message_eventcallback_imagefilter_enumerate      =0x110
sim_message_eventcallback_imagefilter_adjustparams   =0x111
sim_message_eventcallback_imagefilter_reserved       =0x112
sim_message_eventcallback_imagefilter_process        =0x113
sim_message_eventcallback_reserved1                  =0x114   # do not use 
sim_message_eventcallback_reserved2                  =0x115   # do not use 
sim_message_eventcallback_reserved3                  =0x116   # do not use 
sim_message_eventcallback_reserved4                  =0x117   # do not use 
sim_message_eventcallback_abouttoundo                 =0x118   # the undo button was hit and a previous state is about to be restored 
sim_message_eventcallback_undoperformed                 =0x119   # the undo button was hit and a previous state restored 
sim_message_eventcallback_abouttoredo                 =0x11a   # the redo button was hit and a future state is about to be restored  
sim_message_eventcallback_redoperformed                 =0x11b   # the redo button was hit and a future state restored  
sim_message_eventcallback_scripticondblclick         =0x11c   # scipt icon was double clicked.  (aux[0]=object handle associated with script set replyData[0] to 1 if script should not be opened)  
sim_message_eventcallback_simulationabouttostart     =0x11d
sim_message_eventcallback_simulationended            =0x11e
sim_message_eventcallback_reserved5                     =0x11f   # do not use 
sim_message_eventcallback_keypress                     =0x120   # a key was pressed while the focus was on a page (aux[0]=key aux[1]=ctrl and shift key state) 
sim_message_eventcallback_modulehandleinsensingpart  =0x121   # called when simHandleModule in Lua is called with argument true 
sim_message_eventcallback_renderingpass              =0x122   # called just before the scene is rendered 
sim_message_eventcallback_bannerclicked              =0x123   # called when a banner was clicked (aux[0]=banner ID) 
sim_message_eventcallback_menuitemselected           =0x124   # auxiliaryData[0] indicates the handle of the item auxiliaryData[1] indicates the state of the item 
sim_message_eventcallback_refreshdialogs             =0x125   # aux[0]=refresh degree (0=light 1=medium 2=full) 
sim_message_eventcallback_sceneloaded                =0x126
sim_message_eventcallback_modelloaded                =0x127
sim_message_eventcallback_instanceswitch             =0x128
sim_message_eventcallback_guipass                    =0x129
sim_message_eventcallback_mainscriptabouttobecalled  =0x12a
sim_message_eventcallback_rmlposition                =0x12b   #the command simRMLPosition was called. The appropriate plugin should handle the call
sim_message_eventcallback_rmlvelocity                =0x12c   # the command simRMLVelocity was called. The appropriate plugin should handle the call
sim_message_simulation_start_resume_request          =0x1000
sim_message_simulation_pause_request                 =0x1001
sim_message_simulation_stop_request                  =0x1002

# Scene object properties. Combine with the | operator 
sim_objectproperty_reserved1                =0x0000
sim_objectproperty_reserved2                =0x0001
sim_objectproperty_reserved3                =0x0002
sim_objectproperty_reserved4                =0x0003
sim_objectproperty_reserved5                =0x0004 # formely sim_objectproperty_visible 
sim_objectproperty_reserved6                =0x0008 # formely sim_objectproperty_wireframe 
sim_objectproperty_collapsed                =0x0010
sim_objectproperty_selectable                =0x0020
sim_objectproperty_reserved7                =0x0040
sim_objectproperty_selectmodelbaseinstead    =0x0080
sim_objectproperty_dontshowasinsidemodel    =0x0100
# reserved                                    =0x0200 
sim_objectproperty_canupdatedna                =0x0400
sim_objectproperty_selectinvisible            =0x0800
sim_objectproperty_depthinvisible            =0x1000


# type of arguments (input and output) for custom lua commands 
sim_lua_arg_nil     =0
sim_lua_arg_bool    =1    
sim_lua_arg_int     =2
sim_lua_arg_float   =3
sim_lua_arg_string  =4
sim_lua_arg_invalid =5
sim_lua_arg_table   =8

# custom user interface properties. Values are serialized. 
sim_ui_property_visible                        =0x0001
sim_ui_property_visibleduringsimulationonly    =0x0002
sim_ui_property_moveable                    =0x0004
sim_ui_property_relativetoleftborder        =0x0008
sim_ui_property_relativetotopborder            =0x0010
sim_ui_property_fixedwidthfont                =0x0020
sim_ui_property_systemblock                    =0x0040
sim_ui_property_settocenter                    =0x0080
sim_ui_property_rolledup                    =0x0100
sim_ui_property_selectassociatedobject        =0x0200
sim_ui_property_visiblewhenobjectselected    =0x0400


# button properties. Values are serialized. 
sim_buttonproperty_button                =0x0000
sim_buttonproperty_label                =0x0001
sim_buttonproperty_slider                =0x0002
sim_buttonproperty_editbox                =0x0003
sim_buttonproperty_staydown                =0x0008
sim_buttonproperty_enabled                =0x0010
sim_buttonproperty_borderless            =0x0020
sim_buttonproperty_horizontallycentered    =0x0040
sim_buttonproperty_ignoremouse            =0x0080
sim_buttonproperty_isdown                =0x0100
sim_buttonproperty_transparent            =0x0200
sim_buttonproperty_nobackgroundcolor    =0x0400
sim_buttonproperty_rollupaction            =0x0800
sim_buttonproperty_closeaction            =0x1000
sim_buttonproperty_verticallycentered    =0x2000
sim_buttonproperty_downupevent            =0x4000


# Simulation status 
sim_simulation_stopped                        =0x00                                # Simulation is stopped 
sim_simulation_paused                        =0x08                                # Simulation is paused 
sim_simulation_advancing                    =0x10                                # Simulation is advancing 
sim_simulation_advancing_firstafterstop        =sim_simulation_advancing|0x00        # First simulation pass (1x) 
sim_simulation_advancing_running            =sim_simulation_advancing|0x01        # Normal simulation pass (&gt;=1x) 
# reserved                                    =sim_simulation_advancing|0x02 
sim_simulation_advancing_lastbeforepause    =sim_simulation_advancing|0x03        # Last simulation pass before pause (1x) 
sim_simulation_advancing_firstafterpause    =sim_simulation_advancing|0x04        # First simulation pass after pause (1x) 
sim_simulation_advancing_abouttostop        =sim_simulation_advancing|0x05        # "Trying to stop" simulation pass (&gt;=1x) 
sim_simulation_advancing_lastbeforestop        =sim_simulation_advancing|0x06        # Last simulation pass (1x) 


# Script execution result (first return value) 
sim_script_no_error                    =0
sim_script_main_script_nonexistent    =1
sim_script_main_script_not_called    =2
sim_script_reentrance_error            =4
sim_script_lua_error                =8
sim_script_call_error                =16


 # Script types (serialized!) 
sim_scripttype_mainscript   =0
sim_scripttype_childscript  =1
sim_scripttype_jointctrlcallback  =4
sim_scripttype_contactcallback  =5
sim_scripttype_customizationscript  =6
sim_scripttype_generalcallback  =7

# API call error messages 
sim_api_errormessage_ignore    =0    # does not memorize nor output errors 
sim_api_errormessage_report    =1    # memorizes errors (default for C-API calls) 
sim_api_errormessage_output    =2  # memorizes and outputs errors (default for Lua-API calls) 


# special argument of some functions 
sim_handle_all                        =-2
sim_handle_all_except_explicit        =-3
sim_handle_self                        =-4
sim_handle_main_script                =-5
sim_handle_tree                        =-6
sim_handle_chain                    =-7
sim_handle_single                    =-8
sim_handle_default                    =-9
sim_handle_all_except_self            =-10
sim_handle_parent                    =-11


# special handle flags
sim_handleflag_assembly                =0x400000
sim_handleflag_model                =0x800000


# distance calculation methods (serialized) 
sim_distcalcmethod_dl               =0
sim_distcalcmethod_dac              =1
sim_distcalcmethod_max_dl_dac       =2
sim_distcalcmethod_dl_and_dac       =3
sim_distcalcmethod_sqrt_dl2_and_dac2=4
sim_distcalcmethod_dl_if_nonzero    =5
sim_distcalcmethod_dac_if_nonzero   =6


 # Generic dialog styles 
sim_dlgstyle_message        =0
sim_dlgstyle_input          =1
sim_dlgstyle_ok             =2
sim_dlgstyle_ok_cancel      =3
sim_dlgstyle_yes_no         =4
sim_dlgstyle_dont_center    =32# can be combined with one of above values. Only with this flag can the position of the related UI be set just after dialog creation  

 # Generic dialog return values 
sim_dlgret_still_open   =0
sim_dlgret_ok           =1
sim_dlgret_cancel       =2
sim_dlgret_yes          =3
sim_dlgret_no           =4


# Path properties 
sim_pathproperty_show_line                            =0x0001
sim_pathproperty_show_orientation                    =0x0002
sim_pathproperty_closed_path                        =0x0004
sim_pathproperty_automatic_orientation                =0x0008
sim_pathproperty_invert_velocity                    =0x0010
sim_pathproperty_infinite_acceleration                =0x0020
sim_pathproperty_flat_path                            =0x0040
sim_pathproperty_show_position                        =0x0080
sim_pathproperty_auto_velocity_profile_translation    =0x0100
sim_pathproperty_auto_velocity_profile_rotation        =0x0200
sim_pathproperty_endpoints_at_zero                    =0x0400
sim_pathproperty_keep_x_up                            =0x0800


 # drawing objects 
# following are mutually exclusive 
sim_drawing_points          =0            # 3 values per point (point size in pixels) 
sim_drawing_lines            =1            # 6 values per line (line size in pixels) 
sim_drawing_triangles        =2            # 9 values per triangle 
sim_drawing_trianglepoints    =3            # 6 values per point (3 for triangle position 3 for triangle normal vector) (triangle size in meters) 
sim_drawing_quadpoints        =4            # 6 values per point (3 for quad position 3 for quad normal vector) (quad size in meters) 
sim_drawing_discpoints        =5            # 6 values per point (3 for disc position 3 for disc normal vector) (disc size in meters) 
sim_drawing_cubepoints        =6          # 6 values per point (3 for cube position 3 for cube normal vector) (cube size in meters) 
sim_drawing_spherepoints    =7          # 3 values per point (sphere size in meters) 

# following can be or-combined 
sim_drawing_itemcolors                =0x00020 # +3 values per item (each item has its own ambient color (rgb values)).
                                             # Mutually exclusive with sim_drawing_vertexcolors 
sim_drawing_vertexcolors            =0x00040 # +3 values per vertex (each vertex has its own ambient color (rgb values). Only for sim_drawing_lines (+6) and for sim_drawing_triangles(+9)). Mutually exclusive with sim_drawing_itemcolors 
sim_drawing_itemsizes                =0x00080 # +1 value per item (each item has its own size). Not for sim_drawing_triangles 
sim_drawing_backfaceculling            =0x00100 # back faces are not displayed for all items 
sim_drawing_wireframe                =0x00200 # all items displayed in wireframe 
sim_drawing_painttag                =0x00400 # all items are tagged as paint (for additinal processing at a later stage) 
sim_drawing_followparentvisibility    =0x00800 # if the object is associated with a scene object then it follows that visibility otherwise it is always visible 
sim_drawing_cyclic                    =0x01000 # if the max item count was reached then the first items are overwritten. 
sim_drawing_50percenttransparency    =0x02000 # the drawing object will be 50% transparent 
sim_drawing_25percenttransparency    =0x04000 # the drawing object will be 25% transparent 
sim_drawing_12percenttransparency    =0x08000 # the drawing object will be 12.5% transparent 
sim_drawing_emissioncolor            =0x10000 # When used in combination with sim_drawing_itemcolors or sim_drawing_vertexcolors then the specified colors will be for the emissive component 
sim_drawing_facingcamera            =0x20000 # Only for trianglepoints quadpoints discpoints and cubepoints. If specified the normal verctor is calculated to face the camera (each item data requires 3 values less) 
sim_drawing_overlay                    =0x40000 # When specified objects are always drawn on top of "regular objects" 
sim_drawing_itemtransparency        =0x80000  # +1 value per item (each item has its own transparency value (0-1)). Not compatible with sim_drawing_vertexcolors 

# banner values 
# following can be or-combined 
sim_banner_left                        =0x00001 # Banners display on the left of the specified point 
sim_banner_right                    =0x00002 # Banners display on the right of the specified point 
sim_banner_nobackground                =0x00004 # Banners have no background rectangle 
sim_banner_overlay                    =0x00008 # When specified banners are always drawn on top of "regular objects" 
sim_banner_followparentvisibility    =0x00010 # if the object is associated with a scene object then it follows that visibility otherwise it is always visible 
sim_banner_clickselectsparent        =0x00020 # if the object is associated with a scene object then clicking the banner will select the scene object 
sim_banner_clicktriggersevent        =0x00040 # if the banner is clicked an event is triggered (sim_message_eventcallback_bannerclicked and sim_message_bannerclicked are generated) 
sim_banner_facingcamera                =0x00080 # If specified the banner will always face the camera by rotating around the banner's vertical axis (y-axis) 
sim_banner_fullyfacingcamera        =0x00100 # If specified the banner will always fully face the camera (the banner's orientation is same as the camera looking at it) 
sim_banner_backfaceculling            =0x00200 # If specified the banner will only be visible from one side 
sim_banner_keepsamesize                =0x00400 # If specified the banner will always appear in the same size. In that case size represents the character height in pixels 
sim_banner_bitmapfont                =0x00800 # If specified a fixed-size bitmap font is used. The text will also always fully face the camera and be right 
                                             # to the specified position. Bitmap fonts are not clickable 


# particle objects following are mutually exclusive 
sim_particle_points1        =0  # 6 values per point (pt1 and pt2. Pt1 is start position pt2-pt1 is the initial velocity vector). i
                                #Point is 1 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_points2        =1    # 6 values per point. Point is 2 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_points4        =2    # 6 values per point. Point is 4 pixel big. Only appearance is a point internally handled as a perfect sphere 
sim_particle_roughspheres    =3    # 6 values per sphere. Only appearance is rough. Internally a perfect sphere 
sim_particle_spheres        =4    # 6 values per sphere. Internally a perfect sphere 




# following can be or-combined 
sim_particle_respondable1to4        =0x0020 # the particles are respondable against shapes (against all objects that have at least one bit 1-4 activated in the global respondable mask) 
sim_particle_respondable5to8        =0x0040 # the particles are respondable against shapes (against all objects that have at least one bit 5-8 activated in the global respondable mask) 
sim_particle_particlerespondable    =0x0080 # the particles are respondable against each other 
sim_particle_ignoresgravity            =0x0100 # the particles ignore the effect of gravity. Not compatible with sim_particle_water 
sim_particle_invisible                =0x0200 # the particles are invisible 
sim_particle_itemsizes                =0x0400 # +1 value per particle (each particle can have a different size) 
sim_particle_itemdensities            =0x0800 # +1 value per particle (each particle can have a different density) 
sim_particle_itemcolors                =0x1000 # +3 values per particle (each particle can have a different color) 
sim_particle_cyclic                    =0x2000 # if the max item count was reached then the first items are overwritten. 
sim_particle_emissioncolor            =0x4000 # When used in combination with sim_particle_itemcolors then the specified colors will be for the emissive component 
sim_particle_water                    =0x8000 # the particles are water particles (no weight in the water (i.e. when z&lt;0)). Not compatible with sim_particle_ignoresgravity 
sim_particle_painttag                =0x10000 # The particles can be seen by vision sensors (sim_particle_invisible must not be set) 




# custom user interface menu attributes 
sim_ui_menu_title        =1
sim_ui_menu_minimize    =2
sim_ui_menu_close        =4
sim_ui_menu_systemblock =8



# Boolean parameters 
sim_boolparam_hierarchy_visible                 =0
sim_boolparam_console_visible                   =1
sim_boolparam_collision_handling_enabled        =2
sim_boolparam_distance_handling_enabled         =3
sim_boolparam_ik_handling_enabled               =4
sim_boolparam_gcs_handling_enabled              =5
sim_boolparam_dynamics_handling_enabled         =6
sim_boolparam_joint_motion_handling_enabled     =7
sim_boolparam_path_motion_handling_enabled      =8
sim_boolparam_proximity_sensor_handling_enabled =9
sim_boolparam_vision_sensor_handling_enabled    =10
sim_boolparam_mill_handling_enabled             =11
sim_boolparam_browser_visible                   =12
sim_boolparam_scene_and_model_load_messages     =13
sim_reserved0                                   =14
sim_boolparam_shape_textures_are_visible        =15
sim_boolparam_display_enabled                   =16
sim_boolparam_infotext_visible                  =17
sim_boolparam_statustext_open                   =18
sim_boolparam_fog_enabled                       =19
sim_boolparam_rml2_available                    =20
sim_boolparam_rml4_available                    =21
sim_boolparam_mirrors_enabled                    =22
sim_boolparam_aux_clip_planes_enabled            =23
sim_boolparam_full_model_copy_from_api            =24
sim_boolparam_realtime_simulation                =25
sim_boolparam_force_show_wireless_emission        =27
sim_boolparam_force_show_wireless_reception        =28
sim_boolparam_video_recording_triggered            =29
sim_boolparam_threaded_rendering_enabled        =32
sim_boolparam_fullscreen                        =33
sim_boolparam_headless                            =34
sim_boolparam_hierarchy_toolbarbutton_enabled    =35
sim_boolparam_browser_toolbarbutton_enabled        =36
sim_boolparam_objectshift_toolbarbutton_enabled    =37
sim_boolparam_objectrotate_toolbarbutton_enabled=38
sim_boolparam_force_calcstruct_all_visible        =39
sim_boolparam_force_calcstruct_all                =40
sim_boolparam_exit_request                        =41
sim_boolparam_play_toolbarbutton_enabled        =42
sim_boolparam_pause_toolbarbutton_enabled        =43
sim_boolparam_stop_toolbarbutton_enabled        =44
sim_boolparam_waiting_for_trigger                =45


# Integer parameters 
sim_intparam_error_report_mode      =0  # Check sim_api_errormessage_... constants above for valid values 
sim_intparam_program_version        =1  # e.g Version 2.1.4 --&gt; 20104. Can only be read 
sim_intparam_instance_count         =2  # do not use anymore (always returns 1 since CoppeliaSim 2.5.11) 
sim_intparam_custom_cmd_start_id    =3  # can only be read 
sim_intparam_compilation_version    =4  # 0=evaluation version 1=full version 2=player version. Can only be read 
sim_intparam_current_page           =5
sim_intparam_flymode_camera_handle  =6  # can only be read 
sim_intparam_dynamic_step_divider   =7  # can only be read 
sim_intparam_dynamic_engine         =8  # 0=Bullet 1=ODE. 2=Vortex.
sim_intparam_server_port_start      =9  # can only be read 
sim_intparam_server_port_range      =10 # can only be read 
sim_intparam_visible_layers         =11
sim_intparam_infotext_style         =12
sim_intparam_settings               =13
sim_intparam_edit_mode_type         =14 # can only be read 
sim_intparam_server_port_next       =15 # is initialized at sim_intparam_server_port_start 
sim_intparam_qt_version             =16 # version of the used Qt framework 
sim_intparam_event_flags_read       =17 # can only be read 
sim_intparam_event_flags_read_clear =18 # can only be read 
sim_intparam_platform               =19 # can only be read 
sim_intparam_scene_unique_id        =20 # can only be read 
sim_intparam_work_thread_count      =21
sim_intparam_mouse_x                =22
sim_intparam_mouse_y                =23
sim_intparam_core_count             =24
sim_intparam_work_thread_calc_time_ms =25
sim_intparam_idle_fps               =26
sim_intparam_prox_sensor_select_down =27
sim_intparam_prox_sensor_select_up  =28
sim_intparam_stop_request_counter   =29
sim_intparam_program_revision       =30
sim_intparam_mouse_buttons          =31
sim_intparam_dynamic_warning_disabled_mask =32
sim_intparam_simulation_warning_disabled_mask =33
sim_intparam_scene_index            =34
sim_intparam_motionplanning_seed    =35
sim_intparam_speedmodifier          =36

# Float parameters 
sim_floatparam_rand=0 # random value (0.0-1.0) 
sim_floatparam_simulation_time_step =1
sim_floatparam_stereo_distance        =2

# String parameters 
sim_stringparam_application_path=0 # path of CoppeliaSim's executable 
sim_stringparam_video_filename=1
sim_stringparam_app_arg1            =2
sim_stringparam_app_arg2            =3
sim_stringparam_app_arg3            =4
sim_stringparam_app_arg4            =5
sim_stringparam_app_arg5            =6
sim_stringparam_app_arg6            =7
sim_stringparam_app_arg7            =8
sim_stringparam_app_arg8            =9
sim_stringparam_app_arg9            =10
sim_stringparam_scene_path_and_name    =13

# Array parameters 
sim_arrayparam_gravity          =0
sim_arrayparam_fog              =1
sim_arrayparam_fog_color        =2
sim_arrayparam_background_color1=3
sim_arrayparam_background_color2=4
sim_arrayparam_ambient_light    =5
sim_arrayparam_random_euler        =6

sim_objintparam_visibility_layer= 10
sim_objfloatparam_abs_x_velocity= 11
sim_objfloatparam_abs_y_velocity= 12
sim_objfloatparam_abs_z_velocity= 13
sim_objfloatparam_abs_rot_velocity= 14
sim_objfloatparam_objbbox_min_x= 15
sim_objfloatparam_objbbox_min_y= 16
sim_objfloatparam_objbbox_min_z= 17
sim_objfloatparam_objbbox_max_x= 18
sim_objfloatparam_objbbox_max_y= 19
sim_objfloatparam_objbbox_max_z= 20
sim_objfloatparam_modelbbox_min_x= 21
sim_objfloatparam_modelbbox_min_y= 22
sim_objfloatparam_modelbbox_min_z= 23
sim_objfloatparam_modelbbox_max_x= 24
sim_objfloatparam_modelbbox_max_y= 25
sim_objfloatparam_modelbbox_max_z= 26
sim_objintparam_collection_self_collision_indicator= 27
sim_objfloatparam_transparency_offset= 28
sim_objintparam_child_role= 29
sim_objintparam_parent_role= 30
sim_objintparam_manipulation_permissions= 31
sim_objintparam_illumination_handle= 32

sim_visionfloatparam_near_clipping= 1000
sim_visionfloatparam_far_clipping= 1001
sim_visionintparam_resolution_x= 1002
sim_visionintparam_resolution_y= 1003
sim_visionfloatparam_perspective_angle= 1004
sim_visionfloatparam_ortho_size= 1005
sim_visionintparam_disabled_light_components= 1006
sim_visionintparam_rendering_attributes= 1007
sim_visionintparam_entity_to_render= 1008
sim_visionintparam_windowed_size_x= 1009
sim_visionintparam_windowed_size_y= 1010
sim_visionintparam_windowed_pos_x= 1011
sim_visionintparam_windowed_pos_y= 1012
sim_visionintparam_pov_focal_blur= 1013
sim_visionfloatparam_pov_blur_distance= 1014
sim_visionfloatparam_pov_aperture= 1015
sim_visionintparam_pov_blur_sampled= 1016
sim_visionintparam_render_mode= 1017

sim_jointintparam_motor_enabled= 2000
sim_jointintparam_ctrl_enabled= 2001
sim_jointfloatparam_pid_p= 2002
sim_jointfloatparam_pid_i= 2003
sim_jointfloatparam_pid_d= 2004
sim_jointfloatparam_intrinsic_x= 2005
sim_jointfloatparam_intrinsic_y= 2006
sim_jointfloatparam_intrinsic_z= 2007
sim_jointfloatparam_intrinsic_qx= 2008
sim_jointfloatparam_intrinsic_qy= 2009
sim_jointfloatparam_intrinsic_qz= 2010
sim_jointfloatparam_intrinsic_qw= 2011
sim_jointfloatparam_velocity= 2012
sim_jointfloatparam_spherical_qx= 2013
sim_jointfloatparam_spherical_qy= 2014
sim_jointfloatparam_spherical_qz= 2015
sim_jointfloatparam_spherical_qw= 2016
sim_jointfloatparam_upper_limit= 2017
sim_jointfloatparam_kc_k= 2018
sim_jointfloatparam_kc_c= 2019
sim_jointfloatparam_ik_weight= 2021
sim_jointfloatparam_error_x= 2022
sim_jointfloatparam_error_y= 2023
sim_jointfloatparam_error_z= 2024
sim_jointfloatparam_error_a= 2025
sim_jointfloatparam_error_b= 2026
sim_jointfloatparam_error_g= 2027
sim_jointfloatparam_error_pos= 2028
sim_jointfloatparam_error_angle= 2029
sim_jointintparam_velocity_lock= 2030
sim_jointintparam_vortex_dep_handle= 2031
sim_jointfloatparam_vortex_dep_multiplication= 2032
sim_jointfloatparam_vortex_dep_offset= 2033

sim_shapefloatparam_init_velocity_x= 3000
sim_shapefloatparam_init_velocity_y= 3001
sim_shapefloatparam_init_velocity_z= 3002
sim_shapeintparam_static= 3003
sim_shapeintparam_respondable= 3004
sim_shapefloatparam_mass= 3005
sim_shapefloatparam_texture_x= 3006
sim_shapefloatparam_texture_y= 3007
sim_shapefloatparam_texture_z= 3008
sim_shapefloatparam_texture_a= 3009
sim_shapefloatparam_texture_b= 3010
sim_shapefloatparam_texture_g= 3011
sim_shapefloatparam_texture_scaling_x= 3012
sim_shapefloatparam_texture_scaling_y= 3013
sim_shapeintparam_culling= 3014
sim_shapeintparam_wireframe= 3015
sim_shapeintparam_compound= 3016
sim_shapeintparam_convex= 3017
sim_shapeintparam_convex_check= 3018
sim_shapeintparam_respondable_mask= 3019
sim_shapefloatparam_init_velocity_a= 3020
sim_shapefloatparam_init_velocity_b= 3021
sim_shapefloatparam_init_velocity_g= 3022
sim_shapestringparam_color_name= 3023
sim_shapeintparam_edge_visibility= 3024
sim_shapefloatparam_shading_angle= 3025
sim_shapefloatparam_edge_angle= 3026
sim_shapeintparam_edge_borders_hidden= 3027

sim_proxintparam_ray_invisibility= 4000

sim_forcefloatparam_error_x= 5000
sim_forcefloatparam_error_y= 5001
sim_forcefloatparam_error_z= 5002
sim_forcefloatparam_error_a= 5003
sim_forcefloatparam_error_b= 5004
sim_forcefloatparam_error_g= 5005
sim_forcefloatparam_error_pos= 5006
sim_forcefloatparam_error_angle= 5007

sim_lightintparam_pov_casts_shadows= 8000

sim_cameraintparam_disabled_light_components= 9000
sim_camerafloatparam_perspective_angle= 9001
sim_camerafloatparam_ortho_size= 9002
sim_cameraintparam_rendering_attributes= 9003
sim_cameraintparam_pov_focal_blur= 9004
sim_camerafloatparam_pov_blur_distance= 9005
sim_camerafloatparam_pov_aperture= 9006
sim_cameraintparam_pov_blur_samples= 9007

sim_dummyintparam_link_type= 10000

sim_mirrorfloatparam_width= 12000
sim_mirrorfloatparam_height= 12001
sim_mirrorfloatparam_reflectance= 12002
sim_mirrorintparam_enable= 12003

sim_pplanfloatparam_x_min= 20000
sim_pplanfloatparam_x_range= 20001
sim_pplanfloatparam_y_min= 20002
sim_pplanfloatparam_y_range= 20003
sim_pplanfloatparam_z_min= 20004
sim_pplanfloatparam_z_range= 20005
sim_pplanfloatparam_delta_min= 20006
sim_pplanfloatparam_delta_range= 20007

sim_mplanintparam_nodes_computed= 25000
sim_mplanintparam_prepare_nodes= 25001
sim_mplanintparam_clear_nodes= 25002

# User interface elements 
sim_gui_menubar                        =0x0001
sim_gui_popups                        =0x0002
sim_gui_toolbar1                    =0x0004
sim_gui_toolbar2                    =0x0008
sim_gui_hierarchy                    =0x0010
sim_gui_infobar                        =0x0020
sim_gui_statusbar                    =0x0040
sim_gui_scripteditor                =0x0080
sim_gui_scriptsimulationparameters    =0x0100
sim_gui_dialogs                        =0x0200
sim_gui_browser                        =0x0400
sim_gui_all                            =0xffff


# Joint modes 
sim_jointmode_passive       =0
sim_jointmode_motion        =1
sim_jointmode_ik            =2
sim_jointmode_ikdependent   =3
sim_jointmode_dependent     =4
sim_jointmode_force         =5


# Navigation and selection modes with the mouse. Lower byte values are mutually exclusive upper byte bits can be combined 
sim_navigation_passive                    =0x0000
sim_navigation_camerashift                =0x0001
sim_navigation_camerarotate                =0x0002
sim_navigation_camerazoom                =0x0003
sim_navigation_cameratilt                =0x0004
sim_navigation_cameraangle                =0x0005
sim_navigation_camerafly                =0x0006
sim_navigation_objectshift                =0x0007
sim_navigation_objectrotate                =0x0008
sim_navigation_reserved2                =0x0009
sim_navigation_reserved3                =0x000A
sim_navigation_jointpathtest            =0x000B
sim_navigation_ikmanip                    =0x000C
sim_navigation_objectmultipleselection    =0x000D
# Bit-combine following values and add them to one of above's values for a valid navigation mode 
sim_navigation_reserved4                =0x0100
sim_navigation_clickselection            =0x0200
sim_navigation_ctrlselection            =0x0400
sim_navigation_shiftselection            =0x0800
sim_navigation_camerazoomwheel            =0x1000
sim_navigation_camerarotaterightbutton    =0x2000



#Remote API constants
SIMX_VERSION                    =0 
# Remote API message header structure 
SIMX_HEADER_SIZE                =18
simx_headeroffset_crc           =0    # 1 simxUShort. Generated by the client or server. The CRC for the message 
simx_headeroffset_version       =2    # 1 byte. Generated by the client or server. The version of the remote API software 
simx_headeroffset_message_id    =3    # 1 simxInt. Generated by the client (and used in a reply by the server) 
simx_headeroffset_client_time   =7    # 1 simxInt. Client time stamp generated by the client (and sent back by the server) 
simx_headeroffset_server_time   =11    # 1 simxInt. Generated by the server when a reply is generated. The server timestamp 
simx_headeroffset_scene_id      =15    # 1 simxUShort. Generated by the server. A unique ID identifying the scene currently displayed 
simx_headeroffset_server_state  =17    # 1 byte. Generated by the server. Bit coded 0 set --&gt; simulation not stopped 1 set --&gt; simulation paused 2 set --&gt; real-time switch on 3-5 edit mode type (0=no edit mode 1=triangle 2=vertex 3=edge 4=path 5=UI)  

# Remote API command header 
SIMX_SUBHEADER_SIZE                 =26
simx_cmdheaderoffset_mem_size       =0    # 1 simxInt. Generated by the client or server. The buffer size of the command. 
simx_cmdheaderoffset_full_mem_size  =4    # 1 simxInt. Generated by the client or server. The full buffer size of the command (applies to split chunks). 
simx_cmdheaderoffset_pdata_offset0  =8    # 1 simxUShort. Generated by the client or server. The amount of data that is part of the command identification. 
simx_cmdheaderoffset_pdata_offset1  =10    # 1 simxInt. Generated by the client or server. The amount of shift of the pure data buffer (applies to split chunks). 
simx_cmdheaderoffset_cmd=14    # 1 simxInt. Generated by the client (and used in a reply by the server). The command combined with the operation mode of the command. 
simx_cmdheaderoffset_delay_or_split =18    # 1 simxUShort. Generated by the client or server. The amount of delay in ms of a continuous command or the max. pure data size to send at once (applies to split commands). 
simx_cmdheaderoffset_sim_time       =20    # 1 simxInt. Generated by the server. The simulation time (in ms) when the command was executed (or 0 if simulation is not running) 
simx_cmdheaderoffset_status         =24    # 1 byte. Generated by the server. (1 bit 0 is set --&gt; error in function execution on server side). The client writes bit 1 if command cannot be overwritten
simx_cmdheaderoffset_reserved       =25    # 1 byte. Not yet used 





# Regular operation modes 
simx_opmode_oneshot                =0x000000 # sends command as one chunk. Reply will also come as one chunk. Doesn't wait for the reply. 
simx_opmode_blocking            =0x010000 # sends command as one chunk. Reply will also come as one chunk. Waits for the reply (_REPLY_WAIT_TIMEOUT_IN_MS is the timeout). 
simx_opmode_oneshot_wait        =0x010000 # sends command as one chunk. Reply will also come as one chunk. Waits for the reply (_REPLY_WAIT_TIMEOUT_IN_MS is the timeout). 
simx_opmode_continuous            =0x020000  
simx_opmode_streaming            =0x020000 # sends command as one chunk. Command will be stored on the server and always executed 
                                                      #(every x ms (as far as possible) where x can be 0-65535. just add x to opmode_continuous). 
                                                      # A reply will be sent continuously each time as one chunk. Doesn't wait for the reply. 

# Operation modes for heavy data 
simx_opmode_oneshot_split        =0x030000   # sends command as several chunks (max chunk size is x bytes where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to opmode_oneshot_split). Reply will also come as several chunks. Doesn't wait for the reply.      
simx_opmode_continuous_split    =0x040000
simx_opmode_streaming_split    =0x040000    # sends command as several chunks (max chunk size is x bytes where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to opmode_continuous_split). Command will be stored on the server and always executed. A reply will be sent continuously each time as several chunks. Doesn't wait for the reply. 

# Special operation modes 
simx_opmode_discontinue            =0x050000    # removes and cancels all commands stored on the client or server side (also continuous commands) 
simx_opmode_buffer                =0x060000    # doesn't send anything but checks if a reply for the given command is available in the input buffer (i.e. previously received from the server) 
simx_opmode_remove                =0x070000    # doesn't send anything and doesn't return any specific value. It just erases a similar command reply in the inbox (to free some memory) 


# Command return codes 
simx_return_ok                    =0x000000
simx_return_novalue_flag        =0x000001        # input buffer doesn't contain the specified command 
simx_return_timeout_flag        =0x000002        # command reply not received in time for opmode_oneshot_wait operation mode 
simx_return_illegal_opmode_flag    =0x000004        # command doesn't support the specified operation mode 
simx_return_remote_error_flag    =0x000008        # command caused an error on the server side 
simx_return_split_progress_flag    =0x000010        # previous similar command not yet fully processed (applies to opmode_oneshot_split operation modes) 
simx_return_local_error_flag    =0x000020        # command caused an error on the client side 
simx_return_initialize_error_flag    =0x000040        # simxStart was not yet called 

# Following for backward compatibility (same as above) 
simx_error_noerror                =0x000000
simx_error_novalue_flag            =0x000001        # input buffer doesn't contain the specified command 
simx_error_timeout_flag            =0x000002        # command reply not received in time for opmode_oneshot_wait operation mode 
simx_error_illegal_opmode_flag    =0x000004        # command doesn't support the specified operation mode 
simx_error_remote_error_flag    =0x000008        # command caused an error on the server side 
simx_error_split_progress_flag    =0x000010        # previous similar command not yet fully processed (applies to opmode_oneshot_split operation modes) 
simx_error_local_error_flag        =0x000020        # command caused an error on the client side 
simx_error_initialize_error_flag        =0x000040        # simxStart was not yet called 




#load library
libsimx = None
try:
    file_extension = '.so'
    if platform.system() =='cli':
        file_extension = '.dll'
    elif platform.system() =='Windows':
        file_extension = '.dll'
    elif platform.system() == 'Darwin':
        file_extension = '.dylib'
    else:
        file_extension = '.so'
    libfullpath = os.path.join(os.path.dirname(__file__), 'remoteApi' + file_extension)
    libsimx = ct.CDLL(libfullpath)
except:
    print ('----------------------------------------------------')
    print ('The remoteApi library could not be loaded. Make sure')
    print ('it is located in the same folder as "sim.py", or')
    print ('appropriately adjust the file "sim.py"')
    print ('----------------------------------------------------')
    print ('')

#ctypes wrapper prototypes
c_GetJointPosition          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointPosition", libsimx))
c_SetJointPosition          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointPosition", libsimx))
c_GetJointMatrix            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointMatrix", libsimx))
c_SetSphericalJointMatrix   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetSphericalJointMatrix", libsimx))
c_SetJointTargetVelocity    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointTargetVelocity", libsimx))
c_SetJointTargetPosition    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointTargetPosition", libsimx))
c_GetJointForce             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointForce", libsimx))
c_GetJointMaxForce          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetJointMaxForce", libsimx))
c_SetJointForce             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointMaxForce", libsimx))
c_SetJointMaxForce          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetJointMaxForce", libsimx))
c_ReadForceSensor           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.c_int32)(("simxReadForceSensor", libsimx))
c_BreakForceSensor          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxBreakForceSensor", libsimx))
c_ReadVisionSensor          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.POINTER(ct.c_float)), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxReadVisionSensor", libsimx))
c_GetObjectHandle           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectHandle", libsimx))
c_GetVisionSensorImage      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_byte)), ct.c_ubyte, ct.c_int32)(("simxGetVisionSensorImage", libsimx))
c_SetVisionSensorImage      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_byte), ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetVisionSensorImage", libsimx))
c_GetVisionSensorDepthBuffer= ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)), ct.c_int32)(("simxGetVisionSensorDepthBuffer", libsimx))
c_GetObjectChild            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectChild", libsimx))
c_GetObjectParent           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectParent", libsimx))
c_ReadProximitySensor       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_float), ct.c_int32)(("simxReadProximitySensor", libsimx))
c_LoadModel                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.POINTER(ct.c_int32), ct.c_int32)(("simxLoadModel", libsimx))
c_LoadUI                    = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxLoadUI", libsimx))
c_LoadScene                 =  ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_ubyte, ct.c_int32)(("simxLoadScene", libsimx))
c_StartSimulation           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxStartSimulation", libsimx))
c_PauseSimulation           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxPauseSimulation", libsimx))
c_StopSimulation            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxStopSimulation", libsimx))
c_GetUIHandle               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIHandle", libsimx))
c_GetUISlider               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUISlider", libsimx))
c_SetUISlider               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetUISlider", libsimx))
c_GetUIEventButton          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIEventButton", libsimx))
c_GetUIButtonProperty       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetUIButtonProperty", libsimx))
c_SetUIButtonProperty       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetUIButtonProperty", libsimx))
c_AddStatusbarMessage       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxAddStatusbarMessage", libsimx))
c_AuxiliaryConsoleOpen      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.c_int32)(("simxAuxiliaryConsoleOpen", libsimx))
c_AuxiliaryConsoleClose     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxAuxiliaryConsoleClose", libsimx))
c_AuxiliaryConsolePrint     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxAuxiliaryConsolePrint", libsimx))
c_AuxiliaryConsoleShow      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxAuxiliaryConsoleShow", libsimx))
c_GetObjectOrientation      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectOrientation", libsimx))
c_GetObjectQuaternion       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectQuaternion", libsimx))
c_GetObjectPosition         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectPosition", libsimx))
c_SetObjectOrientation      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectOrientation", libsimx))
c_SetObjectQuaternion       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectQuaternion", libsimx))
c_SetObjectPosition         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetObjectPosition", libsimx))
c_SetObjectParent           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetObjectParent", libsimx))
c_SetUIButtonLabel          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32)(("simxSetUIButtonLabel", libsimx))
c_GetLastErrors             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetLastErrors", libsimx))
c_GetArrayParameter         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetArrayParameter", libsimx))
c_SetArrayParameter         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxSetArrayParameter", libsimx))
c_GetBooleanParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxGetBooleanParameter", libsimx))
c_SetBooleanParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_ubyte, ct.c_int32)(("simxSetBooleanParameter", libsimx))
c_GetIntegerParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetIntegerParameter", libsimx))
c_SetIntegerParameter       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetIntegerParameter", libsimx))
c_GetFloatingParameter      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetFloatingParameter", libsimx))
c_SetFloatingParameter      = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetFloatingParameter", libsimx))
c_GetStringParameter        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetStringParameter", libsimx))
c_GetCollisionHandle        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetCollisionHandle", libsimx))
c_GetDistanceHandle         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetDistanceHandle", libsimx))
c_GetCollectionHandle       = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetCollectionHandle", libsimx))
c_ReadCollision             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxReadCollision", libsimx))
c_ReadDistance              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxReadDistance", libsimx))
c_RemoveObject              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveObject", libsimx))
c_RemoveModel               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveModel", libsimx))
c_RemoveUI                  = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxRemoveUI", libsimx))
c_CloseScene                = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32)(("simxCloseScene", libsimx))
c_GetObjects                = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.c_int32)(("simxGetObjects", libsimx))
c_DisplayDialog             = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.POINTER(ct.c_int32), ct.POINTER(ct.c_int32), ct.c_int32)(("simxDisplayDialog", libsimx))
c_EndDialog                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32)(("simxEndDialog", libsimx))
c_GetDialogInput            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetDialogInput", libsimx))
c_GetDialogResult           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetDialogResult", libsimx))
c_CopyPasteObjects          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32, ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxCopyPasteObjects", libsimx))
c_GetObjectSelection        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectSelection", libsimx))
c_SetObjectSelection        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32, ct.c_int32)(("simxSetObjectSelection", libsimx))
c_ClearFloatSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearFloatSignal", libsimx))
c_ClearIntegerSignal        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearIntegerSignal", libsimx))
c_ClearStringSignal         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxClearStringSignal", libsimx))
c_GetFloatSignal            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_float), ct.c_int32)(("simxGetFloatSignal", libsimx))
c_GetIntegerSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetIntegerSignal", libsimx))
c_GetStringSignal           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetStringSignal", libsimx))
c_SetFloatSignal            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_float, ct.c_int32)(("simxSetFloatSignal", libsimx))
c_SetIntegerSignal          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32)(("simxSetIntegerSignal", libsimx))
c_SetStringSignal           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxSetStringSignal", libsimx))
c_AppendStringSignal        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxAppendStringSignal", libsimx))
c_WriteStringStream         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.c_int32)(("simxWriteStringStream", libsimx))
c_GetObjectFloatParameter   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectFloatParameter", libsimx))
c_SetObjectFloatParameter   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_float, ct.c_int32)(("simxSetObjectFloatParameter", libsimx))
c_GetObjectIntParameter     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetObjectIntParameter", libsimx))
c_SetObjectIntParameter     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetObjectIntParameter", libsimx))
c_GetModelProperty          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetModelProperty", libsimx))
c_SetModelProperty          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.c_int32)(("simxSetModelProperty", libsimx))
c_Start                     = ct.CFUNCTYPE(ct.c_int32,ct.POINTER(ct.c_char), ct.c_int32, ct.c_ubyte, ct.c_ubyte, ct.c_int32, ct.c_int32)(("simxStart", libsimx))
c_Finish                    = ct.CFUNCTYPE(None, ct.c_int32)(("simxFinish", libsimx))
c_GetPingTime               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetPingTime", libsimx))
c_GetLastCmdTime            = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxGetLastCmdTime", libsimx))
c_SynchronousTrigger        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxSynchronousTrigger", libsimx))
c_Synchronous               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_ubyte)(("simxSynchronous", libsimx))
c_PauseCommunication        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_ubyte)(("simxPauseCommunication", libsimx))
c_GetInMessageInfo          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetInMessageInfo", libsimx))
c_GetOutMessageInfo         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32))(("simxGetOutMessageInfo", libsimx))
c_GetConnectionId           = ct.CFUNCTYPE(ct.c_int32,ct.c_int32)(("simxGetConnectionId", libsimx))
c_CreateBuffer              = ct.CFUNCTYPE(ct.POINTER(ct.c_ubyte), ct.c_int32)(("simxCreateBuffer", libsimx))
c_ReleaseBuffer             = ct.CFUNCTYPE(None, ct.c_void_p)(("simxReleaseBuffer", libsimx))
c_TransferFile              = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_char), ct.c_int32, ct.c_int32)(("simxTransferFile", libsimx))
c_EraseFile                 = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.c_int32)(("simxEraseFile", libsimx))
c_GetAndClearStringSignal   = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxGetAndClearStringSignal", libsimx))
c_ReadStringStream          = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxReadStringStream", libsimx))
c_CreateDummy               = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_float, ct.POINTER(ct.c_ubyte), ct.POINTER(ct.c_int32), ct.c_int32)(("simxCreateDummy", libsimx))
c_Query                     = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.c_ubyte), ct.c_int32, ct.POINTER(ct.c_char), ct.POINTER(ct.POINTER(ct.c_ubyte)), ct.POINTER(ct.c_int32), ct.c_int32)(("simxQuery", libsimx))
c_GetObjectGroupData        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.c_int32, ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)), ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)), ct.c_int32)(("simxGetObjectGroupData", libsimx))
c_GetObjectVelocity         = ct.CFUNCTYPE(ct.c_int32,ct.c_int32, ct.c_int32, ct.POINTER(ct.c_float), ct.POINTER(ct.c_float), ct.c_int32)(("simxGetObjectVelocity", libsimx))
c_CallScriptFunction        = ct.CFUNCTYPE(ct.c_int32,ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_int32),ct.c_int32,ct.POINTER(ct.c_float),ct.c_int32,ct.POINTER(ct.c_char),ct.c_int32,ct.POINTER(ct.c_ubyte),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_int32)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_float)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_char)),ct.POINTER(ct.c_int32), ct.POINTER(ct.POINTER(ct.c_ubyte)),ct.c_int32)(("simxCallScriptFunction", libsimx))

#API functions
</t>
<t tx="leo.20210713140957.20">def simxGetVisionSensorDepthBuffer(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    c_buffer  = ct.POINTER(ct.c_float)()
    resolution = (ct.c_int*2)()
    ret = c_GetVisionSensorDepthBuffer(clientID, sensorHandle, resolution, ct.byref(c_buffer), operationMode)
    reso = []
    buffer = []
    if (ret == 0):
        buffer = [None]*resolution[0]*resolution[1]
        for i in range(resolution[0] * resolution[1]):
            buffer[i] = c_buffer[i]
        for i in range(2):
            reso.append(resolution[i])
    return ret, reso, buffer

</t>
<t tx="leo.20210713140957.21">def simxGetObjectChild(clientID, parentObjectHandle, childIndex, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    childObjectHandle = ct.c_int()
    return c_GetObjectChild(clientID, parentObjectHandle, childIndex, ct.byref(childObjectHandle), operationMode), childObjectHandle.value

</t>
<t tx="leo.20210713140957.22">def simxGetObjectParent(clientID, childObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parentObjectHandle = ct.c_int()
    return c_GetObjectParent(clientID, childObjectHandle, ct.byref(parentObjectHandle), operationMode), parentObjectHandle.value

</t>
<t tx="leo.20210713140957.23">def simxReadProximitySensor(clientID, sensorHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    detectionState = ct.c_ubyte()
    detectedObjectHandle = ct.c_int()
    detectedPoint  = (ct.c_float*3)()
    detectedSurfaceNormalVector = (ct.c_float*3)()
    ret = c_ReadProximitySensor(clientID, sensorHandle, ct.byref(detectionState), detectedPoint, ct.byref(detectedObjectHandle), detectedSurfaceNormalVector, operationMode)
    arr1 = []
    for i in range(3):
        arr1.append(detectedPoint[i])
    arr2 = []
    for i in range(3):
        arr2.append(detectedSurfaceNormalVector[i])
    return ret, bool(detectionState.value!=0), arr1, detectedObjectHandle.value, arr2

</t>
<t tx="leo.20210713140957.24">def simxLoadModel(clientID, modelPathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    baseHandle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(modelPathAndName) is str):
        modelPathAndName=modelPathAndName.encode('utf-8')
    return c_LoadModel(clientID, modelPathAndName, options, ct.byref(baseHandle), operationMode), baseHandle.value

</t>
<t tx="leo.20210713140957.25">def simxLoadUI(clientID, uiPathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    count = ct.c_int()
    uiHandles = ct.POINTER(ct.c_int)()
    if (sys.version_info[0] == 3) and (type(uiPathAndName) is str):
        uiPathAndName=uiPathAndName.encode('utf-8')
    ret = c_LoadUI(clientID, uiPathAndName, options, ct.byref(count), ct.byref(uiHandles), operationMode)

    handles = []
    if ret == 0:
        for i in range(count.value):
            handles.append(uiHandles[i])
        #free C buffers
        c_ReleaseBuffer(uiHandles)

    return ret, handles

</t>
<t tx="leo.20210713140957.26">def simxLoadScene(clientID, scenePathAndName, options, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(scenePathAndName) is str):
        scenePathAndName=scenePathAndName.encode('utf-8')
    return c_LoadScene(clientID, scenePathAndName, options, operationMode)

</t>
<t tx="leo.20210713140957.27">def simxStartSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_StartSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140957.28">def simxPauseSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_PauseSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140957.29">def simxStopSimulation(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_StopSimulation(clientID, operationMode)

</t>
<t tx="leo.20210713140957.3">def simxGetJointPosition(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    position = ct.c_float()
    return c_GetJointPosition(clientID, jointHandle, ct.byref(position), operationMode), position.value

</t>
<t tx="leo.20210713140957.30">def simxGetUIHandle(clientID, uiName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(uiName) is str):
        uiName=uiName.encode('utf-8')
    return c_GetUIHandle(clientID, uiName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140957.31">def simxGetUISlider(clientID, uiHandle, uiButtonID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    position = ct.c_int()
    return c_GetUISlider(clientID, uiHandle, uiButtonID, ct.byref(position), operationMode), position.value

</t>
<t tx="leo.20210713140957.32">def simxSetUISlider(clientID, uiHandle, uiButtonID, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetUISlider(clientID, uiHandle, uiButtonID, position, operationMode)

</t>
<t tx="leo.20210713140957.33">def simxGetUIEventButton(clientID, uiHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    uiEventButtonID = ct.c_int()
    auxValues = (ct.c_int*2)()
    ret = c_GetUIEventButton(clientID, uiHandle, ct.byref(uiEventButtonID), auxValues, operationMode)
    arr = []
    for i in range(2):
        arr.append(auxValues[i])
    return ret, uiEventButtonID.value, arr

</t>
<t tx="leo.20210713140957.34">def simxGetUIButtonProperty(clientID, uiHandle, uiButtonID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    prop = ct.c_int()
    return c_GetUIButtonProperty(clientID, uiHandle, uiButtonID, ct.byref(prop), operationMode), prop.value

</t>
<t tx="leo.20210713140957.35">def simxSetUIButtonProperty(clientID, uiHandle, uiButtonID, prop, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetUIButtonProperty(clientID, uiHandle, uiButtonID, prop, operationMode)

</t>
<t tx="leo.20210713140957.36">def simxAddStatusbarMessage(clientID, message, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(message) is str):
        message=message.encode('utf-8')
    return c_AddStatusbarMessage(clientID, message, operationMode)

</t>
<t tx="leo.20210713140957.37">def simxAuxiliaryConsoleOpen(clientID, title, maxLines, mode, position, size, textColor, backgroundColor, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    consoleHandle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(title) is str):
        title=title.encode('utf-8')
    if position != None:
        c_position = (ct.c_int*2)(*position)
    else:
        c_position = None
    if size != None:
        c_size = (ct.c_int*2)(*size)
    else:
        c_size = None
    if textColor != None:
        c_textColor = (ct.c_float*3)(*textColor)
    else:
        c_textColor = None
    if backgroundColor != None:
        c_backgroundColor = (ct.c_float*3)(*backgroundColor)
    else:
        c_backgroundColor = None
    return c_AuxiliaryConsoleOpen(clientID, title, maxLines, mode, c_position, c_size, c_textColor, c_backgroundColor, ct.byref(consoleHandle), operationMode), consoleHandle.value

</t>
<t tx="leo.20210713140957.38">def simxAuxiliaryConsoleClose(clientID, consoleHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_AuxiliaryConsoleClose(clientID, consoleHandle, operationMode)

</t>
<t tx="leo.20210713140957.39">def simxAuxiliaryConsolePrint(clientID, consoleHandle, txt, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(txt) is str):
        txt=txt.encode('utf-8')
    return c_AuxiliaryConsolePrint(clientID, consoleHandle, txt, operationMode)

</t>
<t tx="leo.20210713140957.4">def simxSetJointPosition(clientID, jointHandle, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointPosition(clientID, jointHandle, position, operationMode)

</t>
<t tx="leo.20210713140957.40">def simxAuxiliaryConsoleShow(clientID, consoleHandle, showState, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_AuxiliaryConsoleShow(clientID, consoleHandle, showState, operationMode)

</t>
<t tx="leo.20210713140957.41">def simxGetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    eulerAngles = (ct.c_float*3)()
    ret = c_GetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, eulerAngles, operationMode)
    arr = []
    for i in range(3):
        arr.append(eulerAngles[i])
    return ret, arr

</t>
<t tx="leo.20210713140957.42">def simxGetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    quaternion = (ct.c_float*4)()
    ret = c_GetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quaternion, operationMode)
    arr = []
    for i in range(4):
        arr.append(quaternion[i])
    return ret, arr

</t>
<t tx="leo.20210713140957.43">def simxGetObjectPosition(clientID, objectHandle, relativeToObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    position = (ct.c_float*3)()
    ret = c_GetObjectPosition(clientID, objectHandle, relativeToObjectHandle, position, operationMode)
    arr = []
    for i in range(3):
        arr.append(position[i])
    return ret, arr

</t>
<t tx="leo.20210713140957.44">def simxSetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, eulerAngles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    angles = (ct.c_float*3)(*eulerAngles)
    return c_SetObjectOrientation(clientID, objectHandle, relativeToObjectHandle, angles, operationMode)

</t>
<t tx="leo.20210713140957.45">def simxSetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quaternion, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    quat = (ct.c_float*4)(*quaternion)
    return c_SetObjectQuaternion(clientID, objectHandle, relativeToObjectHandle, quat, operationMode)

</t>
<t tx="leo.20210713140957.46">def simxSetObjectPosition(clientID, objectHandle, relativeToObjectHandle, position, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_position = (ct.c_float*3)(*position)
    return c_SetObjectPosition(clientID, objectHandle, relativeToObjectHandle, c_position, operationMode)

</t>
<t tx="leo.20210713140957.47">def simxSetObjectParent(clientID, objectHandle, parentObject, keepInPlace, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectParent(clientID, objectHandle, parentObject, keepInPlace, operationMode)

</t>
<t tx="leo.20210713140957.48">def simxSetUIButtonLabel(clientID, uiHandle, uiButtonID, upStateLabel, downStateLabel, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if sys.version_info[0] == 3:
        if type(upStateLabel) is str:
            upStateLabel=upStateLabel.encode('utf-8')
        if type(downStateLabel) is str:
            downStateLabel=downStateLabel.encode('utf-8')
    return c_SetUIButtonLabel(clientID, uiHandle, uiButtonID, upStateLabel, downStateLabel, operationMode)

</t>
<t tx="leo.20210713140957.49">def simxGetLastErrors(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    errors =[]
    errorCnt = ct.c_int()
    errorStrings = ct.POINTER(ct.c_char)()
    ret = c_GetLastErrors(clientID, ct.byref(errorCnt), ct.byref(errorStrings), operationMode)
    if ret == 0:
        s = 0
        for i in range(errorCnt.value):
            a = bytearray()
            while errorStrings[s] != b'\0':
                if sys.version_info[0] == 3:
                    a.append(int.from_bytes(errorStrings[s],'big'))
                else:
                    a.append(errorStrings[s])
                s += 1
            s += 1 #skip null
            if sys.version_info[0] == 3:
                errors.append(str(a,'utf-8'))
            else:
                errors.append(str(a))

    return ret, errors

</t>
<t tx="leo.20210713140957.5">def simxGetJointMatrix(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    matrix = (ct.c_float*12)()
    ret = c_GetJointMatrix(clientID, jointHandle, matrix, operationMode)
    arr = []
    for i in range(12):
        arr.append(matrix[i])
    return ret, arr

</t>
<t tx="leo.20210713140957.50">def simxGetArrayParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    paramValues = (ct.c_float*3)()
    ret = c_GetArrayParameter(clientID, paramIdentifier, paramValues, operationMode)
    arr = []
    for i in range(3):
        arr.append(paramValues[i])
    return ret, arr

</t>
<t tx="leo.20210713140957.51">def simxSetArrayParameter(clientID, paramIdentifier, paramValues, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_paramValues = (ct.c_float*3)(*paramValues)
    return c_SetArrayParameter(clientID, paramIdentifier, c_paramValues, operationMode)

</t>
<t tx="leo.20210713140957.52">def simxGetBooleanParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_ubyte()
    return c_GetBooleanParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), bool(paramValue.value!=0)

</t>
<t tx="leo.20210713140957.53">def simxSetBooleanParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetBooleanParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140957.54">def simxGetIntegerParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_int()
    return c_GetIntegerParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), paramValue.value

</t>
<t tx="leo.20210713140957.55">def simxSetIntegerParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetIntegerParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140957.56">def simxGetFloatingParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    paramValue = ct.c_float()
    return c_GetFloatingParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode), paramValue.value

</t>
<t tx="leo.20210713140957.57">def simxSetFloatingParameter(clientID, paramIdentifier, paramValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetFloatingParameter(clientID, paramIdentifier, paramValue, operationMode)

</t>
<t tx="leo.20210713140957.58">def simxGetStringParameter(clientID, paramIdentifier, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    paramValue = ct.POINTER(ct.c_char)()
    ret = c_GetStringParameter(clientID, paramIdentifier, ct.byref(paramValue), operationMode)

    a = bytearray()
    if ret == 0:
        i = 0
        while paramValue[i] != b'\0':
            if sys.version_info[0] == 3:
                a.append(int.from_bytes(paramValue[i],'big'))
            else:
                a.append(paramValue[i])
            i=i+1
    if sys.version_info[0] == 3:
        a=str(a,'utf-8')
    else:
        a=str(a)
    return ret, a

</t>
<t tx="leo.20210713140957.59">def simxGetCollisionHandle(clientID, collisionObjectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(collisionObjectName) is str):
        collisionObjectName=collisionObjectName.encode('utf-8')
    return c_GetCollisionHandle(clientID, collisionObjectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140957.6">def simxSetSphericalJointMatrix(clientID, jointHandle, matrix, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    matrix = (ct.c_float*12)(*matrix)
    return c_SetSphericalJointMatrix(clientID, jointHandle, matrix, operationMode)

</t>
<t tx="leo.20210713140957.60">def simxGetCollectionHandle(clientID, collectionName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(collectionName) is str):
        collectionName=collectionName.encode('utf-8')
    return c_GetCollectionHandle(clientID, collectionName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140957.61">def simxGetDistanceHandle(clientID, distanceObjectName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    handle = ct.c_int()
    if (sys.version_info[0] == 3) and (type(distanceObjectName) is str):
        distanceObjectName=distanceObjectName.encode('utf-8')
    return c_GetDistanceHandle(clientID, distanceObjectName, ct.byref(handle), operationMode), handle.value

</t>
<t tx="leo.20210713140957.62">def simxReadCollision(clientID, collisionObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    collisionState = ct.c_ubyte()
    return c_ReadCollision(clientID, collisionObjectHandle, ct.byref(collisionState), operationMode), bool(collisionState.value!=0)

</t>
<t tx="leo.20210713140957.63">def simxReadDistance(clientID, distanceObjectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    minimumDistance = ct.c_float()
    return c_ReadDistance(clientID, distanceObjectHandle, ct.byref(minimumDistance), operationMode), minimumDistance.value

</t>
<t tx="leo.20210713140957.64">def simxRemoveObject(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveObject(clientID, objectHandle, operationMode)

</t>
<t tx="leo.20210713140957.65">def simxRemoveModel(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveModel(clientID, objectHandle, operationMode)

</t>
<t tx="leo.20210713140957.66">def simxRemoveUI(clientID, uiHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_RemoveUI(clientID, uiHandle, operationMode)

</t>
<t tx="leo.20210713140957.67">def simxCloseScene(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_CloseScene(clientID, operationMode)

</t>
<t tx="leo.20210713140957.68">def simxGetObjects(clientID, objectType, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    objectCount = ct.c_int()
    objectHandles = ct.POINTER(ct.c_int)()

    ret = c_GetObjects(clientID, objectType, ct.byref(objectCount), ct.byref(objectHandles), operationMode)
    handles = []
    if ret == 0:
        for i in range(objectCount.value):
            handles.append(objectHandles[i])

    return ret, handles


</t>
<t tx="leo.20210713140957.69">def simxDisplayDialog(clientID, titleText, mainText, dialogType, initialText, titleColors, dialogColors, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    if titleColors != None:
        c_titleColors  = (ct.c_float*6)(*titleColors)
    else:
        c_titleColors  = None
    if dialogColors != None:
        c_dialogColors  = (ct.c_float*6)(*dialogColors)
    else:
        c_dialogColors  = None

    c_dialogHandle = ct.c_int()
    c_uiHandle = ct.c_int()
    if sys.version_info[0] == 3:
        if type(titleText) is str:
            titleText=titleText.encode('utf-8')
        if type(mainText) is str:
            mainText=mainText.encode('utf-8')
        if type(initialText) is str:
            initialText=initialText.encode('utf-8')
    return c_DisplayDialog(clientID, titleText, mainText, dialogType, initialText, c_titleColors, c_dialogColors, ct.byref(c_dialogHandle), ct.byref(c_uiHandle), operationMode), c_dialogHandle.value, c_uiHandle.value

</t>
<t tx="leo.20210713140957.7">def simxSetJointTargetVelocity(clientID, jointHandle, targetVelocity, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointTargetVelocity(clientID, jointHandle, targetVelocity, operationMode)

</t>
<t tx="leo.20210713140957.70">def simxEndDialog(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_EndDialog(clientID, dialogHandle, operationMode)

</t>
<t tx="leo.20210713140957.71">def simxGetDialogInput(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    inputText = ct.POINTER(ct.c_char)()
    ret = c_GetDialogInput(clientID, dialogHandle, ct.byref(inputText), operationMode)

    a = bytearray()
    if ret == 0:
        i = 0
        while inputText[i] != b'\0':
            if sys.version_info[0] == 3:
                a.append(int.from_bytes(inputText[i],'big'))
            else:
                a.append(inputText[i])
            i = i+1

    if sys.version_info[0] == 3:
        a=str(a,'utf-8')
    else:
        a=str(a)
    return ret, a


</t>
<t tx="leo.20210713140957.72">def simxGetDialogResult(clientID, dialogHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    result = ct.c_int()
    return c_GetDialogResult(clientID, dialogHandle, ct.byref(result), operationMode), result.value

</t>
<t tx="leo.20210713140957.73">def simxCopyPasteObjects(clientID, objectHandles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    c_objectHandles  = (ct.c_int*len(objectHandles))(*objectHandles)
    c_objectHandles = ct.cast(c_objectHandles,ct.POINTER(ct.c_int)) # IronPython needs this
    newObjectCount   = ct.c_int()
    newObjectHandles = ct.POINTER(ct.c_int)()
    ret = c_CopyPasteObjects(clientID, c_objectHandles, len(objectHandles), ct.byref(newObjectHandles), ct.byref(newObjectCount), operationMode)

    newobj = []
    if ret == 0:
        for i in range(newObjectCount.value):
            newobj.append(newObjectHandles[i])

    return ret, newobj


</t>
<t tx="leo.20210713140957.74">def simxGetObjectSelection(clientID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    objectCount   = ct.c_int()
    objectHandles = ct.POINTER(ct.c_int)()
    ret = c_GetObjectSelection(clientID, ct.byref(objectHandles), ct.byref(objectCount), operationMode)

    newobj = []
    if ret == 0:
        for i in range(objectCount.value):
            newobj.append(objectHandles[i])

    return ret, newobj



</t>
<t tx="leo.20210713140957.75">def simxSetObjectSelection(clientID, objectHandles, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    c_objectHandles  = (ct.c_int*len(objectHandles))(*objectHandles)
    return c_SetObjectSelection(clientID, c_objectHandles, len(objectHandles), operationMode)

</t>
<t tx="leo.20210713140957.76">def simxClearFloatSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearFloatSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140957.77">def simxClearIntegerSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearIntegerSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140957.78">def simxClearStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_ClearStringSignal(clientID, signalName, operationMode)

</t>
<t tx="leo.20210713140957.79">def simxGetFloatSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalValue = ct.c_float()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_GetFloatSignal(clientID, signalName, ct.byref(signalValue), operationMode), signalValue.value

</t>
<t tx="leo.20210713140957.8">def simxSetJointTargetPosition(clientID, jointHandle, targetPosition, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetJointTargetPosition(clientID, jointHandle, targetPosition, operationMode)

</t>
<t tx="leo.20210713140957.80">def simxGetIntegerSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalValue = ct.c_int()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_GetIntegerSignal(clientID, signalName, ct.byref(signalValue), operationMode), signalValue.value

</t>
<t tx="leo.20210713140957.81">def simxGetStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_GetStringSignal(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140957.82">def simxGetAndClearStringSignal(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_GetAndClearStringSignal(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140957.83">def simxReadStringStream(clientID, signalName, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    signalLength = ct.c_int();
    signalValue = ct.POINTER(ct.c_ubyte)()
    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    ret = c_ReadStringStream(clientID, signalName, ct.byref(signalValue), ct.byref(signalLength), operationMode)

    a = bytearray()
    if ret == 0:
        for i in range(signalLength.value):
            a.append(signalValue[i])
    if sys.version_info[0] != 3:
        a=str(a)

    return ret, a

</t>
<t tx="leo.20210713140957.84">def simxSetFloatSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_SetFloatSignal(clientID, signalName, signalValue, operationMode)

</t>
<t tx="leo.20210713140957.85">def simxSetIntegerSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(signalName) is str):
        signalName=signalName.encode('utf-8')
    return c_SetIntegerSignal(clientID, signalName, signalValue, operationMode)

</t>
<t tx="leo.20210713140957.86">def simxSetStringSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_SetStringSignal(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140957.87">def simxAppendStringSignal(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_AppendStringSignal(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140957.88">def simxWriteStringStream(clientID, signalName, signalValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    sigV=signalValue
    if sys.version_info[0] == 3:
        if type(signalName) is str:
            signalName=signalName.encode('utf-8')
        if type(signalValue) is bytearray:
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=signalValue.encode('utf-8')
            sigV  = (ct.c_ubyte*len(signalValue))(*signalValue)
    else:
        if type(signalValue) is bytearray:
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
        if type(signalValue) is str:
            signalValue=bytearray(signalValue)
            sigV = (ct.c_ubyte*len(signalValue))(*signalValue)
    sigV=ct.cast(sigV,ct.POINTER(ct.c_ubyte)) # IronPython needs this
    return c_WriteStringStream(clientID, signalName, sigV, len(signalValue), operationMode)

</t>
<t tx="leo.20210713140957.89">def simxGetObjectFloatParameter(clientID, objectHandle, parameterID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parameterValue = ct.c_float()
    return c_GetObjectFloatParameter(clientID, objectHandle, parameterID, ct.byref(parameterValue), operationMode), parameterValue.value

</t>
<t tx="leo.20210713140957.9">def simxJointGetForce(clientID, jointHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    force = ct.c_float()
    return c_GetJointForce(clientID, jointHandle, ct.byref(force), operationMode), force.value

</t>
<t tx="leo.20210713140957.90">def simxSetObjectFloatParameter(clientID, objectHandle, parameterID, parameterValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectFloatParameter(clientID, objectHandle, parameterID, parameterValue, operationMode)

</t>
<t tx="leo.20210713140957.91">def simxGetObjectIntParameter(clientID, objectHandle, parameterID, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    parameterValue = ct.c_int()
    return c_GetObjectIntParameter(clientID, objectHandle, parameterID, ct.byref(parameterValue), operationMode), parameterValue.value

</t>
<t tx="leo.20210713140957.92">def simxSetObjectIntParameter(clientID, objectHandle, parameterID, parameterValue, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetObjectIntParameter(clientID, objectHandle, parameterID, parameterValue, operationMode)

</t>
<t tx="leo.20210713140957.93">def simxGetModelProperty(clientID, objectHandle, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    prop = ct.c_int()
    return c_GetModelProperty(clientID, objectHandle, ct.byref(prop), operationMode), prop.value

</t>
<t tx="leo.20210713140957.94">def simxSetModelProperty(clientID, objectHandle, prop, operationMode):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SetModelProperty(clientID, objectHandle, prop, operationMode)

</t>
<t tx="leo.20210713140957.95">def simxStart(connectionAddress, connectionPort, waitUntilConnected, doNotReconnectOnceDisconnected, timeOutInMs, commThreadCycleInMs):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    if (sys.version_info[0] == 3) and (type(connectionAddress) is str):
        connectionAddress=connectionAddress.encode('utf-8')
    return c_Start(connectionAddress, connectionPort, waitUntilConnected, doNotReconnectOnceDisconnected, timeOutInMs, commThreadCycleInMs)

</t>
<t tx="leo.20210713140957.96">def simxFinish(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_Finish(clientID)

</t>
<t tx="leo.20210713140957.97">def simxGetPingTime(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''
    pingTime = ct.c_int()
    return c_GetPingTime(clientID, ct.byref(pingTime)), pingTime.value

</t>
<t tx="leo.20210713140957.98">def simxGetLastCmdTime(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_GetLastCmdTime(clientID)

</t>
<t tx="leo.20210713140957.99">def simxSynchronousTrigger(clientID):
    '''
    Please have a look at the function description/documentation in the CoppeliaSim user manual
    '''

    return c_SynchronousTrigger(clientID)

</t>
</tnodes>
</leo_file>
